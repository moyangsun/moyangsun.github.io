<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ Primer 第二部分 | blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="陌小阳的博客">
    <meta name="description" content="this is my blog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.47a191c6.css" as="style"><link rel="preload" href="/assets/js/app.c8e3a0f1.js" as="script"><link rel="preload" href="/assets/js/3.1f40c1f2.js" as="script"><link rel="preload" href="/assets/js/1.fd77260d.js" as="script"><link rel="preload" href="/assets/js/14.645c3afc.js" as="script"><link rel="prefetch" href="/assets/js/10.27468c1b.js"><link rel="prefetch" href="/assets/js/11.02b03c80.js"><link rel="prefetch" href="/assets/js/12.15f74c8b.js"><link rel="prefetch" href="/assets/js/13.93844b51.js"><link rel="prefetch" href="/assets/js/15.54763910.js"><link rel="prefetch" href="/assets/js/16.7ce4fb83.js"><link rel="prefetch" href="/assets/js/17.2a6c8b67.js"><link rel="prefetch" href="/assets/js/18.5af2a41f.js"><link rel="prefetch" href="/assets/js/19.8a6002cd.js"><link rel="prefetch" href="/assets/js/20.13402627.js"><link rel="prefetch" href="/assets/js/21.72517caa.js"><link rel="prefetch" href="/assets/js/22.b9eb4d25.js"><link rel="prefetch" href="/assets/js/4.51d906d3.js"><link rel="prefetch" href="/assets/js/5.2b3573cc.js"><link rel="prefetch" href="/assets/js/6.b8c0fc1c.js"><link rel="prefetch" href="/assets/js/7.d62414bd.js"><link rel="prefetch" href="/assets/js/8.69f56ef7.js"><link rel="prefetch" href="/assets/js/9.d4a50642.js">
    <link rel="stylesheet" href="/assets/css/0.styles.47a191c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>blog</h3> <p class="description" data-v-59e6cb88>this is my blog</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>mo_xiao_yang</span>
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/C++/" class="nav-link"><i class="undefined"></i>
  C++
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  else
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Computer Fundamentals/" class="nav-link"><i class="undefined"></i>
  Computer Fundamentals
</a></li><li class="dropdown-item"><!----> <a href="/categories/CMake/" class="nav-link"><i class="undefined"></i>
  CMake
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun/md_notebook" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  md文档仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/pikaqiu.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    mo_xiao_yang
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>12</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>5</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/C++/" class="nav-link"><i class="undefined"></i>
  C++
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  else
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Computer Fundamentals/" class="nav-link"><i class="undefined"></i>
  Computer Fundamentals
</a></li><li class="dropdown-item"><!----> <a href="/categories/CMake/" class="nav-link"><i class="undefined"></i>
  CMake
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun/md_notebook" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  md文档仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>C++ Primer 第二部分</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>mo_xiao_yang</span>
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">C++ Primer 第二部分</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>mo_xiao_yang</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>4/27/2024</span></i> <i class="iconfont reco-eye" data-v-8a445198><span id="/blogs/category1/2024/C++%20Primer%20Two.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-8a445198><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>C++</span></i></div></div> <div class="theme-reco-content content__default"><div class="custom-block tip"><p class="title"></p><p>该笔记是C++ Primer 第二部分，笔记参考了https://github.com/czs108/C++-Primer-5th-Notes-CN/
（未完成）</p></div><h1 id="c-标准库"><a href="#c-标准库" class="header-anchor">#</a> C++标准库</h1> <h2 id="第八章-io库"><a href="#第八章-io库" class="header-anchor">#</a> 第八章 IO库</h2> <p>​		之前已经接触到过的IO库中的设施：</p> <ul><li><code>istream</code>(输入流)类型，提供输入操作。</li> <li><code>ostream</code>(输出流)类型，提供输出操作。</li> <li><code>cin</code>，一个<code>istream</code> 对象，从标准输入读取数据。</li> <li><code>cout</code>，一个<code>ostream</code> 对象，向标准输出写入数据。</li> <li><code>cerr</code>，一个<code>ostream</code> 对象，通常用于输出程序错误消息，写入到标准数据</li> <li><code>&gt;&gt;</code>运算符，用来从一个<code>istream</code> 对象读取输入数据</li> <li><code>&lt;&lt;</code>运算符，用来向一个<code>ostream</code> 对象写入输出数据</li> <li>getline 函数，从一个给定的 <code>istream</code> 读取一行数据,存入一个给定的 <code>string</code> 对象中。</li></ul> <h3 id="_8-1-io类"><a href="#_8-1-io类" class="header-anchor">#</a> 8.1 IO类</h3> <p>​		头文件<code>iostream</code>定义了用于读写流的基本类型，<code>fstream</code>定义了读写命名文件的类型，<code>sstream</code>定义了读写内存中<code>string</code>对象的类型。</p> <ul><li><p>头文件<code>iostream</code>：</p> <table><thead><tr><th>类型</th> <th>用法</th></tr></thead> <tbody><tr><td><code>istream</code>、<code>wistream</code></td> <td>从流读取数据</td></tr> <tr><td><code>ostream</code>、<code>wostream</code></td> <td>向流写入数据</td></tr> <tr><td><code>iostream</code>、<code>wiostream</code></td> <td>读写流</td></tr></tbody></table></li> <li><p>头文件<code>fstream</code>：</p> <table><thead><tr><th>类型</th> <th>用法</th></tr></thead> <tbody><tr><td><code>ifstream</code>、<code>wifstream</code></td> <td>从文件读取数据</td></tr> <tr><td><code>ofstream</code>、<code>wofstream</code></td> <td>向文件写入数据</td></tr> <tr><td><code>fstream</code>、<code>wfstream</code></td> <td>读写文件</td></tr></tbody></table></li> <li><p>头文件<code>sstream</code>：</p> <table><thead><tr><th>类型</th> <th>用法</th></tr></thead> <tbody><tr><td><code>istringstream</code>、<code>wistringstream</code></td> <td>从<code>string</code>读取数据</td></tr> <tr><td><code>ostringstream</code>、<code>wostringstream</code></td> <td>向<code>string</code>写入数据</td></tr> <tr><td><code>stringstream</code>、<code>wstringstream</code></td> <td>读写<code>string</code></td></tr></tbody></table></li></ul> <p>​		宽字符版本的IO类型和函数的名字以<code>w</code>开始，如<code>wcin</code>、<code>wcout</code>和<code>wcerr</code>分别对应<code>cin</code>、<code>cout</code>和<code>cerr</code>。它们与其对应的普通<code>char</code>版本都定义在同一个头文件中，如头文件<code>fstream</code>定义了<code>ifstream</code>和<code>wifstream</code>类型。</p> <p><strong>IO类型间的关系</strong></p> <p>​		可以将派生类的对象当作其基类的对象使用。例如：类型<code>ifstream</code>和<code>istringstream</code> 都继承自 <code>istream</code>。因此，我们可以像使用<code>istream</code>对象一样来使用<code>ifstream</code>和<code>istringstream</code>对象。</p> <h4 id="io对象无拷贝或赋值"><a href="#io对象无拷贝或赋值" class="header-anchor">#</a> IO对象无拷贝或赋值</h4> <p>​		我们不能拷贝或对IO对象赋值：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>ofstream out1<span class="token punctuation">,</span> out2<span class="token punctuation">;</span>
out1 <span class="token operator">=</span> out2<span class="token punctuation">;</span>    <span class="token comment">// 错误：不能对流对象赋值</span>
ofstream <span class="token function">print</span><span class="token punctuation">(</span>ofstream<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 错误：不能初始化ofstream参数</span>
out2 <span class="token operator">=</span> <span class="token function">print</span><span class="token punctuation">(</span>out2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 错误：不能拷贝流对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p> <h4 id="条件状态"><a href="#条件状态" class="header-anchor">#</a> 条件状态</h4> <p>​		IO 操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。</p> <table><thead><tr><th>状态</th> <th>含义</th></tr></thead> <tbody><tr><td><code>strm::iostate</code></td> <td>流的条件状态</td></tr> <tr><td><code>strm::badbit</code></td> <td>流已崩溃</td></tr> <tr><td><code>strm::failbit</code></td> <td>一个IO操作失败</td></tr> <tr><td><code>strm::badbit</code></td> <td>流已崩溃</td></tr> <tr><td><code>s.eof()</code></td> <td>若流<code>s</code>的<code>eofbit</code>置位，返回<code>true</code></td></tr> <tr><td><code>s.fail()</code></td> <td>若流<code>s</code>的<code>failbit</code>或<code>badbit</code>置位，返回<code>true</code></td></tr> <tr><td><code>s.bad()</code></td> <td>若流<code>s</code>的<code>badbit</code>置位，返回<code>true</code></td></tr> <tr><td><code>s.good()</code></td> <td>若流<code>s</code>处于有效状态，返回<code>true</code></td></tr> <tr><td><code>s.clear()</code></td> <td>将流<code>s</code>的所有条件状态复位并将流置为有效</td></tr> <tr><td><code>s.clear(flags)</code></td> <td>将流<code>s</code>的条件状态置为<code>flags</code></td></tr> <tr><td><code>s.rdstate()</code></td> <td>返回流的条件状态</td></tr></tbody></table> <p>​		在输入过程中，若是输入的值和所定义的类型不同，则会导致输入进入错误状态。一旦一个流发生错误，则后面的操作都会错误。我们需要保证流一直处于一个无措状态。我们可以将流对象当作一个对象来使用：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ival<span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> ival<span class="token punctuation">;</span><span class="token comment">// 若输入Boo则会导致输入流错误</span>

<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>查询流的状态</strong></p> <p>​		<code>IO</code> 库定义了4个 <code>iostate</code> 类型的 <code>constexpr</code> 值,表示特定的位模式。这些值用来表示特定类型的<code>IO</code>条件，可以与位运算符一起使用来一次性检测或设置多个标志位。</p> <p>​		<code>badbit</code>表示系统级错误，如不可恢复的读写错误。通常情况下，一旦<code>badbit</code>被置位，流就无法继续使用了。在发生可恢复错误后，<code>failbit</code>会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，<code>eofbit</code>和<code>failbit</code>都会被置位。如果流未发生错误，则<code>goodbit</code>的值为0。如果<code>badbit</code>、<code>failbit</code>和<code>eofbit</code>任何一个被置位，检测流状态的条件都会失败。</p> <p>​		<code>good</code>函数在所有错误均未置位时返回<code>true</code>。而<code>bad</code>、<code>fail</code>和<code>eof</code>函数在对应错误位被置位时返回<code>true</code>。此外，在<code>badbit</code>被置位时，<code>fail</code>函数也会返回<code>true</code>。因此应该使用<code>good</code>或<code>fail</code>函数确定流的总体状态，<code>eof</code>和<code>bad</code>只能检测特定错误。</p> <p><strong>管理条件状态</strong></p> <p>​		每个输出流都管理一个缓冲区，用于保存程序读写的数据。导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多：</p> <ul><li>程序正常结束。</li> <li>缓冲区已满。</li> <li>使用操纵符（如<code>endl</code>）显式刷新缓冲区。</li> <li>在每个输出操作之后，可以用<code>unitbuf</code>操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</li> <li>一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，因此，读<code>cin</code>或写<code>cerr</code>都会刷新<code>cout</code>的缓冲区。</li></ul> <p><strong>刷新输出缓冲区</strong></p> <p>​		操纵符 <code>end1</code>，它完成换行并刷新缓冲区的工作。<code>flush</code> 刷新缓冲区，但不输出任何额外的字符;<code>ends</code> 向缓冲区插入一个空字符，然后刷新缓冲区:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;hi!&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 输出 hi 和一个换行，然后刷新缓冲区</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;hi!&quot;</span> <span class="token operator">&lt;&lt;</span> flush<span class="token punctuation">;</span>  <span class="token comment">// 输出 hi，然后刷新缓冲区，不附加任何额外字符</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;hi!&quot;</span> <span class="token operator">&lt;&lt;</span> ends<span class="token punctuation">;</span>   <span class="token comment">// 输出 hi 和一个空字符，然后刷新缓冲区</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>ubitbuf操作符</strong></p> <p>​		如果想在每次输出操作后都刷新缓冲区，可以使用<code>unitbuf</code>操纵符。它令流在接下来的每次写操作后都进行一次<code>flush</code>操作。而<code>nounitbuf</code>操纵符则使流恢复使用正常的缓冲区刷新机制。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> unitbuf<span class="token punctuation">;</span>    <span class="token comment">// 所有输出操作后都会立即刷新缓冲区</span>
<span class="token comment">// 任何输出都立即刷新，无缓冲</span>
cout <span class="token operator">&lt;&lt;</span> nounitbuf<span class="token punctuation">;</span>  <span class="token comment">// 回到正常的缓冲方式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		警告：如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩渍后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p> <p><strong>关联输入和输出流</strong></p> <p>​		交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。即在<code>cin</code>前会先刷新<code>cout</code>缓冲区。</p> <p>​		使用<code>tie</code>函数可以关联两个流。它有两个重载版本：无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。<code>tie</code>的第二个版本接受一个指向<code>ostream</code>的指针，将本对象关联到此<code>ostream</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 仅仅是用来展示:标准库将 cin 和 cout 关联在一起</span>
<span class="token comment">// old tie指向当前关联到 cin 的流(如果有的话)</span>
ostream <span class="token operator">*</span>old_tie <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// cin 不再与其他流关联</span>
<span class="token comment">// 将cin与cerr 关联;这不是一个好主意，因为 cin 应该关联到 cout</span>
cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cerr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 读取 cin 会刷新 cerr而不是 cout</span>
cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span>old_tie<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 重建 cin和 cout 间的正常关联</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		每个流同时最多关联一个流，但多个流可以同时关联同一个<code>ostream</code>。向<code>tie</code>传递空指针可以解开流的关联。</p> <h3 id="_8-2-文件输入输出"><a href="#_8-2-文件输入输出" class="header-anchor">#</a> 8.2 文件输入输出</h3> <p>​		头文件<code>fstream</code>定义了三个类型来支持文件IO：<code>ifstream</code>从给定文件读取数据，<code>ofstream</code>向指定文件写入数据，<code>fstream</code>可以同时读写指定文件。</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>fstream fstrm(s)</code></td> <td>打开<code>s</code>文件，打开模式取决于<code>fstream</code></td></tr> <tr><td><code>fstream fstrm(s, mode)</code></td> <td>以<code>mode</code>模式打开<code>s</code>文件</td></tr> <tr><td><code>fstrm.close()</code></td> <td>关闭文件</td></tr> <tr><td><code>fstrm.is_open()</code></td> <td>如果文件成功打开并尚未关闭，返回<code>true</code></td></tr></tbody></table> <h4 id="使用文件流对象"><a href="#使用文件流对象" class="header-anchor">#</a> 使用文件流对象</h4> <p>​		创建文件流对象时,我们可以提供文件名(可选的)。如果提供了一个文件名，则 <code>open</code>会自动被调用:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>ifstream <span class="token function">in</span><span class="token punctuation">(</span>ifile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造一个ifstream 并打开给定文件</span>
ofstream out<span class="token punctuation">;</span><span class="token comment">// 输出文件流未关联到任何文件</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		在C++11中，文件流对象的文件名可以是<code>string</code>对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。</p> <p><strong>用fstream 代替iostream&amp;</strong></p> <p>​		在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受<code>iostream</code>类型引用或指针参数的函数，可以用对应的<code>fstream</code>类型来调用。</p> <p><strong>成员函数open和close</strong></p> <p>​		可以先定义空文件流对象，再调用<code>open</code>函数将其与指定文件关联。如果<code>open</code>调用失败，<code>failbit</code>会被置位。</p> <p>​		对一个已经打开的文件流调用<code>open</code>会失败，并导致<code>failbit</code>被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用<code>close</code>关闭当前文件，再调用<code>clear</code>重置流的条件状态（<code>close</code>不会重置流的条件状态）。</p> <p><strong>自动构造和析构</strong></p> <p>​		当<code>fstream</code>对象被销毁时，<code>close</code>会自动被调用。</p> <h4 id="文件模式"><a href="#文件模式" class="header-anchor">#</a> 文件模式</h4> <p>每个流都有一个关联的文件模式，用来指出如何使用文件。</p> <table><thead><tr><th>模式</th> <th>含义</th></tr></thead> <tbody><tr><td><code>in</code></td> <td>以读方式打开</td></tr> <tr><td><code>out</code></td> <td>以写方式打开</td></tr> <tr><td><code>app</code></td> <td>每次写操作前定位到文件末尾</td></tr> <tr><td><code>ate</code></td> <td>打开文件后立即定位到文件末尾</td></tr> <tr><td><code>trunc</code></td> <td>截断文件</td></tr> <tr><td><code>binary</code></td> <td>以二进制方式读写</td></tr></tbody></table> <ul><li><p>只能对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式。</p></li> <li><p>只能对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式。</p></li> <li><p>只有当<code>out</code>被设定时才能设定<code>trunc</code>模式。</p></li> <li><p>只要<code>trunc</code>没被设定，就能设定<code>app</code>模式。在<code>app</code>模式下，即使没有设定<code>out</code>模式，文件也是以输出方式打开。</p></li> <li><p>默认情况下，即使没有设定<code>trunc</code>，以<code>out</code>模式打开的文件也会被截断。如果想保留以<code>out</code>模式打开的文件内容，就必须同时设定<code>app</code>模式，这会将数据追加写到文件末尾；或者同时设定<code>in</code>模式，即同时进行读写操作。</p></li> <li><p><code>ate</code>和<code>binary</code>模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。</p></li> <li><p>与<code>ifstream</code>对象关联的文件默认以<code>in</code>模式打开，与<code>ofstream</code>对象关联的文件默认以<code>out</code>模式打开，与<code>fstream</code>对象关联的文件默认以<code>in</code>和<code>out</code>模式打开。</p> <p>​</p></li></ul> <p><strong>以out模式打开文件会丢弃已有数据</strong></p> <div class="language- extra-class"><pre><code>     默认情况下，打开`ofstream`对象时，文件内容会被丢弃，阻止文件清空的方法是同时指定`app`或`in`模式。
</code></pre></div><p><strong>每次调用open 时都会确定文件模式</strong></p> <p>​		流对象每次打开文件时都可以改变其文件模式。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>ofstream out<span class="token punctuation">;</span>   <span class="token comment">// 未指定文件打开模式</span>
out<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;scratchpad&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 模式隐含设置为输出和截断</span>
out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭 out，以便我们将其用于其他文件</span>
out<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;precious&quot;</span><span class="token punctuation">,</span> ofstream<span class="token double-colon punctuation">::</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 模式为输出和追加</span>
out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_8-3string流"><a href="#_8-3string流" class="header-anchor">#</a> 8.3string流</h3> <p>​		头文件<code>sstream</code>定义了三个类型来支持内存IO：<code>istringstream</code>从<code>string</code>读取数据，<code>ostringstream</code>向<code>string</code>写入数据，<code>stringstream</code>可以同时读写<code>string</code>的数据。</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>sstream strm(s)</code></td> <td><code>strm</code>保存<code>string s</code>的拷贝</td></tr> <tr><td><code>strm.str()</code></td> <td>返回<code>strm</code>中的<code>string</code></td></tr> <tr><td><code>strm.str(s)</code></td> <td>将<code>string s</code>拷贝至<code>strm</code></td></tr></tbody></table> <h4 id="使用istringstream"><a href="#使用istringstream" class="header-anchor">#</a> 使用istringstream</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 成员默认为公有</span>
<span class="token keyword">struct</span> <span class="token class-name">PersonInfo</span>
<span class="token punctuation">{</span>
    string name<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> phones<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

string line<span class="token punctuation">,</span> word<span class="token punctuation">;</span>   <span class="token comment">// 分别保存来自输入的一行和单词</span>
vector<span class="token operator">&lt;</span>PersonInfo<span class="token operator">&gt;</span> people<span class="token punctuation">;</span>    <span class="token comment">// 保存来自输入的所有记录</span>
<span class="token comment">// 逐行从输入读取数据，直至 cin 遇到文件尾(或其他错误 )</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    PersonInfo info<span class="token punctuation">;</span>    <span class="token comment">// 创建一个保存此记录数据的对象</span>
    istringstream <span class="token function">record</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将记录绑定到刚读入的行</span>
    record <span class="token operator">&gt;&gt;</span> info<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token comment">// 读取名字</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>record <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>  <span class="token comment">// 读取电话号码</span>
        info<span class="token punctuation">.</span>phones<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 保持它们</span>
    people<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将此记录追加到people末尾</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="使用ostringstream"><a href="#使用ostringstream" class="header-anchor">#</a> 使用ostringstream</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span> people<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token comment">// 对people中每一项</span>
    ostringstream formatted<span class="token punctuation">,</span> badNums<span class="token punctuation">;</span>   <span class="token comment">// 每个循环步创建的对象</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>nums <span class="token operator">:</span> entry<span class="token punctuation">.</span>phones<span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">// 对每个数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">valid</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            badNums <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> nums<span class="token punctuation">;</span>  <span class="token comment">// 将数的字符串形式存入 badNums</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            <span class="token comment">// 将格式化的字符串“写入”formatted</span>
            formatted <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">format</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>badNums<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 没有错误的数</span>
        os <span class="token operator">&lt;&lt;</span> entry<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span>  <span class="token comment">// 打印名字</span>
            <span class="token operator">&lt;&lt;</span> formatted<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 和格式化的数</span>
    <span class="token keyword">else</span>  <span class="token comment">// 否则，打印名字和错误的数</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;input error: &quot;</span> <span class="token operator">&lt;&lt;</span> entry<span class="token punctuation">.</span>name
            <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; invalid number(s) &quot;</span> <span class="token operator">&lt;&lt;</span> badNums<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="header-anchor">#</a> 第九章 顺序容器</h2> <p>​		顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖元素的值，而是与元素加入时的位置相对应。</p> <h3 id="_9-1-顺序容器概述"><a href="#_9-1-顺序容器概述" class="header-anchor">#</a> 9.1 顺序容器概述</h3> <p>​</p> <table><thead><tr><th>类型</th> <th>特性</th></tr></thead> <tbody><tr><td><code>vector</code></td> <td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td></tr> <tr><td><code>deque</code></td> <td>双端队列。支持快速随机访问。在头尾位置插入或删除速度很快</td></tr> <tr><td><code>list</code></td> <td>双向链表。只支持双向顺序访问。在任何位置插入或删除速度都很快</td></tr> <tr><td><code>forward_list</code></td> <td>单向链表。只支持单向顺序访问。在任何位置插入或删除速度都很快</td></tr> <tr><td><code>array</code></td> <td>固定大小数组。支持快速随机访问。不能添加或删除元素</td></tr> <tr><td><code>string</code></td> <td>类似<code>vector</code>，但用于保存字符。支持快速随机访问。在尾部插入或删除速度很快</td></tr></tbody></table> <p>​		<code>forward_list</code>和<code>array</code>是C++11新增类型。与内置数组相比，<code>array</code>更安全易用。<code>forward_list</code>没有<code>size</code>操作。</p> <p>​		现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置的数组。</p> <p><strong>确定使用哪种顺序容器</strong></p> <p>​		容器选择原则：</p> <ul><li><p>除非有合适的理由选择其他容器，否则应该使用<code>vector</code>。</p></li> <li><p>如果程序有很多小的元素，且空间的额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code>。</p></li> <li><p>如果程序要求随机访问容器元素，则应该使用<code>vector</code>或<code>deque</code>。</p></li> <li><p>如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用<code>deque</code>。</p></li> <li><p>如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则：</p> <ul><li><p>先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向<code>vector</code>追加数据，再调用标准库的<code>sort</code>函数重排元素，从而避免在中间位置添加元素。</p></li> <li><p>如果必须在中间位置插入元素，可以在输入阶段使用<code>list</code>。输入完成后将<code>list</code>中的内容拷贝到<code>vector</code>中。</p></li></ul></li></ul> <p>​		不确定应该使用哪种容器时，可以先只使用<code>vector</code>和<code>list</code>的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择<code>vector</code>或<code>list</code>都很方便。</p> <h3 id="_9-2-容器库概览"><a href="#_9-2-容器库概览" class="header-anchor">#</a> 9.2 容器库概览</h3> <p>​		一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。</p> <p>​		容器均定义为模板类。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>Sales_data<span class="token operator">&gt;</span>	<span class="token comment">// 保存Sales_data对象的list</span>
deque<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span>	    <span class="token comment">// 保存double的deque</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>对容器可以保存的元素类型的限制</strong></p> <p>​		顺序容器几乎可以保存任意类型的元素，也包括顺序容器本身（用vector类比定义二维数组就是使用这种方式）</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> lines<span class="token punctuation">;</span> <span class="token comment">// vector的 vector</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​		容器操作</p> <table><thead><tr><th>类型别名</th> <th></th></tr></thead> <tbody><tr><td><code>iterator</code></td> <td>此容器类型的迭代器类型</td></tr> <tr><td><code>const_iterator</code></td> <td>可以读取元素，但不能修改元素的迭代器类型</td></tr> <tr><td><code>size_type</code></td> <td>无符号整数类型，足够保存此种容器类型最大可能容器的大小</td></tr> <tr><td><code>difference_type</code></td> <td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr> <tr><td><code>value_type</code></td> <td>元素类型</td></tr> <tr><td><code>reference</code></td> <td>元素的左值诶性：与<code>value_type&amp;</code>含义相同</td></tr> <tr><td><code>const_reference</code></td> <td>元素的<code>const</code>左值类型（即，<code>const value_type&amp;</code>）</td></tr> <tr><td><strong>构造函数</strong></td> <td></td></tr> <tr><td><code>C c;</code></td> <td>默认构造函数，构造空容器</td></tr> <tr><td><code>C c1(c2)</code></td> <td>构造<code>c2</code>的拷贝<code>c1</code></td></tr> <tr><td><code>C c(b, e)</code></td> <td>构造<code>c</code>，将迭代器<code>b</code>和<code>e</code>指定的范围内的元素拷贝到<code>c</code>（<code>array</code>不支持）</td></tr> <tr><td><code>C c{a, b, c...}</code></td> <td>列表初始化<code>c</code></td></tr> <tr><td><strong>赋值与swap</strong></td> <td></td></tr> <tr><td><code>c1=c2</code></td> <td>将<code>c1</code>中的元素替换为<code>c2</code>中元素</td></tr> <tr><td><code>c1 = {a, b, c...}</code></td> <td>将<code>c1</code>中的元素替换为列表中元素（不适用于<code>array</code>）</td></tr> <tr><td><code>a.swap(b)</code></td> <td>交换<code>a</code>和<code>b</code>的元素</td></tr> <tr><td><code>swap(a, b)</code></td> <td>与<code>a.swap(b)</code>等价</td></tr> <tr><td><strong>大小</strong></td> <td></td></tr> <tr><td><code>c.size()</code></td> <td><code>c</code>中元素的数组（不支持<code>forward_list</code>）</td></tr> <tr><td><code>c.max_size()</code></td> <td><code>c</code>中可保存的最大元素数目</td></tr> <tr><td><code>c.empty()</code></td> <td>若<code>c</code>中存储了元素，返回<code>false</code>,否则返回<code>true</code></td></tr> <tr><td><strong>添加/删除元素（不适用于<code>array</code>）</strong></td> <td></td></tr> <tr><td><code>c.insert(args)</code></td> <td>将<code>args</code>中的元素拷贝进<code>c</code></td></tr> <tr><td><code>c.emplace(inits)</code></td> <td>使用<code>inits</code>构造<code>c</code>中的一个元素</td></tr> <tr><td><code>c.erase(args)</code></td> <td>删除<code>args</code>指定的元素</td></tr> <tr><td><code>c.clear()</code></td> <td>删除<code>c</code>中的所有元素，返回<code>void</code></td></tr> <tr><td><strong>关系运算符</strong></td> <td></td></tr> <tr><td><code>==, !=</code></td> <td>所有容器都支持相等(不等运算符)</td></tr> <tr><td><code>&lt;,&lt;=,&gt;,&gt;=</code></td> <td>关系运算符(无序关联容器不支持）</td></tr> <tr><td><strong>获取迭代器</strong></td> <td></td></tr> <tr><td><code>c.begin(), c.end()</code></td> <td>返回指向<code>c</code>的首元素和尾元素之后位置的迭代器</td></tr> <tr><td><code>c.cbengin(),c.cend()</code></td> <td>返回<code>const_iterator</code></td></tr> <tr><td><strong>反向容器的额外成员（不支持forward_list）</strong></td> <td></td></tr> <tr><td><code>reverse_iterator</code></td> <td>按逆序寻址元素的迭代器</td></tr> <tr><td><code>const_reverse_iterator</code></td> <td>不能修改元素的逆序迭代器</td></tr> <tr><td><code>c.rbegin(), c.rend()</code></td> <td>返回指向<code>c</code>的尾元素和首元素之前位置的迭代器</td></tr> <tr><td><code>c.crbegin(), c.crend()</code></td> <td>返回<code>const_reverse_iterator</code></td></tr></tbody></table> <h4 id="迭代器"><a href="#迭代器" class="header-anchor">#</a> 迭代器</h4> <p><strong>迭代器范围</strong></p> <p>​		一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者尾元素之后的位置。这两个迭代器通常被称为<code>begin</code>和<code>end</code>或者<code>first</code>和<code>last</code>，它们标记了一个容器中元素的一个范围。</p> <p>​		第二个迭代器从来不会指向范围中的最后一个元素，而是指向为元素之后的位置。</p> <p>​		迭代器在使用的过程中是左闭右开的</p> <p>​		<code>[begin,end)</code></p> <p>​		迭代器<code>begin</code>和<code>end</code>必须指向相同的容器，<code>end</code>可以与<code>begin</code>指向相同的位置，但不能指向<code>begin</code>之前的位置（编译器不会报错，由程序员确保）。</p> <p><strong>使用左闭合范围蕴含的编程假定</strong></p> <p>​	   假定<code>begin</code>和<code>end</code>构成一个合法的迭代器范围，则：</p> <ul><li>如果<code>begin</code>等于<code>end</code>，则范围为空。</li> <li>如果<code>begin</code>不等于<code>end</code>，则范围内至少包含一个元素，且<code>begin</code>指向该范围内的第一个元素。</li> <li>可以递增<code>begin</code>若干次，令<code>begin</code>等于<code>end</code>。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">!=</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">*</span>begin <span class="token operator">=</span> val<span class="token punctuation">;</span>   <span class="token comment">// 正确：范围非空，因此begin指向一个元素</span>
    <span class="token operator">++</span>begin<span class="token punctuation">;</span>    <span class="token comment">// 移动迭代器，获取下一个元素</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="容器类型成员"><a href="#容器类型成员" class="header-anchor">#</a> 容器类型成员</h4> <p>​		反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比,各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行<code>++</code>操作，会得到上一个元素。</p> <p>​		通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的<code>value_type</code>。如果需要元素类型的引用，可以使用<code>reference</code>或<code>const_reference</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// iter 是通过list&lt;string&gt;定义的一个迭代器类型</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iter<span class="token punctuation">;</span>
<span class="token comment">// count 是通过 vector&lt;int&gt;定义的一个difference type 类型</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>difference_type count<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="begin和end成员"><a href="#begin和end成员" class="header-anchor">#</a> begin和end成员</h4> <p>​		<code>begin</code>和<code>end</code>操作生成指向容器中第一个元素和尾后地址的迭代器。其常见用途是形成一个包含容器中所有元素的迭代器范围。</p> <p>​		<code>begin</code>和<code>end</code>操作有多个版本：带<code>r</code>的版本返回反向迭代器。以<code>c</code>开头的版本（C++11新增）返回<code>const</code>迭代器。不以<code>c</code>开头的版本都是重载的，当对非常量对象调用这些成员时，返回普通迭代器，对<code>const</code>对象调用时，返回<code>const</code>迭代器。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Milton&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Shakespeare&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Austen&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> it1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// list&lt;string&gt;::iterator</span>
<span class="token keyword">auto</span> it2 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// list&lt;string&gt;::reverse_iterator</span>
<span class="token keyword">auto</span> it3 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// list&lt;string&gt;::const_iterator</span>
<span class="token keyword">auto</span> it4 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// list&lt;string&gt;::const_reverse_iterator</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		当<code>auto</code>与<code>begin</code>或<code>end</code>结合使用时，返回的迭代器类型依赖于容器类型。但调用以<code>c</code>开头的版本仍然可以获得<code>const</code>迭代器，与容器是否是常量无关。</p> <p>​		当程序不需要写操作时，应该使用<code>cbegin</code>和<code>cend</code>。</p> <h4 id="容器定义和初始化"><a href="#容器定义和初始化" class="header-anchor">#</a> 容器定义和初始化</h4> <p>​		每个容器类型都定义了一个默认构造函数。除 array 之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。</p> <p><strong>将一个容器初始化为另一个容器的拷贝</strong></p> <p>​		将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。传递迭代器参数来拷贝一个范围时，不要求容器类型相同，而且新容器和原容器中的元素类型也可以不同，但是要能进行类型转换</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 每个容器有三个元素，用给定的初始化器进行初始化</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> authors <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Milton&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Shakespeare&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Austen&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> articles <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">list2</span><span class="token punctuation">(</span>authors<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 正确:类型匹配</span>
deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">authList</span><span class="token punctuation">(</span>authors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 错误:容器类型不匹配</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">words</span><span class="token punctuation">(</span>articles<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 错误:容器类型必须匹配</span>
<span class="token comment">// 正确:可以将 const char*元素转换为 string</span>
forward_list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">words</span><span class="token punctuation">(</span>articles<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> articles<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>列表初始化</strong></p> <p>​		C++11允许对容器进行列表初始化。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 每个容器有三个元素，用给定的初始化器进行初始化</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> authors <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Milton&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Shakespeare&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Austen&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> articles <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>与顺序容器大小相关的构造函数</strong></p> <p>​		除了与关联容器相同的构造函数外，顺序容器(<code>array</code> 除外)还提供另一个构造函数它接受一个容器大小和一个(可选的) 元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器 :</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token number">10</span>，<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 10个int 元素，每个都初始化为-1</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span><span class="token number">10</span>，<span class="token string">&quot;hi!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 10个strings;每个都初始化为&quot;hi!&quot;</span>
forward list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 10个元素，每个都初始化为 0</span>
deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 10 个元素，每个都是空 string</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>标准库array具有固定大小</strong></p> <p>​		定义和使用<code>array</code>类型时，需要同时指定元素类型和容器大小。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token operator">&gt;</span>      <span class="token comment">// 类型为:保存 42个int 的数组</span>
array<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span>   <span class="token comment">// 类型为:保存10个string 的数组</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type i<span class="token punctuation">;</span>   <span class="token comment">// 数组类型包括元素类型和大小</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type j<span class="token punctuation">;</span>       <span class="token comment">// 错误:array&lt;int&gt;不是一个类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		对<code>array</code>进行列表初始化时，初始值的数量不能大于<code>array</code>的大小。如果初始值的数量小于<code>array</code>的大小，则只初始化靠前的元素，剩余元素会被值初始化。如果元素类型是类类型，则该类需要一个默认构造函数。</p> <p>​		可以对<code>array</code>进行拷贝或赋值操作，但要求二者的元素类型和大小都相同。</p> <p>​		值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但 array 并无此限制:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> digs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cpy<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span> digs<span class="token punctuation">;</span>			<span class="token comment">// 错误:内置数组不支持拷贝或赋值</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span>，<span class="token number">10</span><span class="token operator">&gt;</span> digits<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span>，<span class="token number">10</span><span class="token operator">&gt;</span>copy <span class="token operator">=</span> digits<span class="token punctuation">;</span><span class="token comment">// 正确:只要数组类型匹配即合法</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="赋值和swap"><a href="#赋值和swap" class="header-anchor">#</a> 赋值和swap</h4> <p><strong>使用assign（仅顺序容器）</strong></p> <p>​		赋值运算符两侧的运算对象必须类型相同。<code>assign</code>允许用不同但相容的类型赋值，或者用容器的子序列赋值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> names<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> oldstyle<span class="token punctuation">;</span>
names <span class="token operator">=</span> oldstyle<span class="token punctuation">;</span>   <span class="token comment">// 错误：容器类型不匹配</span>
<span class="token comment">// 正确:可以将 const char*转换为 string</span>
names<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>oldstyle<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> oldstyle<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		由于其旧元素被替换，因此传递给<code>assign</code>的迭代器不能指向调用<code>assign</code>的容器本身。</p> <p><strong>使用swap</strong></p> <p>​		对于<code>array</code>，<code>swap</code>会真正交换它们的元素。因此在<code>swap</code>操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经被交换。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出交换后的值，即4、5、6</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token operator">++</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​		对于其他容器类型（除<code>string</code>），指针、引用和迭代器在<code>swap</code>操作后仍指向操作前的元素，但这些元素已经属于不同的容器了。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出交换前的值，即1、2、3</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token operator">++</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​		<code>array</code>不支持<code>assign</code>，也不允许用花括号列表进行赋值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> a2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 所有元素值均为 0</span>
a1 <span class="token operator">=</span> a2<span class="token punctuation">;</span>    <span class="token comment">// 替换 a1中的元素</span>
a2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// 错误:不能将一个花括号列表赋予数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		新标准库同时提供了成员和非成员函数版本的<code>swap</code>。非成员版本的<code>swap</code>在泛型编程中非常重要，建议统一使用非成员版本的<code>swap</code>。</p> <h4 id="容器大小操作"><a href="#容器大小操作" class="header-anchor">#</a> 容器大小操作</h4> <p>​		<code>size</code>成员返回容器中元素的数量；<code>empty</code>当<code>size</code>为0时返回<code>true</code>，否则返回<code>false</code>；<code>max_size</code>返回一个大于或等于该类型容器所能容纳的最大元素数量的值。<code>forward_list</code>支持<code>max_size</code>和<code>empty</code>，但不支持<code>size</code>。</p> <h4 id="关系运算符"><a href="#关系运算符" class="header-anchor">#</a> 关系运算符</h4> <p>​		每个容器类型都支持相等运算符（<code>==</code>、<code>!=</code>）。除无序关联容器外，其他容器都支持关系运算符（<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>）。关系运算符两侧的容器类型和保存元素类型都必须相同。</p> <p>​		两个容器的比较实际上是元素的逐对比较，其工作方式与<code>string</code>的关系运算符类似：</p> <ul><li>如果两个容器大小相同且所有元素对应相等，则这两个容器相等。</li> <li>如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li> <li>如果两个容器都不是对方的前缀子序列，则两个容器的比较结果取决于第一个不等元素的比较结果。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
v1 <span class="token operator">&lt;</span> v2     <span class="token comment">// true;vl和v2在元素[2]处不同:vl[2]小于等于v2[2]</span>
v1 <span class="token operator">&lt;</span> v3     <span class="token comment">// false;所有元素都相等，但 v3 中元素数目更少</span>
v1 <span class="token operator">==</span> v4    <span class="token comment">// true;每个元素都相等，且vl和v4大小相同</span>
v1 <span class="token operator">==</span> v2    <span class="token comment">// false;v2元素数目比 v1 少</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>容器的关系运算符使用元素的关系运算符完成比较</strong></p> <p>​		容器的相等运算符实际上是使用元素的<code>==</code>运算符实现的，而其他关系运算符则是使用元素的<code>&lt;</code>运算符。如果元素类型不支持所需运算符，则保存该元素的容器就不能使用相应的关系运算。</p> <h3 id="_9-3顺序容器操作"><a href="#_9-3顺序容器操作" class="header-anchor">#</a> 9.3顺序容器操作</h3> <h4 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="header-anchor">#</a> 向顺序容器添加元素</h4> <p>​		我们在对容器的操作过程中要注意不同的容器用不同的策略来分配元素空间，这些策略会直接影响性能。</p> <p><strong>使用push_back</strong></p> <p>​		将元素添加在容器的尾部</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 从标准输入读取数据，将每个单词放到容器末尾</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
    container<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		需要我们注意的是容器的元素是拷贝，当我们初始化元素或者向容器中插入元素的行为实质上放到容器中的对象值是一个拷贝值，而不是对象本身。</p> <p><strong>使用push_front</strong></p> <p>​		将元素添加在容器的首部</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ilist<span class="token punctuation">;</span>
<span class="token comment">// 将元素添加到 ilist 开头</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t ix <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>ix <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">++</span>ix<span class="token punctuation">)</span>
ilist<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>使用insert</strong></p> <p>​		在容器的特定部位添加元素</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>slist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span><span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将&quot;Hello&quot;添加到iter之前的位置</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​		有些容器不支持使用<code>push_front</code>，但是支持<code>insert</code>。我们可以使用<code>insert</code>来模拟<code>push_front</code></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> svec<span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> slist<span class="token punctuation">;</span>
<span class="token comment">// 等价于 slist.push_front(&quot;Hello!&quot;);</span>
slist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// vector不支持push_front,但我们可以插入到begin()之前</span>
<span class="token comment">// 警告：插到vector末尾之外的任何位置都可能很慢</span>
svec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​		将元素插入到 <code>vector</code>、<code>deque</code>和<code>string</code>中的任何位置都是合法的。然而这样做可能很耗时。</p> <p>​		<code>insert</code>可以通过接受更多参数来做到插入范围内元素的操作</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>svec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， <span class="token number">10</span>，<span class="token string">&quot;Anna&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这行代码将10个元素插入到 svec 的末尾，并将所有元素都初始化为 string“Anna&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		在新标准库中，接受元素个数或范围的<code>insert</code>版本返回指向第一个新增元素的迭代器，而旧版本中这些操作返回<code>void</code>。如果范围为空，不插入任何元素，<code>insert</code>会返回第一个参数。</p> <p>​		使用<code>insert</code>的返回值，可以在容器中一个特定的位置反复插入元素：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> lst<span class="token punctuation">;</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
    iter <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等价于调用push_front</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>使用emplace操作</strong></p> <p>​		标准库增加了三个直接构造而不是拷贝元素的操作：<code>emplace_front</code>、<code>emplace_back</code>和<code>emplace</code>，其分别对应<code>push_front</code>、<code>push_back</code>和<code>insert</code>。当调用<code>push</code>或<code>insert</code>时，元素对象被拷贝到容器中。而调用<code>emplace</code>时，则是将参数传递给元素类型的构造函数，直接在容器的内存空间中构造元素。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 在c的末尾构造一个Sales_data对象</span>
<span class="token comment">// 使用三个参数的Sales_data构造函数</span>
c<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">&quot;978-0590353403&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">15.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 错误：没有接受三个参数的push_data构造函数</span>
c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">&quot;978-0590353403&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">15.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确：创建一个临时的Sales_data对象传递给push_back</span>
c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token string">&quot;978-0590353403&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">15.99</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="访问元素"><a href="#访问元素" class="header-anchor">#</a> 访问元素</h4> <p>​		每个顺序容器都有一个<code>front</code>成员函数，而除了<code>forward_list</code>之外的顺序容器还有一个<code>back</code>成员函数。这两个操作分别返回首元素和尾元素的引用。在调用<code>front</code>和<code>back</code>之前，要确保容器非空。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 在解引用一个选代器或调用 front 或 back 之前检查是否有元素</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// val和val2是c中第一个元素值的拷贝</span>
    <span class="token keyword">auto</span> val <span class="token operator">=</span> <span class="token operator">*</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， val2<span class="token operator">=</span>c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// va13和 val4是c中最后一个元素值的拷贝</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> val3 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不能递减 forward_list 选代器</span>
    <span class="token keyword">auto</span> val4 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// forward_list 不支持</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>访问成员函数返回的是引用</strong></p> <p>​		在容器中访问元素的成员函数（即，<code>front</code>、<code>back</code>、下标和<code>at</code>）返回的都是引用。如果容器是一个<code>const</code>对象，则返回值是<code>const</code>的引用。如果容器不是<code>const</code>的，则返回值是普通引用，我们可以用来改变元素的值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>			<span class="token comment">//将42赋予c中的第一个元素</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>v <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//获得指向最后一个元素的引用</span>
    v <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>			   <span class="token comment">//改变 c中的元素</span>
    <span class="token keyword">auto</span> v2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	    <span class="token comment">// v2 不是一个引用，它是 c.back()的一个拷贝	</span>
    v2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>				  <span class="token comment">//未改变c中的元素</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>下标操作和安全的随机访问</strong></p> <p>​		在下标访问的过程中我们要保证下标是有效的，为了防止出现意外，我们可以使用at成员函数。<code>at</code>成员函数类似于下标运算符，但如果下标越界，<code>at</code>会抛出一个<code>out_of_range</code>异常。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> svec<span class="token punctuation">;</span>  <span class="token comment">// 空vector</span>
cout <span class="token operator">&lt;&lt;</span> svec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 运行错误：svec中没有元素</span>
cout <span class="token operator">&lt;&lt;</span> svec<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 抛出一个out_of_range异常</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="删除数据"><a href="#删除数据" class="header-anchor">#</a> 删除数据</h4> <p>​		删除<code>deque</code>中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。删除<code>vector</code>或<code>string</code>的元素后，指向删除点之后位置的迭代器、引用和指针也都会失效。</p> <p><strong>pop_front和pop_back成员函数</strong></p> <p>​		<code>pop_front</code>和<code>pop_back</code>函数分别删除首元素和尾元素。<code>vector</code>和<code>string</code>类型不支持<code>pop_front</code>，<code>forward_list</code>类型不支持<code>pop_back</code>。</p> <p><strong>erase成员函数</strong></p> <p>​		<code>erase</code>函数删除指定位置的元素。可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的<code>erase</code>都返回指向删除元素（最后一个）之后位置的迭代器。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lst <span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> it <span class="token operator">=</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>it <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">// 若元素为奇数</span>
		it <span class="token operator">=</span> ist<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除此元素</span>
	<span class="token keyword">else</span>
	<span class="token operator">++</span>it<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​		删除多个元素</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 删除两个迭代器表示的范围内的元素</span>
<span class="token comment">// 返回指向最后一个被删元素之后位置的选代器</span>
eleml <span class="token operator">=</span> slist<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>eleml，elem2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用后，elem == elem2</span>

slist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除容器中所有元素</span>
slist<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，slist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等价调用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="header-anchor">#</a> 特殊的forward_list操作</h4> <p>​		在<code>forward_list</code>中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>forward list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> flst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> prev <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">before_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//表示 flst的“首前元素”</span>
<span class="token keyword">auto</span> curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//表示flst 中的第一个元素</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> flst<span class="token punctuation">,</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">// 仍有元素要处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>curr <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>						<span class="token comment">// 若元素为奇数</span>
        curr <span class="token operator">=</span> flst<span class="token punctuation">.</span>erase <span class="token function">after</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除它并移动 curr</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span><span class="token comment">// 移动选代器 curr，指向下一个元素，prev 指向</span>
        <span class="token operator">++</span>cuur<span class="token punctuation">;</span>		<span class="token comment">//curr之前的元素</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="改变容器大小"><a href="#改变容器大小" class="header-anchor">#</a> 改变容器大小</h4> <p>​		<code>resize</code>函数接受一个可选的元素值参数，用来初始化添加到容器中的元素，否则新元素进行值初始化。如果容器保存的是类类型元素，且<code>resize</code>向容器添加新元素，则必须提供初始值，或元素类型提供默认构造函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ilist</span><span class="token punctuation">(</span><span class="token number">10</span>，<span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 10个int:每个的值都是42</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将5个值为0的元素添加到 ilist 的末尾</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">25</span>，<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将10个值为-1的元素添加到 ilist 的末尾</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从ilist 末尾删除 20 个元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="header-anchor">#</a> 容器操作可能使迭代器失效</h4> <p>向容器中添加或删除元素可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再表示任何元素，使用它们是一种严重的程序设计错误。</p> <ul><li>向容器中添加元素后：
<ul><li>如果容器是<code>vector</code>或<code>string</code>类型，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。</li> <li>如果容器是<code>deque</code>类型，添加到除首尾之外的任何位置都会使迭代器、指针和引用失效。如果添加到首尾位置，则迭代器会失效，而指针和引用不会失效。</li> <li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器的迭代器、指针和引用仍然有效。</li></ul></li> <li>从容器中删除元素后，指向被删除元素的迭代器、指针和引用失效：
<ul><li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器其他位置的迭代器、指针和引用仍然有效。</li> <li>如果容器是<code>deque</code>类型，删除除首尾之外的任何元素都会使迭代器、指针和引用失效。如果删除尾元素，则尾后迭代器失效，其他迭代器、指针和引用不受影响。如果删除首元素，这些也不会受影响。</li> <li>如果容器是<code>vector</code>或<code>string</code>类型，指向删除位置之前元素的迭代器、指针和引用仍然有效。但尾后迭代器总会失效。</li></ul></li></ul> <p>必须保证在每次改变容器后都正确地重新定位迭代器。</p> <p>不要保存<code>end</code>函数返回的迭代器。</p> <h3 id="_9-4-vector对象是如何增长的"><a href="#_9-4-vector对象是如何增长的" class="header-anchor">#</a> 9.4 vector对象是如何增长的</h3> <p>​		由于<code>vector</code>和<code>string</code>在增加时分配新的空间效率过慢，所以<code>vector</code>和<code>string</code>的实现通常会分配比新的空间需求更大的内存空间</p> <p><strong>管理容量的成员函数</strong>·</p> <p>​		<code>reserve</code>操作允许我们通知容器我们需要存储多少个元素。<code>reserve</code>不会改变容器中元素的数量，仅仅影响<code>vector</code>预先分配多大的内存。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>c<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>capacity和size</strong></p> <p>​	<code>capacity</code>函数返回容器在不扩充内存空间的情况下最多可以容纳的元素数量。<code>size</code>函数是指已经保存的元素的数目。</p> <p>​		只有当需要的内存空间超过当前容量时，<code>reserve</code>才会真正改变容器容量，分配不小于需求大小的内存空间。当需求大小小于当前容量时，<code>reserve</code>并不会退回内存空间。因此在调用<code>reserve</code>之后，<code>capacity</code>会大于或等于传递给<code>reserve</code>的参数。</p> <p>​		在C++11中可以使用<code>shrink_to_fit</code>函数来要求<code>deque</code>、<code>vector</code>和<code>string</code>退回不需要的内存空间（并不保证退回）。</p> <p>​		每个 vector 实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是:只有当迫不得已时才可以分配新的内存空间。</p> <h3 id="_9-5-额外的string操作"><a href="#_9-5-额外的string操作" class="header-anchor">#</a> 9.5 额外的string操作</h3> <h4 id="构造string的其他方法"><a href="#构造string的其他方法" class="header-anchor">#</a> 构造string的其他方法</h4> <p>​		从另一个<code>string</code>对象拷贝字符构造<code>string</code>时，如果提供的拷贝开始位置（可选）大于给定<code>string</code>的大小，则构造函数会抛出<code>out_of_range</code>异常。</p> <p><strong>substr操作</strong></p> <p>​		<code>substr</code>操作返回一个 <code>string</code>，它是原始<code>string</code> 的一部分或全部的贝。可以传递给 <code>substr</code>一个可选的开始位置和计数值</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span>，<span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// s2 =hello</span>
string s3 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// s3= world</span>
string s4 <span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span>，<span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// s3= world</span>
string s5 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 抛出一个out of range 异常</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		如果传递给<code>substr</code>函数的开始位置超过<code>string</code>的大小，则函数会抛出<code>out_of_range</code>异常。</p> <h4 id="改变string的其他方法"><a href="#改变string的其他方法" class="header-anchor">#</a> 改变string的其他方法</h4> <p>​		除了接受迭代器的 insert 和erase 版本外，string还提供了接受下标的版本下标指出了开始删除的位置，或是 insert 到给定值之前的位置:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，<span class="token number">5</span>，<span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在s 末尾插入5个感叹号</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span>，<span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从 s删除最后 5个字</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>append 和replace 函数</strong></p> <p>​		<code>append</code>函数是在<code>string</code>末尾进行插入操作的简写形式。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;C++ Primer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> s<span class="token punctuation">;</span>     <span class="token comment">// 将s和s2初始化为&quot;C++ Primer&quot;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot; 4th Ed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s == &quot;C++ Primer 4th Ed.&quot;</span>
s2<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot; 4th Ed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 等价方法:将”4th Ed.&quot;追加到s2;s== s2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		<code>replace</code>函数是调用<code>erase</code>和<code>insert</code>函数的简写形式。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 将”4th”替换为”5th&quot;的等价方法</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// s == &quot;C++ Primer Ed.&quot;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">&quot;5th&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// s == &quot;C++ Primer 5th Ed.&quot;</span>
<span class="token comment">// 从位置11开始，删除3个字符并插入”5th&quot;</span>
s2<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;5th&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 等价方法: s == s2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="string搜索操作"><a href="#string搜索操作" class="header-anchor">#</a> string搜索操作</h4> <p>​		<code>string</code> 搜索函数返回<code>string::size_type</code> 值，该类型是一个<code>unsigned</code>类型。因此，用一个 <code>int</code> 或其他带符号类型来保存这些函数的返回值不是一个好主意</p> <p>​		<code>find</code> 函数完成最简单的搜索。它查找参数指定的字符串，若找到，则返回第一个匹配位置的下标，否则返回<code>npos</code></p> <p><strong>指定在哪里开始</strong></p> <p>​		我们可以传递给 <code>find</code> 操作一个可选的开始位置。这个可选的参数指出从哪个位置开始进行搜索。默认情况下，此位置被置为 <code>0</code>。一种常见的程序设计模式是用这个可选参数在字符串中循环地搜索子字符串出现的所有位置:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string<span class="token double-colon punctuation">::</span>size_type pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 每步循环查找name 中下一个数</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pos <span class="token operator">=</span> name<span class="token punctuation">.</span>find first <span class="token function">of</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token operator">!=</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;found number at index: &quot;</span> <span class="token operator">&lt;&lt;</span> pos
    	<span class="token operator">&lt;&lt;</span> <span class="token string">&quot; element is &quot;</span> <span class="token operator">&lt;&lt;</span> name<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token operator">++</span>pos<span class="token punctuation">;</span><span class="token comment">// 移动到下一个字符</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>逆向搜索</strong></p> <p>​		标准库还提供了类似的但由右至左搜索的操作。<code>rfind</code> 成员函数搜索最后一个匹配，即子字符串最靠右的出现位置。</p> <h4 id="compare函数"><a href="#compare函数" class="header-anchor">#</a> compare函数</h4> <p>​		根据 <code>s</code> 是等于、大于还是小于参数指定的字符串，<code>s.compare</code> 返回<code>0</code>、正数或负数。</p> <h4 id="数值转化"><a href="#数值转化" class="header-anchor">#</a> 数值转化</h4> <p>​		C++11增加了<code>string</code>和数值之间的转换函数。</p> <p>​		进行数值转换时，<code>string</code>参数的第一个非空白字符必须是符号（<code>+</code>或<code>-</code>）或数字。它可以以<code>0x</code>或<code>0X</code>开头来表示十六进制数。对于转换目标是浮点值的函数，<code>string</code>参数也可以以小数点开头，并可以包含<code>e</code>或<code>E</code>来表示指数部分。</p> <p>​		如果给定的<code>string</code>不能转换为一个数值，则转换函数会抛出<code>invalid_argument</code>异常。如果转换得到的数值无法用任何类型表示，则抛出<code>out_of_range</code>异常。</p> <h3 id="_9-6-容器适配器"><a href="#_9-6-容器适配器" class="header-anchor">#</a> 9.6 容器适配器</h3> <p>​		除了顺序容器外，标准库还定义了三个顺序容器适配器:<code>stack</code>、<code>queue</code> 和<code>priority_queue</code>。适配器 (adaptor)是标准库中的一个通用概念。容器、代器和函数都有适配器。</p> <p><strong>定义一个适配器</strong></p> <p>​		默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是基于<code>vector</code>实现的。可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 在vector上实现的空栈</span>
stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> str_stk<span class="token punctuation">;</span>
<span class="token comment">// str_stk2在vector 上实现，初始化时保存 svec 的拷贝</span>
stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> <span class="token function">str_stk2</span><span class="token punctuation">(</span>svec<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在<code>array</code>上。适配器还要求容器具有添加、删除和访问尾元素的能力，因此也不能用<code>forward_list</code>构造适配器。</p> <p><strong>栈适配器</strong></p> <p>栈适配器<code>stack</code>定义在头文件<code>stack</code>中。队列适配器<code>queue</code>和<code>priority_queue</code>定义在头文件<code>queue</code>中。</p> <p><strong>队列适配器</strong></p> <p><code>queue</code>使用先进先出的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。</p> <h2 id="第十章-泛式算法"><a href="#第十章-泛式算法" class="header-anchor">#</a> 第十章 泛式算法</h2> <p>​		标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口。</p> <h3 id="_10-1-概述"><a href="#_10-1-概述" class="header-anchor">#</a> 10.1 概述</h3> <p>​		大多数算法都定义在头文件<code>algorithm</code>中，此外标准库还在头文件<code>numeric</code>中定义了一组数值泛型算法。一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的元素范围进行操作。</p> <p>​		<code>find</code>函数将范围中的每个元素与给定值进行比较，返回指向第一个等于给定值的元素的迭代器。如果无匹配元素，则返回其第二个参数来表示搜索失败。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment">// 我们要寻找的值</span>
<span class="token comment">// 如果在 vec 中找到想要的元素，则返回结果指向它，否则返回结果为 vec.cend()</span>
<span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 报告结果</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;The value &quot;</span> <span class="token operator">&lt;&lt;</span> val
    <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot; is not present&quot;</span> <span class="token operator">:</span> <span class="token string">&quot; is present&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		迭代器参数令算法不依赖于特定容器，但依赖于元素类型操作。</p> <p>​		泛型算法本身不会执行容器操作，它们只会运行于迭代器之上，执行迭代器操作。算法可能改变容器中元素的值，或者在容器内移动元素，但不会改变底层容器的大小（当算法操作插入迭代器时，迭代器可以向容器中添加元素，但算法自身不会进行这种操作）。</p> <h3 id="_10-2-初识泛型算法"><a href="#_10-2-初识泛型算法" class="header-anchor">#</a> 10.2 初识泛型算法</h3> <p>​		虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。</p> <h4 id="只读算法"><a href="#只读算法" class="header-anchor">#</a> 只读算法</h4> <p>​		<code>find</code>和<code>count</code>都是只读算法，这类算法只会读取去输入范围内的元素，而不会改变元素。</p> <p>​		另一种只读算法是<code>accumulate</code>，它定义在头文件<code>numeric</code>中。接受三个参数，前两个参数指定需要求和的元素范围，第三个参数是和的初值（决定加法运算类型和返回值类型）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 对 vec 中的元素求和，和的初值是 0</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>算法和元素类型</strong></p> <p>​		<code>accumulate</code> 将第三个参数作为求和起点，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。由于<code>string</code>定义了<code>+</code>运算符，所以我们可以通过调用<code>accumulate</code>来将 <code>vector</code> 中所有 string 元素连接起来:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 错误:const char*上没有定义+运算符</span>
string sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		建议在只读算法中使用<code>cbegin</code>和<code>cend</code>函数。</p> <p><strong>操作两个序列的算法</strong></p> <p>​		另一个只读算法是 <code>equal</code>，用于确定两个序列是否保存相同的值。它接受三个迭代器参数，前两个参数指定第一个序列范围，第三个参数指定第二个序列的首元素。<code>equal</code>函数假定第二个序列至少与第一个序列一样长。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// roster2中的元素数目应该至少与roster1一样多</span>
<span class="token function">equal</span><span class="token punctuation">(</span>roster1<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> roster1<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> roster2<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p> <h4 id="写容器元素的算法"><a href="#写容器元素的算法" class="header-anchor">#</a> 写容器元素的算法</h4> <p>​		<code>fill</code>函数接受两个迭代器参数表示序列范围，还接受一个值作为第三个参数，它将给定值赋予范围内的每个元素。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 将每个元素重置为0</span>
<span class="token function">fill</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		由于 <code>fill</code> 向给定输入序列中写入数据，因此，只要我们传递了一个有效的输入序列，写入操作就是安全的。</p> <p><strong>算法不检查写操作</strong></p> <p>​		<code>fill_n</code>函数接受单个迭代器参数、一个计数值和一个值，它将给定值赋予迭代器指向位置开始的指定个元素。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 使用 vec，赋予它不同值</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 函数 fill_n 假定写入指定个元素是安全的</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span>dest，n，val<span class="token punctuation">)</span>
<span class="token comment">// 灾难:修改 vec中的10个(不存在)元素</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，<span class="token number">10</span>，<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		向目的位置迭代器写入数据的算法都假定目的位置足够大，能容纳要写入的元素。</p> <p><strong>介绍back_inserter</strong></p> <p>​		插入迭代器是一种向容器内添加元素的迭代器。通过插入迭代器赋值时，一个与赋值号右侧值相等的元素会被添加到容器中。</p> <p>​		<code>back_inserter</code>函数（定义在头文件<code>iterator</code>中）接受一个指向容器的引用，返回与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>    <span class="token comment">// 空向量</span>
<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 通过它赋值会将元素添加到vec中</span>
<span class="token operator">*</span>it <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment">// vec中现在又一个元素，值为42</span>
<span class="token comment">// 正确:back_inserter 创建一个插入迭代器，可用来向 vec 添加元素</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 添加10个元素到vec</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>拷贝算法</strong></p> <p>​		<code>copy</code>函数接受三个迭代器参数，前两个参数指定输入序列，第三个参数指定目的序列的起始位置。它将输入序列中的元素拷贝到目的序列中，返回目的位置迭代器（递增后）的值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a1<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// a2 与 a1大小一样</span>
<span class="token comment">// ret 指向拷贝到 a2 的尾元素之后的位置</span>
<span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">,</span> a2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 把a1的内容拷贝给a2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		<code>replace</code>函数接受四个参数，前两个迭代器参数指定输入序列，后两个参数指定要搜索的值和替换值。它将序列中所有等于第一个值的元素都替换为第二个值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 将所有值为0的元素改为42</span>
<span class="token function">replace</span><span class="token punctuation">(</span>ilst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ilst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		相对于<code>replace</code>，<code>replace_copy</code>函数可以保留原序列不变。它接受第三个迭代器参数，指定调整后序列的保存位置。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 使用back_inserter按需要增长目标序列</span>
<span class="token function">replace_copy</span><span class="token punctuation">(</span>ilst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ilst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>ivec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		很多算法都提供“copy”版本，这些版本不会将新元素放回输入序列，而是创建一个新序列保存结果。</p> <h4 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="header-anchor">#</a> 重排容器元素的算法</h4> <p>​		<code>sort</code>函数接受两个迭代器参数，指定排序范围。它利用元素类型的<code>&lt;</code>运算符重新排列元素。</p> <p><strong>消除重复单词</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">elimDups</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>words<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 按字典序排序 words，以便查找重复单词</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// unique 重排输入范围，使得每个单词只出现一次</span>
    <span class="token comment">// 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器</span>
    <span class="token keyword">auto</span> end_unique <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用向量操作 erase删除重复单词</span>
    words<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>end_unique<span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>使用unique</strong></p> <p>​		<code>unique</code>函数重排输入序列，消除相邻的重复项，返回指向不重复值范围末尾的迭代器。</p> <h3 id="_10-3-定制操作"><a href="#_10-3-定制操作" class="header-anchor">#</a> 10.3 定制操作</h3> <div class="language- extra-class"><pre><code>	默认情况下，很多比较算法使用元素类型的`&lt;`或`==`运算符完成操作。可以为这些算法提供自定义操作来代替默认运算符。
</code></pre></div><h4 id="向算法传递函数"><a href="#向算法传递函数" class="header-anchor">#</a> 向算法传递函数</h4> <p><strong>谓词</strong></p> <p>​		谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为一元谓词（接受一个参数）和二元谓词（接受两个参数）。接受谓词参数的算法会对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 比较函数，用来按长度排序单词</span>
<span class="token keyword">bool</span> <span class="token function">isShorter</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 按长度由短至长排序 words</span>
<span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>排序算法</strong></p> <p>​		稳定排序函数<code>stable_sort</code>可以维持输入序列中相等元素的原有顺序。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">elimDups</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将words 按宇典序重排，并消除重复单词</span>
<span class="token comment">// 按长度重新排序，长度相同的单词维持字典序</span>
stable <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token comment">// 无须拷贝字符串</span>
	cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span><span class="token comment">// 打印每个元素，以空格分隔</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="lambda表达式"><a href="#lambda表达式" class="header-anchor">#</a> lambda表达式</h4> <p>​		<code>find_if</code>函数接受两个迭代器参数和一个谓词参数。迭代器参数用于指定序列范围，之后对序列中的每个元素调用给定谓词，并返回第一个使谓词返回非0值的元素。如果不存在，则返回尾迭代器。</p> <p><strong>介绍lambda</strong></p> <p>​		对于一个对象或表达式，如果可以对其使用调用运算符<code>()</code>，则称它为可<strong>调用对象</strong>（callable object）。可以向算法传递任何类别的可调用对象。</p> <p>​		一个<code>lambda</code>表达式表示一个可调用的代码单元，类似未命名的内联函数，但可以定义在函数内部。其形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>parameter list<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">return</span> type <span class="token punctuation">{</span> function body <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​		其中，<code>capture list</code>（捕获列表）是一个由<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。<code>return type</code>、<code>parameter list</code>和<code>function body</code>与普通函数一样，分别表示返回类型、参数列表和函数体。但与普通函数不同，<code>lambda</code>必须使用尾置返回类型，且不能有默认实参。</p> <p>​		定义<code>lambda</code>时可以省略参数列表和返回类型，但必须包含捕获列表和函数体。省略参数列表等价于指定空参数列表。省略返回类型时，若函数体只是一个<code>return</code>语句，则返回类型由返回表达式的类型推断而来。否则返回类型为<code>void</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 打印 42</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>向lambda传递参数</strong></p> <p>​		通常，实参和形参的类型必须匹配。但与普通函数不同，<code>lambda</code> 不能有默认参数。因此，一个 <code>lambda</code> 调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
	<span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		可以使用此<code>lambda</code> 来调用<code>stable_sort</code>:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 按长度排序，长度相同的单词维持宇典序</span>
stable <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，
			<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
				<span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>使用捕获列表</strong></p> <p>​		在本例中，我们的 <code>lambda</code> 会捕获 <code>sz</code>，并只有单一的 <code>string</code> 参数。其函数体会将<code>string</code> 的大小与捕获的 <code>sz</code> 的值进行比较:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> sz<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		一个 lambda 只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p> <p><strong>调用find_if</strong></p> <p>​		<code>lambda</code>可以使用其所在函数的局部变量，但必须先将其包含在捕获列表中。捕获列表只能用于局部非<code>static</code>变量，<code>lambda</code>可以直接使用局部<code>static</code>变量和其所在函数之外声明的名字。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 获取一个选代器，指向第一个满足 size()&gt;= sz的元素</span>
<span class="token keyword">auto</span> wc <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> sz<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>for_each算法</strong></p> <p><code>for_each</code>函数接受一个输入序列和一个可调用对象，它对输入序列中的每个元素调用此对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 打印长度大于等于给定值的单词，每个单词后面接一个空格</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>wc<span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>完整的 biggies</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">biggies</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>words<span class="token punctuation">,</span>
			vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size type sz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">elimDups</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将words 按宇典序排序，删除重复单词</span>
    <span class="token comment">// 按长度排序，长度相同的单词维持字典序</span>
    stable <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， <span class="token function">wordsend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    			<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
    				<span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取一个迭代器，指向第一个满足 size()&gt;= sz 的元素</span>
    <span class="token keyword">auto</span> wc <span class="token operator">=</span> find <span class="token keyword">if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> sz<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 计算满足 size &gt;= sz 的元素的数目</span>
    <span class="token keyword">auto</span> count <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> wc<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span><span class="token string">&quot; &quot;</span><span class="token operator">&lt;&lt;</span> make <span class="token function">plural</span><span class="token punctuation">(</span>count，<span class="token string">&quot;word&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;s&quot;</span><span class="token punctuation">)</span>
    <span class="token operator">&lt;&lt;</span><span class="token string">&quot; of length &quot;</span><span class="token operator">&lt;&lt;</span> sz <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; or longer&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 打印长度大于等于给定值的单词，每个单词后面接一个空格</span>
    <span class="token keyword">for</span> <span class="token function">each</span><span class="token punctuation">(</span>wc，words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h4 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="header-anchor">#</a> lambda捕获和返回</h4> <p><strong>值捕获</strong></p> <p>​		被<code>lambda</code>捕获的变量的值是在<code>lambda</code>创建时拷贝，而不是调用时拷贝。在<code>lambda</code>创建后修改局部变量不会影响<code>lambda</code>内对应的值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>size_t v1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 局部变量</span>
<span class="token comment">// 将v1拷贝到名为f的可调用对象</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>v1<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> v1<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
v1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> j <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// j为42;f保存了我们创建它时 v1的拷贝</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>引用捕获</strong></p> <p>​		<code>lambda</code>可以以引用方式捕获变量，但必须保证<code>lambda</code>执行时变量存在。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>size_t v1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 局部变量</span>
<span class="token comment">// 对象f2包含v1引用</span>
<span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>v1<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> v1<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
v1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> j <span class="token operator">=</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// j为0;f2保存vl的引用，而非拷贝</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>隐式捕获</strong></p> <p>​		可以让编译器根据<code>lambda</code>代码隐式捕获函数变量，方法是在捕获列表中写一个<code>&amp;</code>或<code>=</code>符号。<code>&amp;</code>为引用捕获，<code>=</code>为值捕获。</p> <p>​		可以混合使用显式捕获和隐式捕获。混合使用时，捕获列表中的第一个元素必须是<code>&amp;</code>或<code>=</code>符号，用于指定默认捕获方式。显式捕获的变量必须使用与隐式捕获不同的方式。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// os 隐式捕获，引用捕获方式;c 显式捕获，值捕获方式</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> os <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// os 显式捕获，引用捕获方式;c 隐式捕获，值捕获方式</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>os<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> os <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>可变lamba</strong></p> <p>​		默认情况下，对于值方式捕获的变量，<code>lambda</code>不能修改其值。如果希望修改，就必须在参数列表后添加关键字<code>mutable</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>size_t v1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 局部变量</span>
<span class="token comment">// f 可以改变它所捕获的变量的值</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>v1<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>v1<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
v1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> j <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// j 为 43</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		对于引用方式捕获的变量，<code>lambda</code>是否可以修改依赖于此引用指向的是否是<code>const</code>类型。</p> <p><strong>指定lambda返回类型</strong></p> <p>​		<code>transform</code>函数接受三个迭代器参数和一个可调用对象。前两个迭代器参数指定输入序列，第三个迭代器参数表示目的位置。它对输入序列中的每个元素调用可调用对象，并将结果写入目的位置。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">transform</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		为<code>lambda</code>定义返回类型时，必须使用尾置返回类型。</p> <h4 id="参数绑定"><a href="#参数绑定" class="header-anchor">#</a> 参数绑定</h4> <p><strong>标准bind函数</strong></p> <p>​		<code>bind</code>函数定义在头文件<code>functional</code>中，相当于一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。一般形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> newCallable <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span> arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​		其中，<code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个以逗号分隔的参数列表，对应给定的<code>callable</code>的参数。之后调用<code>newCallable</code>时，<code>newCallable</code>会再调用<code>callable</code>，并传递给它<code>arg_list</code>中的参数。<code>arg_list</code>中可能包含形如<code>_n</code>的名字，其中<code>n</code>是一个整数。这些参数是占位符，表示<code>newCallable</code>的参数，它们占据了传递给<code>newCallable</code>的参数的位置。数值<code>n</code>表示生成的可调用对象中参数的位置：<code>_1</code>为<code>newCallable</code>的第一个参数，<code>_2</code>为<code>newCallable</code>的第二个参数，依次类推。这些名字都定义在命名空间<code>placeholders</code>中，它又定义在命名空间<code>std</code>中，因此使用时应该进行双重限定。</p> <p><strong>使用placeholders名字</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">check_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> string<span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// check6 是一个课调用对象，接受一个string类型的参数</span>
<span class="token comment">// 并用此string和值6来调用check_size</span>
<span class="token keyword">auto</span> check6 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>check_size<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">check6</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// check6(s) 会调用 check_size(s, 6)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>bind的参数</strong></p> <p>​		<code>bind</code>函数可以调整给定可调用对象中的参数顺序。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 按单词长度由短至长排序</span>
<span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 按单词长度由长至短排序</span>
<span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bind</span><span class="token punctuation">(</span>isShorter<span class="token punctuation">,</span> _2<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>用bind重排参数顺序</strong></p> <p>​		默认情况下，<code>bind</code>函数的非占位符参数被拷贝到<code>bind</code>返回的可调用对象中。但有些类型不支持拷贝操作。</p> <p>​		如果希望传递给<code>bind</code>一个对象而又不拷贝它，则必须使用标准库的<code>ref</code>函数。<code>ref</code>函数返回一个对象，包含给定的引用，此对象是可以拷贝的。<code>cref</code>函数生成保存<code>const</code>引用的类。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bind</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">,</span> _1<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_10-4-再探迭代器"><a href="#_10-4-再探迭代器" class="header-anchor">#</a> 10.4 再探迭代器</h3> <p>除了为每种容器定义的迭代器之外，标准库还在头文件<code>iterator</code>中定义了另外几种迭代器。</p> <ul><li>插入迭代器（insert iterator）：该类型迭代器被绑定到容器对象上，可用来向容器中插入元素。</li> <li>流迭代器（stream iterator）：该类型迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</li> <li>反向迭代器（reverse iterator）：该类型迭代器向后而不是向前移动。除了<code>forward_list</code>之外的标准库容器都有反向迭代器。</li> <li>移动迭代器（move iterator）：该类型迭代器用来移动容器元素。</li></ul> <h4 id="插入迭代器"><a href="#插入迭代器" class="header-anchor">#</a> 插入迭代器</h4> <p>​		插入器是一种迭代器适配器，它接受一个容器参数，生成一个插入迭代器。通过插入迭代器赋值时，该迭代器调用容器操作向给定容器的指定位置插入一个元素。</p> <p>​		插入器有三种类型，区别在于元素插入的位置：</p> <ul><li><code>back_inserter</code>：创建一个调用<code>push_back</code>操作的迭代器。</li> <li><code>front_inserter</code>：创建一个调用<code>push_front</code>操作的迭代器。</li> <li><code>inserter</code>：创建一个调用<code>insert</code>操作的迭代器。此函数接受第二个参数，该参数必须是一个指向给定容器的迭代器，元素会被插入到该参数指向的元素之前。</li></ul> <p>​		只有在容器支持<code>push_front</code>的情况下,我们才可以使用<code>front_insertero</code>类似的，只有在容器支持 <code>push_back</code>的情况下，我们才能使用<code>back_inserter</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lst <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lst2<span class="token punctuation">,</span> lst3<span class="token punctuation">;</span>   <span class="token comment">// 空lists</span>
<span class="token comment">// 拷贝完成之后，lst2 包含 4 3 2 1</span>
<span class="token function">copy</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">front_inserter</span><span class="token punctuation">(</span>lst2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 拷贝完成之后，lst2 包含 1 2 3 4</span>
<span class="token function">copy</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inserter</span><span class="token punctuation">(</span>lst3<span class="token punctuation">,</span> lst3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="iostream迭代器"><a href="#iostream迭代器" class="header-anchor">#</a> iostream迭代器</h4> <p>​		<code>istream_iterator</code>从输入流读取数据，<code>ostream_iterator</code>向输出流写入数据。这些迭代器将流当作特定类型的元素序列处理。</p> <p><strong>istream_iterator操作</strong></p> <p>​		当创建流迭代器时，必须指定迭代器读写的对象类型。<code>istream_iterator</code>使用<code>&gt;&gt;</code>来读取流，因此<code>istream_iterator</code>要读取的类型必须定义了<code>&gt;&gt;</code>运算符。创建<code>istream_iterator</code>时，可以将其绑定到一个流。如果默认初始化，则创建的是尾后迭代器。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">int_it</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从cin读取int</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> int_eof<span class="token punctuation">;</span>      <span class="token comment">// 尾后迭代器</span>
ifstream <span class="token function">in</span><span class="token punctuation">(</span><span class="token string">&quot;afile&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">str_it</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 从&quot;afile&quot;读取字符串</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。下面是一个用istream_iterator从标准输入读取数据，存入一个vector的例子：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>istream iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> in <span class="token function">iter</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从 cin 读取 int</span>
istream iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> eof<span class="token punctuation">;</span><span class="token comment">// istream 尾后选代器</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>in iter <span class="token operator">!=</span> eof<span class="token punctuation">)</span><span class="token comment">// 当有数据可供读取时</span>
<span class="token comment">// 后置递增运算读取流，返回迭代器的旧值</span>
<span class="token comment">//解引用选代器，获得从流读取的前一个值</span>
vec<span class="token punctuation">.</span>push <span class="token function">back</span><span class="token punctuation">(</span><span class="token operator">*</span>in iter<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		可以直接使用流迭代器构造容器。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">in_iter</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> eof<span class="token punctuation">;</span>    <span class="token comment">// 从cin读取int</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span>in_iter<span class="token punctuation">,</span> eof<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 从迭代器范围构造vec</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		将<code>istream_iterator</code>绑定到一个流时，标准库并不保证迭代器立即从流读取数据。但可以保证在第一次解引用迭代器之前，从流中读取数据的操作已经完成了。</p> <p><strong>使用算法操作流迭代器</strong></p> <p>​		用一对istream_iterator来调用accumulate:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>istream iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">in</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> eof<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> eof<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>istream_iterator 允许使用懒惰求值</strong></p> <p>​		当我们将一个istream iterator 绑定到一个流时，标准库并不保证选代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。</p> <p><strong>ostream_iterator 操作</strong></p> <p>​		定义<code>ostream_iterator</code>对象时，必须将其绑定到一个指定的流。不允许定义空的或者表示尾后位置的<code>ostream_iterator</code>。</p> <p>​		<code>*</code>和<code>++</code>运算符实际上不会对<code>ostream_iterator</code>对象做任何操作。但是建议代码写法与其他迭代器保持一致。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">out_iter</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> vec<span class="token punctuation">)</span>
    <span class="token operator">*</span>out_iter<span class="token operator">++</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token comment">// 赋值语句将元素写道cout</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		可以为任何定义了<code>&lt;&lt;</code>运算符的类型创建<code>istream_iterator</code>对象，为定义了<code>&gt;&gt;</code>运算符的类型创建<code>ostream_iterator</code>对象。</p> <h4 id="反向迭代器"><a href="#反向迭代器" class="header-anchor">#</a> 反向迭代器</h4> <p>​		显示一个名为vec的假设的vector上的4钟迭代器：</p> <p><img src="https://raw.githubusercontent.com/moyangsun/ty_assist/main/img/MatLab202404211040705.png" alt="image-20240421104021364"></p> <p>​		递增反向迭代器会移动到前一个元素，递减会移动到后一个元素。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 按&quot;正常序&quot;排序vec</span>
<span class="token comment">// 按逆序排列：将最小元素放在vec末尾</span>
<span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>反向迭代器需要递减运算符</strong></p> <p>​		我们只能从既支持<code>++</code>也支持<code>--</code>的迭代器来定义反向迭代器。流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不能从<code>forward_list</code>或流迭代器创建反向迭代器。</p> <p><strong>反向迭代器和其他迭代器间的关系</strong></p> <p>​		调用反向迭代器的<code>base</code>函数可以获得其对应的普通迭代器。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 在一个逗号分隔的列表中查找最后一个元素</span>
<span class="token keyword">auto</span> rcomma <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> line<span class="token punctuation">.</span><span class="token function">crend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 错误:将逆序输出单词的字符</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rcomma<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token comment">// 正确:得到一个正向迭代器，从逐号开始读取字符直到 line 末尾</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>rcomma<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> line<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		反向迭代器的目的是表示元素范围，而这些范围是不对称的。用普通迭代器初始化反向迭代器，或者给反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同元素。</p> <h3 id="_10-5-范式算法"><a href="#_10-5-范式算法" class="header-anchor">#</a> 10.5 范式算法</h3> <p>​		算法所要求的迭代器操作可以分为5个选代器类别 (iterator category)，每个算法都会对它的每个选代器参数指明须提供哪类迭代器：</p> <table><thead><tr><th>迭代器类型</th> <th>功能</th></tr></thead> <tbody><tr><td>输入迭代器</td> <td>只读，不写；单遍扫描，只能递增</td></tr> <tr><td>输出迭代器</td> <td>只写，不读；单遍扫描，只能递增</td></tr> <tr><td>前向迭代器</td> <td>可读写；多遍扫描，只能递增</td></tr> <tr><td>双向迭代器</td> <td>可读写；多遍扫描，可递增递减</td></tr> <tr><td>随机访问迭代器</td> <td>可读写；多遍扫描，支持全部迭代器运算</td></tr></tbody></table> <h4 id="五类迭代器"><a href="#五类迭代器" class="header-anchor">#</a> 五类迭代器</h4> <p>​		C++标准指定了泛型和数值算法的每个迭代器参数的最小类别。对于迭代器实参来说，其能力必须大于或等于规定的最小类别。向算法传递更低级的迭代器参数会产生错误（大部分编译器不会提示错误）。</p> <p>迭代器类别：</p> <ul><li><p>输入迭代器（input iterator）：可以读取序列中的元素，只能用于单遍扫描算法。必须支持以下操作：</p> <ul><li>用于比较两个迭代器相等性的相等<code>==</code>和不等运算符<code>!=</code>。</li> <li>用于推进迭代器位置的前置和后置递增运算符<code>++</code>。</li> <li>用于读取元素的解引用运算符<code>*</code>；解引用只能出现在赋值运算符右侧。</li> <li>用于读取元素的箭头运算符<code>-&gt;</code>。</li></ul></li> <li><p>输出迭代器（output iterator）：可以读写序列中的元素，只能用于单遍扫描算法，通常指向目的位置。必须支持以下操作：</p> <ul><li>用于推进迭代器位置的前置和后置递增运算符<code>++</code>。</li> <li>用于读取元素的解引用运算符<code>*</code>；解引用只能出现在赋值运算符左侧（向已经解引用的输出迭代器赋值，等价于将值写入其指向的元素）。</li></ul></li> <li><p>前向迭代器（forward iterator）：可以读写序列中的元素。只能在序列中沿一个方向移动。支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此可以使用前向迭代器对序列进行多遍扫描。</p></li> <li><p>双向迭代器（bidirectional iterator）：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，还支持前置和后置递减运算符<code>--</code>。除<code>forward_list</code>之外的其他标准库容器都提供符合双向迭代器要求的迭代器。</p></li> <li><p>随机访问迭代器（random-access iterator）：可以在常量时间内访问序列中的任何元素。除了支持所有双向迭代器的操作之外，还必须支持以下操作：</p> <ul><li>用于比较两个迭代器相对位置的关系运算符<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>。</li> <li>迭代器和一个整数值的加减法运算<code>+</code>、<code>+=</code>、<code>-</code>、<code>-=</code>，计算结果是迭代器在序列中前进或后退给定整数个元素后的位置。</li> <li>用于两个迭代器上的减法运算符<code>-</code>，计算得到两个迭代器的距离。</li> <li>下标运算符<code>[]</code>。</li></ul></li></ul> <h4 id="算法形参模式"><a href="#算法形参模式" class="header-anchor">#</a> 算法形参模式</h4> <p>​	大多数算法的形参模式是以下四种形式之一：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> other args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> other args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> other args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> other args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		其中<code>alg</code>是算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于算法操作。<code>dest</code>表示输出范围，<code>beg2</code>和<code>end2</code>表示第二个输入范围。</p> <p><strong>接受单个目标迭代器的算法</strong></p> <p>​		dest 参数是一个表示算法可以写入的目的位置的选代器。算法假定:按其需要写入数据，不管写入多少个元素都是安全的。</p> <p>​		向输出迭代器写入数据的算法都假定目标空间足够容纳要写入的数据。</p> <p><strong>接受第二个输入序列的算法</strong></p> <p>​		接受单独一个迭代器参数表示第二个输入范围的算法都假定从迭代器参数开始的序列至少与第一个输入范围一样大。</p> <h4 id="算法命名规范"><a href="#算法命名规范" class="header-anchor">#</a> 算法命名规范</h4> <p>​		除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如:如何提供一个操作代替默认的<code>&lt;</code>或<code>==</code>运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p> <p><strong>一些算法使用重载形式传递一个谓词</strong></p> <p>接受谓词参数来代替<code>&lt;</code>或<code>==</code>运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素:另一个版本接受一个额外谓词参数，来代替<code>&lt;</code>或<code>==</code>:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">unique</span><span class="token punctuation">(</span>beg，end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用 == 运算符比较元素</span>
<span class="token function">unique</span><span class="token punctuation">(</span>beg，end，comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用comp 比较元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>_if版本的算法</strong></p> <p>​		接受谓词参数的算法都有附加的<code>_if</code>后缀。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 查找输入范围中 val 第一次出现的位置</span>
<span class="token function">find_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 查找第一个令 pred 为真的元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>区分拷贝元素的版本和不拷贝的版本</strong></p> <p>​		将执行结果写入额外目的空间的算法都有<code>_copy</code>后缀。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">reverse</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 反转输入范围中元素的顺序</span>
<span class="token function">reverse_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 将元素按逆序拷贝到 dest</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		一些算法同时提供<code>_copy</code>和<code>_if</code>版本。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//从v1中删除奇数元素</span>
remove <span class="token keyword">if</span><span class="token punctuation">(</span>vl<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，vl<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
				<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span> <span class="token keyword">return</span> i<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将偶数元素从 v1拷贝到 v2;v1不变</span>
remove <span class="token function">_copy_if</span><span class="token punctuation">(</span>vl<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，vl<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，back <span class="token function">inserter</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">,</span>
					<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">[</span> <span class="token keyword">return</span> i2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_10-6-特定容器算法"><a href="#_10-6-特定容器算法" class="header-anchor">#</a> 10.6 特定容器算法</h3> <p>​		对于<code>list</code>和<code>forward_list</code>类型，应该优先使用成员函数版本的算法，而非通用算法。</p> <p>​		链表特有版本的算法操作会改变底层容器。</p> <h2 id="第十一章-关联容器"><a href="#第十一章-关联容器" class="header-anchor">#</a> 第十一章 关联容器</h2> <p>​		关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p> <p>​		关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是<code>map</code>和<code>set</code>。</p> <ul><li><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</li> <li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</li></ul> <p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p> <ul><li>是<code>map</code>还是<code>set</code>类型。</li> <li>是否允许保存重复的关键字。</li> <li>是否按顺序保存元素。</li></ul> <p>​		允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p> <ul><li><p>有序容器：</p> <table><thead><tr><th>类型</th> <th>特性</th></tr></thead> <tbody><tr><td><code>map</code></td> <td>保存键值对的关联数组</td></tr> <tr><td><code>set</code></td> <td>只保存关键字的容器</td></tr> <tr><td><code>multimap</code></td> <td>关键字可重复出现的<code>map</code></td></tr> <tr><td><code>multiset</code></td> <td>关键字可重复出现的<code>set</code></td></tr></tbody></table></li> <li><p>无序容器：</p> <table><thead><tr><th>类型</th> <th>特性</th></tr></thead> <tbody><tr><td><code>unordered_map</code></td> <td>用哈希函数管理的<code>map</code></td></tr> <tr><td><code>unordered_set</code></td> <td>用哈希函数管理的<code>set</code></td></tr> <tr><td><code>unordered_multimap</code></td> <td>关键字可重复出现的<code>unordered_map</code></td></tr> <tr><td><code>unordered_multiset</code></td> <td>关键字可重复出现的<code>unordered_set</code></td></tr></tbody></table> <p>​		<code>map</code>和<code>multimap</code>类型定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>类型定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p></li></ul> <h3 id="_11-1-使用关联容器"><a href="#_11-1-使用关联容器" class="header-anchor">#</a> 11.1 使用关联容器</h3> <p>​		<code>map</code>类型通常被称为关联数组（associative array）。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。</p> <h4 id="使用map"><a href="#使用map" class="header-anchor">#</a> 使用map</h4> <p>​		从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 统计每个单词再输入中出现的次数</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> word_count<span class="token punctuation">;</span>     <span class="token comment">// string到size_t的空map</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
    <span class="token operator">++</span>word_count<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 提取 word 的计数器并将其加 1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>w <span class="token operator">:</span> word_count<span class="token punctuation">)</span>    <span class="token comment">// 对map中的每个元素</span>
    <span class="token comment">// 打印结果</span>
    cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; occurs &quot;</span> <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>second
        <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>second <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot; times&quot;</span> <span class="token operator">:</span> <span class="token string">&quot; time&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="使用set"><a href="#使用set" class="header-anchor">#</a> 使用set</h4> <p>​		上个示例程序的一个合理扩展是:忽略常见单词，如&quot;the&quot;、&quot;and&quot;&quot;or&quot;等。我们可以使用 set 保存想忽略的单词，只对不在集合中的单词统计出现次数:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 统计每个单词再输入中出现的次数</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> word_count<span class="token punctuation">;</span>     <span class="token comment">// string到size_t的空map</span>
set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> exclude <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;The&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;But&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;And&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Or&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;An&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;the&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;but&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;or&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
    <span class="token comment">// 只统计不在 exclude 中的单词</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>exclude<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> exclude<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    	<span class="token operator">++</span>word_count<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 获取并递增 word的计数器</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>w <span class="token operator">:</span> word_count<span class="token punctuation">)</span>    <span class="token comment">// 对map中的每个元素</span>
    <span class="token comment">// 打印结果</span>
    cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; occurs &quot;</span> <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>second
        <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>second <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot; times&quot;</span> <span class="token operator">:</span> <span class="token string">&quot; time&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​		<code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p> <h3 id="_11-2-关联容器概述"><a href="#_11-2-关联容器概述" class="header-anchor">#</a> 11.2 关联容器概述</h3> <p>​		关联容器都支持9.2节中介绍的普通容器的操作。关联容器不支持顺序容器的位置相关的操作。关联容器中的元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素和一个数量值的操作。</p> <p>​		处理与顺序容器相同的操作外，关联容器还支持一些顺序容器不支持的操作和类型别名，此外无序容器还提供一些用来调整哈希性能的操作。</p> <p>​		关联容器的迭代器都是双向的。</p> <h4 id="定义关联容器"><a href="#定义关联容器" class="header-anchor">#</a> 定义关联容器</h4> <p>​		定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p> <p>​		初始化<code>map</code>时，提供的每个键值对用花括号<code>{}</code>包围。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> word_count<span class="token punctuation">;</span>   <span class="token comment">// 空容器</span>
<span class="token comment">// 列表初始化</span>
set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> exclude <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;but&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;and&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 三个元素；authors将姓映射为名</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span> authors <span class="token operator">=</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token string">&quot;Joyce&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;James&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;Austen&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;Dickens&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Charles&quot;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​		与以往一样，初始化器必须能转换为容器中元素的类型。对于 <code>set</code>，元素类型就是关键字类型。
​		当初始化一个 <code>map</code> 时，必须提供关键字类型和值类型。我们将每个关键字-值对包围在花括号中:</p> <p>​		<code>{key，value}</code></p> <p>​		来指出它们一起构成了 <code>map</code> 中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。因此，<code>authors</code> 将姓映射到名，初始化后它包含三个元素。</p> <p>**初始化multimap或multiset **</p> <p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 定义一个有20个元素的 vector，保存0到9每个整数的两个拷贝</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size type i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ivec<span class="token punctuation">.</span>push <span class="token function">back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ivec<span class="token punctuation">.</span>push <span class="token function">back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 每个数重复保存一次</span>
<span class="token punctuation">}</span>
<span class="token comment">// iset包含来自 ivec 的不重复的元素:miset 包含所有 20 个元素</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">iset</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ivec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
multiset<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">miset</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ivec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 打印出20</span>
cout <span class="token operator">&lt;&lt;</span> iset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 打印出10</span>
cout <span class="token operator">&lt;&lt;</span> miset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 打印出20</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="关联字类型的要求"><a href="#关联字类型的要求" class="header-anchor">#</a> 关联字类型的要求</h4> <p>​		对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p> <p>​		传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求。</p> <p><strong>有序容器的关键词类型</strong></p> <p>​		可以向一个算法提供我们自己定义的比较操作，与此类似，也可以提供自己定义的操作来代替关键词上的<code>&lt;</code>运算符。所提供的操作必须再关键词类型上定义一个<strong>严格弱序</strong>。可以将严格弱序看作是”小于等于“。无论我们怎么定义比较函数，它必须具备如下基本性质：</p> <ul><li>两个关键字不能同时“小于等于”对方;如果 k1“小于等于”k2，那么 k2 绝不能“小于等于”k1。</li> <li>如果 k1“小于等于”k2，且 k2“小于等于”k3，那么 k1 必须“小于等于”k3。</li> <li>如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果 k1“等价于”k2，且 k2“等价于”k3，那么 k1 必须“等价于”k3。</li></ul> <p><strong>使用关键字类型的比较函数</strong></p> <p>​		用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">compareIsbn</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// bookstore中多条记录可以有相同的 ISBN</span>
<span class="token comment">// bookstore 中的元素以 ISBN 的顺序进行排列</span>
multiset<span class="token operator">&lt;</span>Sales_data<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>compareIsbn<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">bookstore</span><span class="token punctuation">(</span>compareIsbn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="pair类型"><a href="#pair类型" class="header-anchor">#</a> pair类型</h4> <p>​		<code>pair</code>定义在头文件<code>utility</code>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span> anon<span class="token punctuation">;</span>        <span class="token comment">// 保存两个string</span>
pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> word_count<span class="token punctuation">;</span>  <span class="token comment">// 保存一个string和一个size_t</span>
pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> line<span class="token punctuation">;</span>   <span class="token comment">// 保存string和vector&lt;int&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		<code>pair</code>的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 这条语句创建一个名为 author 的 pair，两个成员被初始化为&quot;James&quot;和&quot;Joyce&quot;</span>
pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>string<span class="token operator">&gt;</span> author<span class="token punctuation">{</span><span class="token string">&quot;James&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Joyce&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>创建pair对象的函数</strong></p> <p>​		在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">process</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 处理v</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 列表初始化</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// 隐式构造返回值</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_11-3-关联容器操作"><a href="#_11-3-关联容器操作" class="header-anchor">#</a> 11.3 关联容器操作</h3> <p>​		关联容器定义了类型别名来表示容器关键字和值的类型。</p> <table><thead><tr><th>类型</th> <th>含义</th></tr></thead> <tbody><tr><td><code>key_type</code></td> <td>容器的关键字类型</td></tr> <tr><td><code>mapped_type</code></td> <td><code>map</code>的值类型</td></tr> <tr><td><code>value_type</code></td> <td>对于<code>set</code>，与<code>key_type</code>相同 对于<code>map</code>，为<code>pair&lt;const key_type, mapped_type&gt;</code></td></tr></tbody></table> <p>​		对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是键值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type v1<span class="token punctuation">;</span>        <span class="token comment">// v1 是一个string</span>
set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>key_type v2<span class="token punctuation">;</span>          <span class="token comment">// v2 是一个string</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type v3<span class="token punctuation">;</span>   <span class="token comment">// v3 是一个&lt;const string, int&gt;</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>key_type v4<span class="token punctuation">;</span>     <span class="token comment">// v4 是一个string</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>mapped_type v5<span class="token punctuation">;</span>  <span class="token comment">// v5 是一个int</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="关联容器迭代器"><a href="#关联容器迭代器" class="header-anchor">#</a> 关联容器迭代器</h4> <p>​		解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 获得指向 word_count 中一个元素的选代器</span>
<span class="token keyword">auto</span> map_it <span class="token operator">=</span> word_count<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// *map_it 是指向一个pair&lt;const string，size_t&gt;对象的引用</span>
cout <span class="token operator">&lt;&lt;</span> map_it<span class="token operator">-&gt;</span>first<span class="token punctuation">;</span>          <span class="token comment">// 打印此元素的关键字</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> map_it<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>  <span class="token comment">// 打印此元素的值</span>
map_it<span class="token operator">-&gt;</span>first <span class="token operator">=</span> <span class="token string">&quot;new key&quot;</span><span class="token punctuation">;</span>      <span class="token comment">// 错误:关键字是 const 的</span>
<span class="token operator">++</span>map_it<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>               <span class="token comment">// 正确：我们可以通过迭代器改变元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​		必须记住，一个map的value type是一个pair，我们可以改变 pair的值，但不能改变关键字成员的值。</p> <p><strong>set的迭代器是const的</strong></p> <p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> iset <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator set_it <span class="token operator">=</span> iset<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>set_it <span class="token operator">!=</span> iset<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">*</span>set_it <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>       <span class="token comment">// 错误：set中的关键字是只读的</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>set_it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 正确：可以读关键字</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>遍历关联容器</strong></p> <p>​		<code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 获得一个指向首元素的迭代器</span>
<span class="token keyword">auto</span> map_it <span class="token operator">=</span> word_count<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 比较当前迭代器和尾后迭代器</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>map it <span class="token operator">!=</span> word_count<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解引用迭代器，打印关键字-值对</span>
    cout <span class="token operator">&lt;&lt;</span> map_it<span class="token operator">-&gt;</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; occurs &quot;</span>
    	 <span class="token operator">&lt;&lt;</span> map_it<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span><span class="token string">&quot; times&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token operator">++</span>map_it<span class="token punctuation">;</span><span class="token comment">//递增选代器，移动到下一个元素</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>关联容器和算法</strong></p> <p>​		通常不对关联容器使用泛型算法，主要是由于const的特性使然。set中的元素是const的，map中的元素是pair，其中第一个元素是const的。</p> <h4 id="添加元素"><a href="#添加元素" class="header-anchor">#</a> 添加元素</h4> <p>​		使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// ivec有8个元素</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> set2<span class="token punctuation">;</span>					 	       <span class="token comment">// 空集合</span>
set2<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， ivec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// set2有4个元素</span>
set2<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//set2 现在有 8个元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		<code>insert</code> 有两个版本，分别接受一对迭代器，或是一个初始化器列表</p> <p><strong>向map添加元素</strong></p> <p>​		通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 向word_count插入word的4种方法</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">value_type</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>检测insert的返回值</strong></p> <p>​		<code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p> <ul><li>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</li> <li>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</li></ul> <p><strong>展开递增语句</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token operator">-&gt;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等价的表达</span>

<span class="token comment">// 展开讲解</span>
ret <span class="token comment">//保存 insert 返回的值，是一个 pair。</span>
ret<span class="token punctuation">.</span>first <span class="token comment">//是 pair 的第一个成员，是一个map 选代器，指向具有给定关键字的元素。</span>
ret<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span> <span class="token comment">//解引用此迭代器，提取 map 中的元素，元素也是一个 pair。</span>
ret<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>second <span class="token comment">//map 中元素的值部分。</span>
<span class="token operator">++</span>ret<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>second <span class="token comment">//递增此值。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>向multiset或multimap添加元素</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>multimap<span class="token operator">&lt;</span>string， string<span class="token operator">&gt;</span> authors<span class="token punctuation">;</span>
<span class="token comment">// 插入第一个元素，关键字为 Barth， John</span>
authors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;Barth, John&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Sot-Weed Factor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确:添加第二个元素，关键字也是 Barth， John</span>
authors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;Barth, John&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Lost in the Funhouse&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="删除元素"><a href="#删除元素" class="header-anchor">#</a> 删除元素</h4> <p>​		与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 删除一个关键字，返回删除的元素数量</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>word count<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>removal word<span class="token punctuation">)</span><span class="token punctuation">)</span>
	cout <span class="token operator">&lt;&lt;</span><span class="token string">&quot;ok: &quot;</span> <span class="token operator">&lt;&lt;</span> removal word <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; removed\n&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span><span class="token string">&quot;oops:&quot;</span> <span class="token operator">&lt;&lt;</span> removal word <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; not found!\n&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		对允许重复关键词的容器，删除元素的数量可能大于1</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> cnt <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token string">&quot;Barth,John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="map的下标操作"><a href="#map的下标操作" class="header-anchor">#</a> map的下标操作</h4> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>c[k]</code></td> <td>返回关键字为<code>k</code>的元素；若<code>k</code>不存在，则向<code>c</code>中添加并进行值初始化</td></tr> <tr><td><code>c.at(k)</code></td> <td>返回关键字为<code>k</code>的元素；若<code>k</code>不存在，则抛出<code>out_of_range</code>异常</td></tr></tbody></table> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>map <span class="token operator">&lt;</span>string，size t<span class="token operator">&gt;</span> word count<span class="token punctuation">;</span><span class="token comment">// empty map</span>
<span class="token comment">// 插入一个关键字为 Anna 的元素，关联值进行值初始化;然后将 1赋予它</span>
word count<span class="token punctuation">[</span><span class="token string">&quot;Anna&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>使用下标操作的返回值</strong></p> <p>​		<code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p> <p>​		由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p> <p>​		对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> word count<span class="token punctuation">[</span><span class="token string">&quot;Anna&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 用Anna作为下标提取元素:会打印出1</span>
<span class="token operator">++</span>word count<span class="token punctuation">[</span><span class="token string">&quot;Anna&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 提取元素，将其增 1</span>
cout <span class="token operator">&lt;&lt;</span> word count<span class="token punctuation">[</span><span class="token string">&quot;Anna&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 提取元素并打印它;会打印出 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="访问元素-2"><a href="#访问元素-2" class="header-anchor">#</a> 访问元素</h4> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>c.find(k)</code></td> <td>返回指向第一个关键字为<code>k</code>的元素的迭代器或尾后迭代器</td></tr> <tr><td><code>c.count(k)</code></td> <td>返回关键字为<code>k</code>的元素的数量</td></tr> <tr><td><code>c.lower_bound(k)</code></td> <td>返回指向第一个关键字不小于<code>k</code>的元素的迭代器</td></tr> <tr><td><code>c.upper_bound(k)</code></td> <td>返回指向第一个关键字大于<code>k</code>的元素的迭代器</td></tr> <tr><td><code>c.equal_range(k)</code></td> <td>返回一个迭代器<code>pair</code>，表示关键字为<code>k</code>的元素范围</td></tr></tbody></table> <p><strong>对map使用find代替下标操作</strong></p> <p>​		只是想知道一个给定关键字是否在 map 中，而不想改变 map。这样就不能使用下标运算符来检查一个元素是否存在，因为如果关键字不存在的话，下标运算符会插入一个新元素。在这种情况下，应该使用 find:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>word count<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;foobar&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> word_count<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cout<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;foobar is not in the map&quot;</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>在multimap或multiset中查找元素</strong></p> <p>​		如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">search_item</span><span class="token punctuation">(</span><span class="token string">&quot;Alain de Botton&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 要查找的作者</span>
<span class="token keyword">auto</span> entries <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 元素的数量</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 此作者的第一本书</span>
<span class="token comment">// 用一个循环查找此作者的所有著作</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 打印每个题目</span>
    <span class="token operator">++</span>iter<span class="token punctuation">;</span>      <span class="token comment">// 前进到下一本书</span>
    <span class="token operator">--</span>entries<span class="token punctuation">;</span>   <span class="token comment">// 记录已经打印了多少本书</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​		当我们遍历一个<code>multimap</code>或<code>multiset</code> 时，保证可以得到序列中所有具有给定关键字的元素。</p> <p><strong>一种不同的，面向迭代器的解决方法</strong></p> <p>​		<code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// authors和search_item 的定义，与前面的程序一样</span>
<span class="token comment">// beg和end 表示对应此作者的元素的范围</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">,</span>
        end <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    beg <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>beg<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> beg<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 打印每个题目</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		<code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p> <p><strong>equal_range函数</strong></p> <p>​		<code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// authors和search_item 的定义，与前面的程序一样</span>
<span class="token comment">// pos 保存选代器对，表示与关键字匹配的元素范围</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> pos <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos<span class="token punctuation">.</span>first <span class="token operator">!=</span> pos<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token operator">++</span>pos<span class="token punctuation">.</span>first<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> pos<span class="token punctuation">.</span>first<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 打印每个题目</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_11-4-无序容器"><a href="#_11-4-无序容器" class="header-anchor">#</a> 11.4 无序容器</h3> <p>​		新标准库定义了4个无序关联容器，这些容器使用哈希函数和关键字类型的<code>==</code>运算符组织元素。</p> <p>​		如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。</p> <p><strong>使用无序容器</strong></p> <p>​		无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 统计出现次数，但单词不会按宇典序排列</span>
unordered map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>size t<span class="token operator">&gt;</span> word count<span class="token punctuation">;</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
	<span class="token operator">++</span>word_count<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 提取并递增 word 的计数器</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>w <span class="token operator">:</span>word_count<span class="token punctuation">)</span> <span class="token comment">//对map 中的每个元素</span>
<span class="token comment">// 打印结果</span>
cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; occurs &quot;</span> <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>second
		<span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>second<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token string">&quot; times&quot;</span><span class="token operator">:</span><span class="token string">&quot;time&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​		对于每个单词，我们将得到相同的计数结果。但单词不太可能按字典序输出。</p> <p><strong>管理桶</strong></p> <p>​		无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p> <table><thead><tr><th>无序容器管理操作</th> <th></th></tr></thead> <tbody><tr><td>桶接口</td> <td></td></tr> <tr><td>c.bucket_count()</td> <td>正在使用的桶的数目</td></tr> <tr><td>c.max_bucket_count ()</td> <td>容器能容纳的最多的桶的数量</td></tr> <tr><td>c.bucket_size(n)</td> <td>第 n个桶中有多少个元素</td></tr> <tr><td>c.bucket(k)</td> <td>关键字为 k 的元素在哪个桶中</td></tr> <tr><td>桶迭代</td> <td></td></tr> <tr><td>local_iterator</td> <td>可以用来访问桶中元素的迭代器类型</td></tr> <tr><td>const_local_iterator</td> <td>桶迭代器的 const 版本</td></tr> <tr><td>c.begin(n)，c.end(n)</td> <td>桶n的首元素选代器和尾后选代器</td></tr> <tr><td>c.cbegin(n)，c.cend(n)</td> <td>与前两个函数类似，但返回 const_local_iterator</td></tr> <tr><td>哈希策略</td> <td></td></tr> <tr><td>c.load_factor()</td> <td>每个桶的平均元素数量，返回 float 值</td></tr> <tr><td>c.max_load_factor()</td> <td>c试图维护的平均桶大小，返回 float 值。c 会在需要时添加新的桶，以使得 load_factor&lt;=max_load_factor</td></tr> <tr><td>c.rehash(n)</td> <td>重组存储，使得 bucket_count&gt;=n且bucket_count&gt;size/max_load_factor</td></tr> <tr><td>c.reserve(n)</td> <td>重组存储，使得c可以保存n 个元素且不必 rehash</td></tr></tbody></table> <p><strong>无序容器对关键字类型的要求</strong></p> <p>​		默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 定义重载函数</span>
size_t <span class="token function">hasher</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>sd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sd<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">bool</span> <span class="token function">eqOp</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales data <span class="token operator">&amp;</span>lhs， <span class="token keyword">const</span> Sales data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> rhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 我们使用这些函数来定义一个 unordered_multiset</span>
<span class="token keyword">using</span> SD_multiset <span class="token operator">=</span> unordered multiset<span class="token operator">&lt;</span>Sales data<span class="token punctuation">,</span>
					<span class="token keyword">decltype</span><span class="token punctuation">(</span>hasher<span class="token punctuation">)</span><span class="token operator">*</span>，<span class="token keyword">decltype</span><span class="token punctuation">(</span>egOp<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// 参数是桶大小、哈希函数指针和相等性判断运算符指针</span>
SD_multiset <span class="token function">bookstore</span><span class="token punctuation">(</span><span class="token number">42</span>，hasher， egOp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果我们的类定义了==运算符，则可以只重载哈希函数:</span>
<span class="token comment">// 使用 EooHash 生成哈希值;Eoo 必须有==运算符</span>
unordered set<span class="token operator">&lt;</span>Foo， <span class="token keyword">decltype</span><span class="token punctuation">(</span>FooHash<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">fooSet</span><span class="token punctuation">(</span><span class="token number">10</span>，FooHash<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="header-anchor">#</a> 第十二章 动态内存</h2> <p>​		程序用堆来存储动态分配的对象。动态对象的生存期由程序控制。</p> <h3 id="_12-1-动态内存与智能指针"><a href="#_12-1-动态内存与智能指针" class="header-anchor">#</a> 12.1 动态内存与智能指针</h3> <p>​		C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</p> <p>​		新标准库提供了两种<strong>智能指针</strong>类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>独占所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在头文件<code>memory</code>中。</p> <h4 id="shared-ptr类"><a href="#shared-ptr类" class="header-anchor">#</a> shared_ptr类</h4> <p>​		智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> p1<span class="token punctuation">;</span>      <span class="token comment">// shared_ptr，可以指向string</span>
shared_ptr<span class="token operator">&lt;</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> p2<span class="token punctuation">;</span>   <span class="token comment">// shared_ptr，可以指向int的list</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 如果p1不为空，检查它是否指向一个空 string</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>pl <span class="token operator">&amp;&amp;</span> p1<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token operator">*</span>pl <span class="token operator">=</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">;</span><span class="token comment">// 如果pl指向一个空string，解引用pl，将一个新值赋予 string</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作：</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>shared_ptr&lt;T&gt; sp</code> <code>unique_ptr&lt;T&gt; up</code></td> <td>默认初始化为空指针</td></tr> <tr><td><code>p</code></td> <td>若<code>p</code>指向一个对象，则为<code>true</code></td></tr> <tr><td><code>*p</code></td> <td>解引用<code>p</code></td></tr> <tr><td><code>p-&gt;mem</code></td> <td>等价于<code>(*p).mem</code></td></tr> <tr><td><code>p.get()</code></td> <td>返回<code>p</code>中的指针</td></tr></tbody></table> <p><code>shared_ptr</code>独有的操作：</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>p.use_count()</code></td> <td>返回<code>p</code>的引用计数</td></tr> <tr><td><code>p.unique()</code></td> <td>若<code>p.use_count() == 1</code>，则返回<code>true</code></td></tr></tbody></table> <p><strong>make_shared函数</strong></p> <p>​		<code>make_shared</code>函数（定义在头文件<code>memory</code>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 指向一个值为42的int的 shared ptr</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// p4 指向一个值为”9999999999&quot;的 string</span>
shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> p4 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// p5指向一个值初始化的int，即，值为0</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p5 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		通常用auto定义一个对象来保存make_shared的结果，这种方式较为简单。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// p6 指向一个动态分配的空 vector&lt;string&gt;</span>
<span class="token keyword">auto</span> p6 <span class="token operator">=</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>shared_ptr的拷贝和赋值</strong></p> <p>​		进行拷贝或赋值操作时，每个<code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>与其指向相同的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// p指向的对象只有p一个引用者</span>
<span class="token keyword">auto</span> <span class="token function">q</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// p和q指向相同对象，此对象有两个引用者</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		每个<code>shared_ptr</code>都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝<code>shared_ptr</code>时引用计数会递增。例如使用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>，或将它作为参数传递给函数以及作为函数的返回值返回。给<code>shared_ptr</code>赋予新值或<code>shared_ptr</code>被销毁时引用计数会递减。例如一个局部<code>shared_ptr</code>离开其作用域。一旦一个<code>shared_ptr</code>的引用计数变为0，它就会自动释放其所管理的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> r <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// r指向的int 只有一个引用者</span>
r <span class="token operator">=</span> q<span class="token punctuation">;</span>  <span class="token comment">// 给r赋值，令它指向另一个地址</span>
        <span class="token comment">// 递增q 指向的对象的引用计数</span>
        <span class="token comment">// 递减r原来指向的对象的引用计数</span>
        <span class="token comment">// r 原来指向的对象已没有引用者，会自动释放</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个 <code>shared_ptr</code> 指向相同的对象，并能在恰当的时候自动释放对象</p> <p><strong>shared_ptr销毁对象</strong></p> <p>​		<code>shared_ptr</code>自动销毁所管理的对象，还会自动释放相关联的内存。通过shared_ptr的析构函数来完成。</p> <p>​		如果你将 <code>shared_ptr</code> 存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用 <code>erase</code>删除不再需要的那些元素</p> <p><strong>使用了动态生存期的资源的类</strong></p> <p>程序使用动态内存通常出于以下三种原因之一：</p> <ul><li><p>不确定需要使用多少对象。</p></li> <li><p>不确定所需对象的准确类型。</p></li> <li><p>需要在多个对象间共享数据。</p></li></ul> <p>使用动态内存的一个常见原因是允许多个对象共享相同的状态</p> <h4 id="直接管理内存"><a href="#直接管理内存" class="header-anchor">#</a> 直接管理内存</h4> <p>​		相对于智能指针，使用<code>new</code>和<code>delete</code>管理内存很容易出错。</p> <p><strong>使用new 动态分配和初始化对象</strong></p> <p>​		默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token operator">*</span>ps <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span>    <span class="token comment">// 初始化为空string</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>     <span class="token comment">// pi指向一个未初始化的int</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		可以使用值初始化方式、直接初始化方式、传统构造方式（圆括号<code>()</code>）或新标准下的列表初始化方式（花括号<code>{}</code>）初始化动态分配的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// pi指向的对象的值为 1024</span>
string <span class="token operator">*</span>ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// *ps为”9999999999&quot;</span>
<span class="token comment">// vector有10个元素，值依次从0到9</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">*</span>pv <span class="token operator">=</span> <span class="token keyword">new</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
string <span class="token operator">*</span>ps1 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span>     <span class="token comment">// 默认初始化为空 string</span>
string <span class="token operator">*</span>ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 值初始化为空 string</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>      <span class="token comment">// 默认初始化;*pi1的值未定义</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi2 <span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//值初始化为0;*pi2为0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​		只有当初始化的括号中仅有单一初始化器时才可以使用<code>auto</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// p指向一个与 obj类型相同的对象</span>
                            <span class="token comment">// 该对象用obj进行初始化</span>
<span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 错误:括号中只能有单个初始化器		</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>动态分配的 const 对象</strong></p> <p>​		可以用<code>new</code>分配<code>const</code>对象，返回指向<code>const</code>类型的指针。动态分配的<code>const</code>对象必须初始化。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 分配并初始化一个 const int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 分配并跌认初始化一个 const 的空 string</span>
<span class="token keyword">const</span> string <span class="token operator">*</span>pcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> string<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>内存耗尽</strong></p> <p>​		默认情况下，如果<code>new</code>不能分配所要求的内存空间，会抛出<code>bad_alloc</code>异常。使用定位<code>new</code>（placement new）可以阻止其抛出异常。定位<code>new</code>表达式允许程序向<code>new</code>传递额外参数。如果将<code>nothrow</code>传递给<code>new</code>，则<code>new</code>在分配失败后会返回空指针。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 如果分配失败，new 返回一个空指针</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>            <span class="token comment">// 如果分配失败，new抛出 std::bad_alloc</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment">// 如果分配失败，new 返回一个空指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>释放动态内存</strong></p> <p>​		我们通过<strong>delete</strong>表达式来将动态内存归还给系统。<code>delete</code>表达式接受一个指针，指向我们想要释放的对象：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">delete</span> p<span class="token punctuation">;</span><span class="token comment">// p 必须指向一个动态分配的对象或是一个空指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​		与<code>new</code>类型类似，<code>delete</code> 表达式也执行两个动作:销毁给定的指针指向的对象:释放对应的内存。</p> <p><strong>指针值和delete</strong></p> <p>​		我们传递给 <code>delete</code> 的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非 <code>new</code> 分配的内存，或者将相同的指针值释放多次，其行为是未定义的。虽然一个<code>const</code> 对象的值不能被改变，但它本身是可以被销毁的。如同任何其他动态对象一样，想要释放一个 <code>const</code> 动态对象，只要 <code>delete</code> 指向它的指针即可:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i，<span class="token operator">*</span>pil <span class="token operator">=</span> <span class="token operator">&amp;</span>i，<span class="token operator">*</span>pi2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span>pd<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span>，<span class="token operator">*</span>pd2<span class="token operator">=</span>pd<span class="token punctuation">;</span>
<span class="token keyword">delete</span> i<span class="token punctuation">;</span><span class="token comment">// 错误:不是一个指针</span>
<span class="token keyword">delete</span> pil<span class="token punctuation">;</span> <span class="token comment">// 未定义:pil指向一个局部变量</span>
<span class="token keyword">delete</span> pd<span class="token punctuation">;</span><span class="token comment">// 正确</span>
<span class="token keyword">delete</span> pd2<span class="token punctuation">;</span> <span class="token comment">//未定义:pd2 指向的内存已经被释放了</span>
<span class="token keyword">delete</span> pi2<span class="token punctuation">;</span><span class="token comment">// 正确:释放一个空指针总是没有错误的</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> pci<span class="token punctuation">;</span><span class="token comment">//正确:释放一个 const 对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>动态对象的生存期直到被释放时为止</strong></p> <p>​		由内置指针(而不是智能指针)管理的动态内存在被显式释放前一直都会存在</p> <p>使用 <code>new</code>和<code>delete</code>管理动态内存存在三个常见问题:</p> <ol><li>忘记 <code>delete</code> 内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。</li> <li>使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。</li> <li>同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了<code>delete</code> 操作,对象的内存就被归还给自由空间了如果我们随后又 <code>delete</code> 第二个指针，自由空间就可能被破坏。</li></ol> <p>​		坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。</p> <p><strong>delete 之后重置指针，这只是提供了有限的保护</strong></p> <p>​		在<code>delete</code>之后指针变成了<strong>空悬指针</strong>即，指向一块曾经保存数据对象但现在已经无效的内存的指针。为了防止后续的错误访问，应该在<code>delete</code>之后将指针值置空。</p> <h4 id="share-ptr和new结合使用"><a href="#share-ptr和new结合使用" class="header-anchor">#</a> share_ptr和new结合使用</h4> <p>​		可以用<code>new</code>返回的指针初始化智能指针。该构造函数是<code>explicit</code>的，因此必须使用直接初始化形式。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 错误: 必须使用直接初始化形式</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 正确:使用了直接初始化形式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替<code>delete</code>。</p> <p><strong>不要混合使用内置指针和智能指针</strong></p> <p>​		当将<code>shared_ptr</code>绑定到内置指针后，资源管理就应该交由<code>shared_ptr</code>负责。不应该再使用内置指针访问<code>shared_ptr</code>指向的内存。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 在函数被调用时 ptr 被创建并初始化</span>
<span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 使用 ptr</span>
<span class="token punctuation">}</span>   <span class="token comment">// ptr 离开作用域，被销毁</span>

shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//引用计数为1</span>
<span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 拷贝p会递增它的引用计数;在 process 中引用计数值为 2</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment">// 正确:引用计数值为 1</span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 危险:X是一个普通指针，不是一个智能指针</span>
<span class="token function">process</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 错误:不能将 int*转换为一个 shared ptr&lt;int&gt;</span>
<span class="token function">process</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 合法的，但内存会被释放!!</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>     <span class="token comment">// 未定义的:x是一个空悬指针!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>不要使用get初始化另一个智能指针或为智能指针赋值</strong></p> <p>​		智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>返回指针的代码不能<code>delete</code>此指针。</p> <p>​		不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 引用计数为 1</span>
<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确:但使用 q 时要注意，不要让它管理的指针被释放</span>
<span class="token punctuation">{</span>   <span class="token comment">// 新程序块</span>
    <span class="token comment">// 未定义:两个独立的 shared ptr 指向相同的内存</span>
    <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 程序块结束，q 被销毁，它指向的内存被释放</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>   <span class="token comment">// 未定义:p指向的内存已经被释放了</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​		<code>get</code> 用来将指针的访问权限传递给代码，你只有在确定代码不会 <code>delete</code> 指针的情况下，才能使用 <code>get</code>。特别是，永远不要用 <code>get</code> 初始化另一个智能指针或者为另一个智能指针赋值。</p> <p><strong>其他shared_ptr 操作</strong></p> <p>​		可以用<code>reset</code>函数将新的指针赋予<code>shared_ptr</code>。与赋值类似，<code>reset</code>会更新引用计数，如果需要的话，还会释放内存空间。<code>reset</code>经常与<code>unique</code>一起使用，来控制多个<code>shared_ptr</code>共享的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 我们不是唯一用户;分配新的拷贝</span>
<span class="token operator">*</span>p <span class="token operator">+=</span> newVal<span class="token punctuation">;</span>   <span class="token comment">// 现在我们知道自己是唯一的用户，可以改变对象的值</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="智能指针和异常"><a href="#智能指针和异常" class="header-anchor">#</a> 智能指针和异常</h4> <p>​		如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 分配一个新对象</span>
    <span class="token comment">// 这段代码抛出一个异常，且在 f中未被捕获</span>
<span class="token punctuation">}</span> <span class="token comment">// 在函数结束时 shared ptr 自动释放内存</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		如果使用内置指针管理内存，且在 <code>new</code> 之后在对应的 <code>delete</code> 之前发生了异常，则内存不会被释放:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 动态分配一个新对象</span>
    <span class="token comment">// 这段代码抛出一个异常，且在 f 中未被捕获</span>
    <span class="token keyword">delete</span> ip<span class="token punctuation">;</span>     <span class="token comment">// 在退出之前释放内存</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		如果在 new 和 delete 之间发生异常，且异常未在 中被捕获，则内存就永远不会被释放了。在函数 f 之外没有指针指向这块内存，因此就无法释放它了。</p> <p><strong>智能指针和哑类</strong></p> <p>​		有些类不具有良好定义的析构函数，如c和c++在使用的网络库：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">destination</span><span class="token punctuation">;</span>    <span class="token comment">// 表示我们正在连接什么</span>
<span class="token keyword">struct</span> <span class="token class-name">connection</span><span class="token punctuation">;</span>     <span class="token comment">// 使用连接所需的信息</span>
connection <span class="token function">connect</span><span class="token punctuation">(</span>destination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打开连接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭给定的连接</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>destination <span class="token operator">&amp;</span>d <span class="token comment">/* 其他参数 */</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//获得一个连接;记住使用完后要关闭它</span>
    connection c <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>connection<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> end_connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用连接</span>
    <span class="token comment">// 如果我们在 f 退出前忘记调用 disconnect，就无法关闭 C了</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>使用我们自己的释放操作</strong></p> <p>​		我们必须首先定义一个函数来代替 delete。这个删除器函数必须能够完成对 shared ptr中保存的指针进行释放的操作。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">end_connection</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>智能指针规范：</p> <ul><li>不使用相同的内置指针值初始化或<code>reset</code>多个智能指针。</li> <li>不释放<code>get</code>返回的指针。</li> <li>不使用<code>get</code>初始化或<code>reset</code>另一个智能指针。</li> <li>使用<code>get</code>返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</li> <li>使用<code>shared_ptr</code>管理并非<code>new</code>分配的资源时，应该传递删除函数。</li></ul> <h4 id="unique-ptr"><a href="#unique-ptr" class="header-anchor">#</a> unique_ptr</h4> <p>​		与<code>shared_ptr</code>不同，同一时刻只能有一个<code>unique_ptr</code>指向给定的对象。当<code>unique_ptr</code>被销毁时，它指向的对象也会被销毁。</p> <p>​		<code>make_unique</code>函数（C++14新增，定义在头文件<code>memory</code>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>unique_ptr</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// C++14</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		由于<code>unique_ptr</code>独占其指向的对象，因此<code>unique_ptr</code>不支持普通的拷贝或赋值操作。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>unique ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">pl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;Stegosaurus&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误:unique ptr 不支持拷贝</span>
unique ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> p3<span class="token punctuation">;</span>
p3<span class="token operator">=</span>p2<span class="token punctuation">;</span><span class="token comment">//错误:unique ptr 不支持赋值、</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		<code>release</code>函数返回<code>unique_ptr</code>当前保存的指针并将其置为空。</p> <p>​		<code>reset</code>函数成员接受一个可选的指针参数，重新设置<code>unique_ptr</code>保存的指针。如果<code>unique_ptr</code>不为空，则它原来指向的对象会被释放。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 将所有权从p1(指向 string stegosaurus)转移给 p2</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// release将p1置为空</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;Trex&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将所有权从p3 转移给 p2</span>
p2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p3<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reset 释放了p2原来指向的内存</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		调用<code>release</code>会切断<code>unique_ptr</code>和它原来管理的对象之间的联系。<code>release</code>返回的指针通常被用来初始化另一个智能指针或给智能指针赋值。如果没有用另一个智能指针保存<code>release</code>返回的指针，程序就要负责资源的释放。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 错误: P2 不会释放内存，而且我们丢失了指针</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> p2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确，但我们必须记得 delete(p)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>传递unique_ptr 参数和返回unique_ptr</strong></p> <p>​		不能拷贝<code>unique_ptr</code>的规则有一个例外：可以拷贝或赋值一个即将被销毁的<code>unique_ptr</code>（移动构造、移动赋值）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ret</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// . . .</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>标准库的较早版本包含了一个名为<code>auto_ptr</code>的类，它具有 <code>unique_ptr</code>的部分特性，但不是全部。特别是，我们不能在容器中保存 <code>auto_ptr</code>，也不能从函数中返回<code>auto_ptr</code>。虽然<code>auto_ptr</code>仍是标准库的一部分，但编写程序时应该使用<code>unique_ptro</code>。</p> <p><strong>向unique_ptr 传递删除器</strong></p> <p>​		类似<code>shared_ptr</code>，默认情况下<code>unique_ptr</code>用<code>delete</code>释放其指向的对象。<code>unique_ptr</code>的删除器同样可以重载，但<code>unique_ptr</code>管理删除器的方式与<code>shared_ptr</code>不同。定义<code>unique_ptr</code>时必须在尖括号中提供删除器类型。创建或<code>reset</code>这种<code>unique_ptr</code>类型的对象时，必须提供一个指定类型的可调用对象（删除器）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// p 指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象</span>
<span class="token comment">// 它会调用一个名为 fcn 的 delT 类型对象</span>
unique_ptr<span class="token operator">&lt;</span>objT<span class="token punctuation">,</span> delT<span class="token operator">&gt;</span> <span class="token function">p</span> <span class="token punctuation">(</span><span class="token keyword">new</span> objT<span class="token punctuation">,</span> fcn<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>destination <span class="token operator">&amp;</span>d <span class="token comment">/* 其他需要的参数 */</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    connection c <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打开连接</span>
    <span class="token comment">//当 p被销毁时，连接将会关闭</span>
    unique_ptr<span class="token operator">&lt;</span>connection<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>end_connection<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> end_connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用连接</span>
    <span class="token comment">// 当 f退出时(即使是由于异常而退出)，connection 会被正确关闭</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="weak-ptr"><a href="#weak-ptr" class="header-anchor">#</a> weak_ptr</h4> <p>​		<code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针，它指向一个由<code>shared_ptr</code>管理的对象。将<code>weak_ptr</code>绑定到<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。如果<code>shared_ptr</code>被销毁，即使有<code>weak_ptr</code>指向对象，对象仍然有可能被释放。</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>weak_ptr&lt;T&gt; w(sp)</code></td> <td><code>w</code>与<code>shared_ptr sp</code>指向相同对象</td></tr> <tr><td><code>w.use_count()</code></td> <td>返回与<code>w</code>共享对象的<code>shared_ptr</code>的数量·</td></tr> <tr><td><code>w.expired()</code></td> <td>若<code>w.use_count() == 0</code>，则返回<code>true</code></td></tr> <tr><td><code>w.lock()</code></td> <td>若<code>w.expired() == true</code>，则返回空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code></td></tr></tbody></table> <p>​		创建一个<code>weak_ptr</code>时，需要使用<code>shared_ptr</code>来初始化它。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">wp</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// wp 弱共享p;p的引用计数未改变</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		使用<code>weak_ptr</code>访问对象时，必须先调用<code>lock</code>函数。该函数检查<code>weak_ptr</code>指向的对象是否仍然存在。如果存在，则返回指向共享对象的<code>shared_ptr</code>，否则返回空指针。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> np <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 如果 np不为空则条件成立</span>
    <span class="token comment">//在if中，np与p共享对象</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_12-2-动态数组"><a href="#_12-2-动态数组" class="header-anchor">#</a> 12.2 动态数组</h3> <p>​		使用<code>allocator</code>类可以将内存分配和初始化过程分离，这通常会提供更好的性能和更灵活的内存管理能力。</p> <p>​		大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</p> <h4 id="new和数组"><a href="#new和数组" class="header-anchor">#</a> new和数组</h4> <p>​		使用<code>new</code>分配对象数组时需要在类型名之后跟一对方括号，在其中指明要分配的对象数量（必须是整型，但不必是常量）。<code>new</code>返回指向第一个对象的指针（元素类型）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 调用get_size确定分配多少个int</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// pia 指向第一个int</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		也可以用一个表示数组类型的类型别名来分配一个数组，这样，<code>new</code> 表达式中就不需要方括号了:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span> arrT<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// arrT 表示 42个int 的数组类型</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> arrT<span class="token punctuation">;</span><span class="token comment">// 分配一个42个int 的数组;p指向第一个nt</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>分配一个数组会得到一个元素类型的指针</strong></p> <p>​		由于<code>new</code>分配的内存并不是数组类型，因此不能对动态数组调用<code>begin</code>和<code>end</code>，也不能用范围<code>for</code>语句处理其中的元素。</p> <p>​		要记住我们所说的动态数组并不是数组类型，这是很重要的。</p> <p><strong>初始化动态分配对象的数组</strong></p> <p>​		默认情况下，<code>new</code>分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小后面跟一对空括号<code>()</code>。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则<code>new</code>表达式失败，不会分配任何内存，并抛出<code>bad_array_new_length</code>异常。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>pia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 10个未初始化的 int</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pia2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 10个值初始化为0的int</span>
string <span class="token operator">*</span>psa <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 10个空string</span>
string <span class="token operator">*</span>psa2 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 10 个空 string</span>
<span class="token comment">// 10 个 int 分别用列表中对应的初始化器初始化</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pia3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 10个 string，前 4 个用给定的初始化器初始化，剩余的进行值初始化</span>
string <span class="token operator">*</span>psa3 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token char">'x'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​		虽然可以使用空括号对<code>new</code>分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用<code>auto</code>分配数组</p> <p><strong>动态分配一个空数组是合法的</strong></p> <p>​		动态分配一个空数组是合法的，此时<code>new</code>会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 错误:不能定义长度为 0的数组</span>
<span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 正确:但cp 不能解引用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>释放动态数组</strong></p> <p>​		使用<code>delete[]</code>释放动态数组。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">delete</span> p<span class="token punctuation">;</span>       <span class="token comment">// p必须指向一个动态分配的对象或为空</span>
<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> pa<span class="token punctuation">;</span>   <span class="token comment">// pa 必须指向一个动态分配的数组或为空</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		如果我们在<code>delete</code>一个数组指针时忘记了方括号,或者在 <code>delete</code>一个单一对象的指针时使用了方括号，编译器很可能不会给出警告。我们的程序可能在执行过程中在没有任何警告的情况下行为异常。</p> <p><strong>智能指针和动态数组</strong></p> <p>​		<code>unique_ptr</code>可以直接管理动态数组，定义时需要在对象类型后添加一对空方括号<code>[]</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// up 指向一个包含 10 个未初始化int 的数组</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 自动用 delete[]销毁其指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		当一个<code>unique_ptr</code>指向一个数组时，我们不能使用点和箭头成员运算符。但是我们可以使用下标运算符来访问数组中的元素。</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>for (size_t i=0; i!=10; ++i)
	up[i] =i;//为每个元素赋予一个新值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持动态数组管理。如果想用<code>shared_ptr</code>管理动态数组，必须提供自定义的删除器。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 为了使用 shared_ptr，必须提供一个删除器</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用我们提供的lambda释放数组，它使用delete[]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		<code>shared_ptr</code>未定义下标运算符，智能指针类型也不支持指针算术运算。因此如果想访问<code>shared_ptr</code>管理的数组元素，必须先用<code>get</code>获取内置指针，再用内置指针进行访问。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// shared_ptr未定义下标运算符，并且不支持指针的算术运算</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token comment">// 使用 get 获取一个内置指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="allocator类"><a href="#allocator类" class="header-anchor">#</a> allocator类</h4> <p><strong>allocator类</strong></p> <p>​		<code>allocator</code>类是一个模板，定义时必须指定其可以分配的对象类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>allocator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> alloc<span class="token punctuation">;</span>    <span class="token comment">// 可以分配 string的allocator 对象</span>
<span class="token keyword">auto</span> <span class="token keyword">const</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配n个未初始化的 string</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>allocator 分配未构造的内存</strong></p> <p>​		<code>allocator</code>分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的<code>construct</code>函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>     <span class="token comment">// q指向最后构造的元素之后的位置</span>
alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// *q 为空字符串</span>
alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// *q 为 cccccccccc</span>
alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// *q 为 hi!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​		直接使用<code>allocator</code>返回的未构造内存是错误行为，其结果是未定义的。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 正确:使用 string 的输出运算符</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 灾难:q指向未构造的内存!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		对象使用完后，必须对每个构造的元素调用<code>destroy</code>进行销毁。<code>destroy</code>函数接受一个指针，对指向的对象执行析构函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 释放我们真正构造的 string</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		我们只能对真正构造了的元素进行 destroy 操作</p> <p>​		<code>deallocate</code>函数用于释放<code>allocator</code>分配的内存空间。传递给<code>deallocate</code>的指针不能为空，它必须指向由<code>allocator</code>分配的内存。而且传递给<code>deallocate</code>的大小参数必须与调用<code>allocator</code>分配内存时提供的大小参数相一致。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>拷贝和填充未初始化内存的算法</strong></p> <p>​		标准库还为 <code>allocator</code> 类定义了两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件<code>memory</code> 中。</p> <table><thead><tr><th>allocator算法</th> <th></th></tr></thead> <tbody><tr><td>uninitialized_copy(b,e,b2)</td> <td>从迭代器b和e指出的输入范围中拷贝元素到迭代器b2 指定的未构造的原始内存中。b2 指向的内存必须足够大，能容纳输入序列中元素的拷贝</td></tr> <tr><td>uninitialized_copy_n(b,n,b2)</td> <td>从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2开始的内存中</td></tr> <tr><td>uninitialized_fill(b,e,t)</td> <td>在迭代器 b和 e指定的原始内存范围中创建对象，对象的值均为 t的拷贝</td></tr> <tr><td>uninitialized_fill_n(b,n,t)</td> <td>从迭代器 b 指向的内存地址开始创建 n 个对象。b 必须指向足够大的未构造的原始内存，能够容纳给定数量的对象</td></tr></tbody></table> <p>​		作为一个例子，假定有一个 <code>int</code> 的 <code>vector</code>，希望将其内容拷贝到动态内存中。我们将分配一块比 <code>vector</code> 中元素所占用空间大一倍的动态内存，然后将原<code>vector</code> 中的元素拷贝到前一半空间，对后一半空间用一个给定值进行填充:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 分配比 vi 中元素所占用空间大一倍的动态内存</span>
<span class="token keyword">auto</span> p<span class="token operator">=</span>alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过拷贝 vi 中的元素来构造从 p开始的元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将剩余元素初始化为 42</span>
<span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，<span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#第八章-io库" class="sidebar-link reco-side-第八章-io库" data-v-b57cc07c>第八章 IO库</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_8-1-io类" class="sidebar-link reco-side-_8-1-io类" data-v-b57cc07c>8.1 IO类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_8-2-文件输入输出" class="sidebar-link reco-side-_8-2-文件输入输出" data-v-b57cc07c>8.2 文件输入输出</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_8-3string流" class="sidebar-link reco-side-_8-3string流" data-v-b57cc07c>8.3string流</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#第九章-顺序容器" class="sidebar-link reco-side-第九章-顺序容器" data-v-b57cc07c>第九章 顺序容器</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_9-1-顺序容器概述" class="sidebar-link reco-side-_9-1-顺序容器概述" data-v-b57cc07c>9.1 顺序容器概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_9-2-容器库概览" class="sidebar-link reco-side-_9-2-容器库概览" data-v-b57cc07c>9.2 容器库概览</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_9-3顺序容器操作" class="sidebar-link reco-side-_9-3顺序容器操作" data-v-b57cc07c>9.3顺序容器操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_9-4-vector对象是如何增长的" class="sidebar-link reco-side-_9-4-vector对象是如何增长的" data-v-b57cc07c>9.4 vector对象是如何增长的</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_9-5-额外的string操作" class="sidebar-link reco-side-_9-5-额外的string操作" data-v-b57cc07c>9.5 额外的string操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_9-6-容器适配器" class="sidebar-link reco-side-_9-6-容器适配器" data-v-b57cc07c>9.6 容器适配器</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#第十章-泛式算法" class="sidebar-link reco-side-第十章-泛式算法" data-v-b57cc07c>第十章 泛式算法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_10-1-概述" class="sidebar-link reco-side-_10-1-概述" data-v-b57cc07c>10.1 概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_10-2-初识泛型算法" class="sidebar-link reco-side-_10-2-初识泛型算法" data-v-b57cc07c>10.2 初识泛型算法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_10-3-定制操作" class="sidebar-link reco-side-_10-3-定制操作" data-v-b57cc07c>10.3 定制操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_10-4-再探迭代器" class="sidebar-link reco-side-_10-4-再探迭代器" data-v-b57cc07c>10.4 再探迭代器</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_10-5-范式算法" class="sidebar-link reco-side-_10-5-范式算法" data-v-b57cc07c>10.5 范式算法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_10-6-特定容器算法" class="sidebar-link reco-side-_10-6-特定容器算法" data-v-b57cc07c>10.6 特定容器算法</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#第十一章-关联容器" class="sidebar-link reco-side-第十一章-关联容器" data-v-b57cc07c>第十一章 关联容器</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_11-1-使用关联容器" class="sidebar-link reco-side-_11-1-使用关联容器" data-v-b57cc07c>11.1 使用关联容器</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_11-2-关联容器概述" class="sidebar-link reco-side-_11-2-关联容器概述" data-v-b57cc07c>11.2 关联容器概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_11-3-关联容器操作" class="sidebar-link reco-side-_11-3-关联容器操作" data-v-b57cc07c>11.3 关联容器操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_11-4-无序容器" class="sidebar-link reco-side-_11-4-无序容器" data-v-b57cc07c>11.4 无序容器</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#第十二章-动态内存" class="sidebar-link reco-side-第十二章-动态内存" data-v-b57cc07c>第十二章 动态内存</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_12-1-动态内存与智能指针" class="sidebar-link reco-side-_12-1-动态内存与智能指针" data-v-b57cc07c>12.1 动态内存与智能指针</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20Two.html#_12-2-动态数组" class="sidebar-link reco-side-_12-2-动态数组" data-v-b57cc07c>12.2 动态数组</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.c8e3a0f1.js" defer></script><script src="/assets/js/3.1f40c1f2.js" defer></script><script src="/assets/js/1.fd77260d.js" defer></script><script src="/assets/js/14.645c3afc.js" defer></script>
  </body>
</html>
