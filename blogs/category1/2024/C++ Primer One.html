<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ Primer 第一部分 | blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="陌小阳的博客">
    <meta name="description" content="this is my blog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.47a191c6.css" as="style"><link rel="preload" href="/assets/js/app.c8e3a0f1.js" as="script"><link rel="preload" href="/assets/js/3.1f40c1f2.js" as="script"><link rel="preload" href="/assets/js/1.fd77260d.js" as="script"><link rel="preload" href="/assets/js/13.93844b51.js" as="script"><link rel="prefetch" href="/assets/js/10.27468c1b.js"><link rel="prefetch" href="/assets/js/11.02b03c80.js"><link rel="prefetch" href="/assets/js/12.15f74c8b.js"><link rel="prefetch" href="/assets/js/14.645c3afc.js"><link rel="prefetch" href="/assets/js/15.54763910.js"><link rel="prefetch" href="/assets/js/16.7ce4fb83.js"><link rel="prefetch" href="/assets/js/17.2a6c8b67.js"><link rel="prefetch" href="/assets/js/18.5af2a41f.js"><link rel="prefetch" href="/assets/js/19.8a6002cd.js"><link rel="prefetch" href="/assets/js/20.13402627.js"><link rel="prefetch" href="/assets/js/21.72517caa.js"><link rel="prefetch" href="/assets/js/22.b9eb4d25.js"><link rel="prefetch" href="/assets/js/4.51d906d3.js"><link rel="prefetch" href="/assets/js/5.2b3573cc.js"><link rel="prefetch" href="/assets/js/6.b8c0fc1c.js"><link rel="prefetch" href="/assets/js/7.d62414bd.js"><link rel="prefetch" href="/assets/js/8.69f56ef7.js"><link rel="prefetch" href="/assets/js/9.d4a50642.js">
    <link rel="stylesheet" href="/assets/css/0.styles.47a191c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>blog</h3> <p class="description" data-v-59e6cb88>this is my blog</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>mo_xiao_yang</span>
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/C++/" class="nav-link"><i class="undefined"></i>
  C++
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  else
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Computer Fundamentals/" class="nav-link"><i class="undefined"></i>
  Computer Fundamentals
</a></li><li class="dropdown-item"><!----> <a href="/categories/CMake/" class="nav-link"><i class="undefined"></i>
  CMake
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun/md_notebook" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  md文档仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/pikaqiu.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    mo_xiao_yang
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>12</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>5</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/C++/" class="nav-link"><i class="undefined"></i>
  C++
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  else
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Computer Fundamentals/" class="nav-link"><i class="undefined"></i>
  Computer Fundamentals
</a></li><li class="dropdown-item"><!----> <a href="/categories/CMake/" class="nav-link"><i class="undefined"></i>
  CMake
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun/md_notebook" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  md文档仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>C++ Primer 第一部分</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>mo_xiao_yang</span>
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">C++ Primer 第一部分</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>mo_xiao_yang</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>4/8/2024</span></i> <i class="iconfont reco-eye" data-v-8a445198><span id="/blogs/category1/2024/C++%20Primer%20One.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-8a445198><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>C++</span></i></div></div> <div class="theme-reco-content content__default"><div class="custom-block tip"><p class="title"></p><p>该笔记是C++ Primer 第一部分，笔记参考了https://github.com/czs108/C++-Primer-5th-Notes-CN/</p></div><h1 id="c-primer-one"><a href="#c-primer-one" class="header-anchor">#</a> C++ Primer One</h1> <h2 id="第一章-开始"><a href="#第一章-开始" class="header-anchor">#</a> 第一章 开始</h2> <h3 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="header-anchor">#</a> 读取数量不定的输入数据</h3> <p>可以使用<code>while</code>循环以及if判断来实现</p> <div class="language-Cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    Sales_item total<span class="token punctuation">;</span> <span class="token comment">// variable to hold data for the next transaction</span>

    <span class="token comment">// read the first transaction and ensure that there are data to process</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> total<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		Sales_item trans<span class="token punctuation">;</span> <span class="token comment">// variable to hold the running sum</span>
        <span class="token comment">// read and process the remaining transactions</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> trans<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// if we're still processing the same book</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> trans<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
                total <span class="token operator">+=</span> trans<span class="token punctuation">;</span> <span class="token comment">// update the running total </span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>              
		        <span class="token comment">// print results for the previous book </span>
                std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  
                total <span class="token operator">=</span> trans<span class="token punctuation">;</span>  <span class="token comment">// total now refers to the next book</span>
            <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// print the last transaction</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// no input! warn the user</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;No data?!&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// indicate failure</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="缓冲区"><a href="#缓冲区" class="header-anchor">#</a> 缓冲区</h3> <p><a href="https://zhuanlan.zhihu.com/p/149256595" target="_blank" rel="noopener noreferrer">一文带你读懂C/C++语言输入输出流与缓存区 - 知乎 (zhihu.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>如果程序崩溃时 ，输出缓冲区不会被刷新</p> <h3 id="术语"><a href="#术语" class="header-anchor">#</a> 术语</h3> <p>cerr：一个<code>ostream</code>对象，通常输出错误信息的时候用的是<code>cerr</code>而不是<code>cout</code>，不用经过缓冲区</p> <p>clog：一个<code>ostream</code>对象，和<code>cerr</code>相同，同为错误的输出流，但是这个会经过缓冲区</p> <h3 id="区分「类」「类型」「类型类」「类类型」"><a href="#区分「类」「类型」「类型类」「类类型」" class="header-anchor">#</a> 区分「类」「类型」「类型类」「类类型」</h3> <h2 id="第二章-变量和基础类型"><a href="#第二章-变量和基础类型" class="header-anchor">#</a> 第二章 变量和基础类型</h2> <h3 id="_2-1基本内置类型"><a href="#_2-1基本内置类型" class="header-anchor">#</a> 2.1基本内置类型</h3> <p>​	整型用<code>int</code>, 不够直接用<code>long long</code>，因为一般将<code>int</code>和<code>long</code>类型看作是一样的大小</p> <p>​	<code>char</code>只用于存放单个字符, 它存整数有一个风险, 不同机器A对<code>char</code>归类<code>signed</code>和<code>unsigned</code>不一致, 在A机器上char(用<code>unsigned</code>诠释) <code>smallNum=200</code>可以过, 在B机器上(用<code>signed</code>诠释)就会溢出</p> <p>​	浮点数一律用<code>double</code></p> <h4 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="header-anchor">#</a> 带符号类型和无符号类型</h4> <p>​	除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的 (<code>signed</code>) 和无符号的(<code>unsigned</code>)两种。带符号类型可以表示正数、负数或 0，无符号类型则仅能表示大于等于0的值。
类型 <code>int</code>、<code>short</code>、<code>long</code> 和 <code>long long</code> 都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long。类型<code>unsigned int</code> 可以缩写为<code>unsigned</code>。</p> <h4 id="转义字符"><a href="#转义字符" class="header-anchor">#</a> 转义字符</h4> <p><img src="https://raw.githubusercontent.com/moyangsun/ty_assist/main/img/MatLab202401241608298.png" alt="image-20240124160823900"></p> <h3 id="_2-2变量"><a href="#_2-2变量" class="header-anchor">#</a> 2.2变量</h3> <h4 id="初始值-初始化"><a href="#初始值-初始化" class="header-anchor">#</a> 初始值&amp;初始化</h4> <p>https://zh.C++reference.com/w/C++/language/list_initialization</p> <p>初始化不是赋值，初始化的会义是创建变量时赋予其一个初始值，而赋值的会义是把对象的当前值擦除，而以一个新值来替代。</p> <h4 id="列表初始化"><a href="#列表初始化" class="header-anchor">#</a> 列表初始化</h4> <p>可以简单的理解为带有花括号的赋值如定一个名为a的int变量并初始化为0</p> <div class="language-Cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> a <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该方法使得初始化更加安全[避免了类型转换的精度损失的危险]</p> <h4 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="header-anchor">#</a> 变量声明和定义的关系</h4> <p>​	为了支持分离式编译，C++语言将声明和定义区分开来。声明(<code>declaration</code>)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(<code>definition</code>)负责创建与名字关联的实体。</p> <p>​	如果想声明一个变量而非定义它，就在变量名前添加关键字<code>extern</code>，而且不要显式地初始化变量:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//声明i而非定义i</span>
<span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token comment">//声明并定义了</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>任何包含了显式初始化的声明即成为定义。我们能给由<code>extern</code>关键字标记的变量赋一个初始值，但是这么做也就抵消了<code>extern</code> 的作用。<code>extern</code> 语句如果包含初始值就不再是声明，而变成定义了:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.1416</span><span class="token punctuation">;</span><span class="token comment">//定义</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_2-3复合类型"><a href="#_2-3复合类型" class="header-anchor">#</a> 2.3复合类型</h3> <h4 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h4> <p><a href="https://blog.csdn.net/xiao__tian__/article/details/51814617" target="_blank" rel="noopener noreferrer">C++之引用的详解_C++引用-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>​	一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定(bind)**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>引用类型初始值必须是一个对象，且该对象的类型要和引用严格匹配以下定义方法是错误的</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//错误</span>

<span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//错误</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="指针"><a href="#指针" class="header-anchor">#</a> 指针</h4> <p>​	**指针(pointer)**是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p> <p>​	指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符&amp;):</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span> <span class="token comment">//p存放变量ival的地址，或者说p是指向变量ival的指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	第二条语句把p定义为一个指向 <code>int</code> 的指针，随后初始化p令其指向名为 ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p> <h4 id="利用指针访问对象"><a href="#利用指针访问对象" class="header-anchor">#</a> 利用指针访问对象</h4> <p>如果指针指向了一个对象，则允许使用解引用符(操作符*)来访问该对象:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span> <span class="token comment">// p存放着变量ival的地址，或者说p是指向变量ival的指针</span>
cout <span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">// 由符号*得到指针p所指的对象，输出42</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//由符号*得到指针p所指的对象，即可经由p为变量ival赋值</span>
cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//输出0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如上述程序所示，为<code>*p</code> 赋值实际上是为p所指的对象赋值</p> <h4 id="空指针"><a href="#空指针" class="header-anchor">#</a> 空指针</h4> <p>生成空指针的方法</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span>pl<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//等价于int*p1=0;</span>
<span class="token keyword">int</span><span class="token operator">*</span>p2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 直接将p2初始化为字面常量 0</span>
<span class="token comment">// 需要首先#include cstdlib</span>
<span class="token keyword">int</span><span class="token operator">*</span>p3<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//等价于int*p3=0;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>把int 变量直接赋给指针是错误的操作，即使int变量的值恰好等于也不行。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> zero<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
pi<span class="token operator">=</span>zero<span class="token punctuation">;</span><span class="token comment">//错误:不能把int 变量直接赋给指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="赋值和指针"><a href="#赋值和指针" class="header-anchor">#</a> 赋值和指针</h4> <p>​	指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。</p> <p>​	有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>pi<span class="token operator">=</span><span class="token operator">&amp;</span>ival<span class="token punctuation">;</span><span class="token comment">//pi的值被改变，现在 pi 指向了ival</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	意思是为 <code>pi</code> 赋一个新的值，也就是改变了那个存放在 <code>pi</code> 内的地址值。相反的，如果写出如下语句，</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//ival的值被改变，指针pi并没有改变</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	则<code>*pi</code>(也就是指针<code>pi</code> 指向的那个对象)发生改变</p> <h4 id="void-指针"><a href="#void-指针" class="header-anchor">#</a> void* 指针</h4> <p>​	<code>void*</code> 是一种特殊的指针类型，可用于存放任意对象的地址。一个<code>void*</code> 指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">double</span> obj<span class="token operator">=</span><span class="token number">3.14</span>，<span class="token operator">*</span>pd<span class="token operator">=</span><span class="token operator">&amp;</span>obj<span class="token punctuation">;</span><span class="token comment">//正确:void*能存放任意类型对象的地址</span>
<span class="token keyword">void</span><span class="token operator">*</span>pv<span class="token operator">=</span><span class="token operator">&amp;</span>obj<span class="token punctuation">;</span>			<span class="token comment">//obi可以是任意类型的对象</span>
pv<span class="token operator">=</span>pd<span class="token punctuation">;</span>				   <span class="token comment">//pv可以存放任意类型的指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	利用 <code>void*</code> 指针能做的事儿比较有限:拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 <code>void*</code> 指针。不能直接操作 <code>void*</code>指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p> <h4 id="指向指针的指针"><a href="#指向指针的指针" class="header-anchor">#</a> 指向指针的指针</h4> <p>​	通过 <code>*</code> 的个数可以区分指针的级别。也就是说，<code>* *</code> 表示指向指针的指针，<code>* * *</code> 表示指向指针的指针的指针，以此类推:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span><span class="token comment">// pi指向一个int型的数</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ppi <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">//ppi指向一个int型的指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	此处<code>pi</code> 是指向 <code>int</code> 型数的指针，而 <code>ppi</code> 是指向 <code>nt</code> 型指针的指针，下图描述了它们之、间的关系。</p> <p><img src="https://raw.githubusercontent.com/moyangsun/ty_assist/main/img/MatLab202401242113798.png" alt="image-20240124211311768"></p> <h4 id="指向指针的引用"><a href="#指向指针的引用" class="header-anchor">#</a> 指向指针的引用</h4> <p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对
指针的引用:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>        <span class="token comment">//p是一个int型指针</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r<span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token comment">//r是一个对指针p的引用</span>
r <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>        <span class="token comment">//r引用了一个指针，因此给r赋值&amp;i就是令p指向 i</span>
<span class="token operator">*</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_2-4const限定符"><a href="#_2-4const限定符" class="header-anchor">#</a> 2.4const限定符</h3> <p><code>const</code>限定符修饰的常量可以在编译时初始化也可以在运行时初始化</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> get <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确:运行时初始化</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//正确:编译时初始化</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span><span class="token comment">// 错误:k是一个未经初始化的常量</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="默认状态下-const对象仅在文件内有效"><a href="#默认状态下-const对象仅在文件内有效" class="header-anchor">#</a> 默认状态下，const对象仅在文件内有效</h4> <p>​	默认情况下，<code>const</code> 对象被设定为仅在文件内有效。当多个文件中出现了同名的 <code>const</code> 变量时，其实等同于在不同文件中分别定义了独立的变量。</p> <p>​	若是希望被<code>const</code>对象在多个文件中声明并使用它，解决的办法就是，对于<code>const</code>变量不管是声明还是定义都添加<code>extern</code>关键字，这样只需要定义一次<code>const</code>变量即可</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// file 1.cc定义并初始化了一个常量，该常量能被其他文件访问</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufSize <span class="token operator">=</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//filel.h头文件</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufSize<span class="token punctuation">;</span><span class="token comment">//与file 1.cc中定义的bufSize是同一个</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="cosnt引用"><a href="#cosnt引用" class="header-anchor">#</a> cosnt引用</h4> <p>​	可以把引用绑定到 <code>const</code> 对象上，就像绑定到其他对象上一样，我们称之为<strong>对常量的引用(reference toconst)</strong>。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>rl <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">//正确:引用及其对应的对象都是常量</span>
r1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//错误:r是对常量的引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment">// 错误:试图让一个非常量引用指向一个常量对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	可以把对<code>const</code>的引用简称为常量引用，尽管这种说法并不正确。因为引用不是一个对象，所以我们没法让引用本身恒定不变。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。</p> <h5 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="header-anchor">#</a> 初始化和对const的引用</h5> <p>​	在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//允许将const int&amp;绑定到一个普通int 对象上</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//正确:r1是一个常量引用</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> rl <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 正确:r3是一个常量引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r4 <span class="token operator">=</span> rl <span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//错误:r4是一个普通的非常量引用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	一般情况下，引用类型必须与其所引用对象的类型保持一致，但是对<code>const</code>的引用是一个例外。下列将展示一个常量引用绑定到另一个类型上面会发生什么</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">double</span> dval<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>ri <span class="token operator">=</span>dval<span class="token punctuation">;</span>
<span class="token comment">//在编译器中会把上述的代码转换为</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> temp <span class="token operator">=</span> dval<span class="token punctuation">;</span><span class="token comment">//由双精度浮点数生成一个临时的整型常量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>ri <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment">//让ri绑定这个临时量</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	在这种情况下，<code>ri</code>绑定了一个**临时量 (temporary)**对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。</p> <h5 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="header-anchor">#</a> 对const的引用可能引用一个并非const的对象</h5> <p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>rl <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//引用ri绑定对象i</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2<span class="token comment">//r2也绑定对象i，但是不允许通过 r2修改i的值</span>
r1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//r1并非常量，i的值修改为0</span>
r2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//错误:r2是一个常量引用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="指针和const"><a href="#指针和const" class="header-anchor">#</a> 指针和const</h4> <p>​	指向常量的指针不能用于改变其所指对象的值。要想存放常量的地址，只能使用指向常量的指针：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token comment">// pi 是个常量，它的值不能改变</span>
<span class="token keyword">double</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">//错误:ptr 是一个普通指针</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">//正确:cptr 可以指向一个双精度常量</span>
<span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//错误:不能给*cptr赋值</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">double</span> dval <span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token comment">// dval是一个双精度浮点数，它的值可以改变</span>
cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span><span class="token comment">//正确:但是不能通过 cptr 改变 dval的值</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</p> <p>​	<strong>可以简单的理解引用和指针在被<code>const</code>修饰的时候，两者都觉得指向了常量，所以自觉地不去改变所指对象的值。</strong></p> <h5 id="const指针"><a href="#const指针" class="header-anchor">#</a> const指针</h5> <p>​	<strong>常量指针</strong>必须初始化，而且一旦初始化成功，则它的值（也就是存放在指针中的那个地址）就是不再改变了。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> errNumb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> curErr <span class="token operator">=</span> <span class="token operator">&amp;</span>errNumb<span class="token punctuation">;</span><span class="token comment">//curErr将一直指向errNumb</span>

<span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token keyword">const</span> pip <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">// pip 是一个指向常量对象的常量指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	上下两种的区别是，上面那个可以改变存在该地址中的值，但是能改变地址；下面那个是既不能改变地址中的值也不能改变地址。</p> <h4 id="顶层const"><a href="#顶层const" class="header-anchor">#</a> 顶层const</h4> <p>​	顶层<code>const</code>表示指针本身是个常量，底层表示指针所指觉得对象是一个常量。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> pl <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//不能改变pl的值，这是一个顶层const</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//不能改变ci的值，这是一个顶层const</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span><span class="token comment">//允许改变p2的值，这是一个底层const</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> p2<span class="token punctuation">;</span><span class="token comment">// 靠右的const是顶层const，靠左的是底层const</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment">//用于声明引用的const都是底层const</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	当执行对象的拷贝操作时，常量是顶层 <code>const</code> 还是底层 <code>const</code> 区别明显。其中，顶层<code>const</code> 不受什么影响:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>i <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment">//正确:拷贝ci的值，ci是一个顶层const，对此操作无影响</span>
p2 <span class="token operator">=</span> P3<span class="token punctuation">;</span><span class="token comment">//正确:p2和p3指向的对象类型相同，p3 顶层const 的部分不影响</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	另一方面，底层 <code>const</code> 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 <code>const</code> 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span>p <span class="token operator">=</span> p3<span class="token punctuation">;</span><span class="token comment">//错误:p3包含底层const 的定义，而p没有</span>
p2 <span class="token operator">=</span> p3<span class="token punctuation">;</span><span class="token comment">//正确:p2和p3都是底层const</span>
p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//正确:int*能转换成const int*</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment">//错误:普通的 int&amp;不能绑定到 int 常量上</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//正确:const int&amp;可以绑定到一个普通int 上</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="header-anchor">#</a> constexpr和常量表达式</h4> <p>​	常量表达式是指值不会改变并且在编译阶段就能得到计算结果的表达式。</p> <p><a href="https://blog.csdn.net/wzz953200463/article/details/116176071" target="_blank" rel="noopener noreferrer">C++11 constexpr和const的区别详解_在C++ 98/03标准中，只存在 const 关键字，并且其在实际使用中经常会表现出两种不同的语义-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h5 id="constexpr变量"><a href="#constexpr变量" class="header-anchor">#</a> constexpr变量</h5> <p>​	C++11新标准规定，允许将变量声明为 <code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 <code>constexpr</code> 的变量一定是一个常量，而且必须用常量表达式初始化：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> mf<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">// 20是常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> limit <span class="token operator">=</span>mf <span class="token operator">+</span> l<span class="token punctuation">;</span><span class="token comment">//mf +1是常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有当 size是一个constexpr函数时</span>
						<span class="token comment">// 才是一条正确的声明语句</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	一般来说，如果你认定变量是一个常量表达式，那就把它声明成<code>constexpr</code>类型</p> <h5 id="字面值类型"><a href="#字面值类型" class="header-anchor">#</a> 字面值类型</h5> <p>​	常量表达式的值需要在编译时就得到计算，因此对声明constexpr 时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为**“字面值类型”(literaltype)**。</p> <p>​	数据类型中，算术类型、引用和指针都是属于字面值类型。尽管指针和引用都能定义成 <code>constexpr</code>，但它们的初始值却受到严格限制。一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者0或者是存储于某个固定地址中的对象</p> <h5 id="指针和constexpr"><a href="#指针和constexpr" class="header-anchor">#</a> 指针和constexpr</h5> <p>​	必须明确一点，在<code>constexpr</code>声明中如果定义了一个指针，限定符 <code>constexpr</code>仅对指针有效，与指针所指的对象无关:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//P是一个指向整型常量的指针</span>
<span class="token keyword">const</span> exprint <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//q是一个指向整数的常量指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	<code>p</code> 和<code>q</code>的类型相差甚远，<code>p</code> 是一个指向常量的指针，而q 是一个常量指针，其中的关键在于<code>constexpr</code> 把它所定义的对象置为了顶层<code>const</code>。</p> <p>与其他常量指针类似，<code>constexpr</code> 指针既可以指向常量也可以指向一个非常量：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>np<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// np是一个指向整数的常量指针，其值为空</span>
<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> i<span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">// i的类型是整型常量</span>
<span class="token comment">// i和都必须定义在函数体之外</span>
<span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//p是常量指针，指向整型常量i</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>pl <span class="token operator">=</span> <span class="token operator">&amp;</span>j<span class="token punctuation">;</span><span class="token comment">//p1是常量指针，指向整数 i</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_2-5处理类型"><a href="#_2-5处理类型" class="header-anchor">#</a> 2.5处理类型</h3> <h4 id="类型别名"><a href="#类型别名" class="header-anchor">#</a> 类型别名</h4> <p>​	<strong>类型别名</strong>是一个名字，它是某种类型的同义词。</p> <p>​	有两种方法可以用于定义类型别名。第一种是传统方法使用关键字**<code>typedef</code>**</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">double</span> wages<span class="token punctuation">;</span><span class="token comment">//wages是double的同义词</span>
<span class="token keyword">typedef</span> wages base，<span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//base是double的同义词，p是double*的同义词</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	第二种是新标准规定的一种新的方法，使用<strong>别名声明</strong>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">using</span> SI <span class="token operator">=</span> Sales_item<span class="token punctuation">;</span> <span class="token comment">//SI是Sales_item的同义词</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="header-anchor">#</a> 指针、常量和类型别名</h5> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>pstring<span class="token punctuation">;</span>
<span class="token keyword">const</span> pstring <span class="token operator">*</span>ps<span class="token punctuation">;</span><span class="token comment">// cstr是指向char的常量指针</span>
<span class="token keyword">const</span> pstringcstr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ps 是一个指针，它的对象是指向 char的常量指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> chat <span class="token operator">*</span>cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//是对const pstring cstr的错误理解</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	前后两种声明含义截然不同，前者声明了一个指向 <code>char</code>的常量指针,改写后的形式则声明了一个指向<code>const char</code> 的指针。</p> <h4 id="auto类型说明符"><a href="#auto类型说明符" class="header-anchor">#</a> auto类型说明符</h4> <p>​	C++11 新标准引入了**<code>auto</code>**类型说明符，用它就能让编译器替我们去分析表达式所属的型。和原来那些只对应一种特定类型的说明符 (比如 <code>double</code>) 不同，<code>auto</code> 让编译器过初始值来推算变量的类型。显然，<code>auto</code>定义的变量必须有初始值:</p> <p>​	使用<code>auto</code>也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span>，<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//正确:i是整数、P 是整型指针</span>
<span class="token keyword">auto</span> sz<span class="token operator">=</span><span class="token number">0</span>，pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// 错误:sz和pi的类型不一致</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="header-anchor">#</a> decltype类型指示符</h4> <p>C++11新增<code>decltype</code>类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// sum has whatever type f returns</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>有些不同，如果<code>decltype</code>使用的表达式是一个变量，则<code>decltype</code>返回该变量的类型（包括顶层<code>const</code>和引用）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cj <span class="token operator">=</span> ci<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// x has type const int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token comment">// y has type const int&amp; and is bound to x</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> z<span class="token punctuation">;</span>     <span class="token comment">// error: z is a reference and must be initialized</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果<code>decltype</code>使用的表达式不是一个变量，则<code>decltype</code>返回表达式结果对应的类型。如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则<code>decltype</code>会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。</p> <p><code>decltype((var))</code>的结果永远是引用，而<code>decltype(var)</code>的结果只有当<code>var</code>本身是一个引用时才会是引用。</p> <h4 id="自定义数据结构"><a href="#自定义数据结构" class="header-anchor">#</a> 自定义数据结构</h4> <p>C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p> <p>类内初始值不能使用圆括号。</p> <p>类定义的最后应该加上分号。</p> <p>头文件（header file）通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量。</p> <p>头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。</p> <p>头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。<code>##define</code>指令把一个名字设定为预处理变量。<code>##ifdef</code>指令当且仅当变量已定义时为真，<code>##ifnde</code>f指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到<code>##endif</code>指令为止。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>##ifndef SALES_DATA_H
##define SALES_DATA_H
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
##endif
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在高级版本的IDE环境中，可以直接使用<code>##pragma once</code>命令来防止头文件的重复包含。</p> <p>预处理变量无视C++语言中关于作用域的规则。</p> <p>整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。</p> <p>头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。</p> <h3 id="_2-6自定义数据结构"><a href="#_2-6自定义数据结构" class="header-anchor">#</a> 2.6自定义数据结构</h3> <h4 id="编写头文件"><a href="#编写头文件" class="header-anchor">#</a> 编写头文件</h4> <h5 id="预处理器概述"><a href="#预处理器概述" class="header-anchor">#</a> 预处理器概述</h5> <p>​	C++程序还会用到的一项预处理功能是头文件保护符(header guard)，头文件保护符依赖于预处理变量。预处理变量有两种状态:已定义和未定义。<code>##define</code> 指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:<code>##ifdef</code> 当且仅当变量已定义时为真，<code>##ifndef</code> 当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到<code>##endif</code> 指令为止。</p> <p>使用这些功能就能有效地防止重复包含的发生:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>##ifndef SALES_DATA_H
##define SALES_DATA_H
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">Sales</span> data<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>；
##endif
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	第一次包含 <code>Sales data.h</code> 时，<code>##ifndef</code> 的检查结果为真，预处理器将顺序执行后面的操作直至遇到<code>##endif</code> 为止。此时，预处理变量 <code>SALES DATA H</code> 的值将变为已定义，而日<code>sales data.h</code>也会被拷贝到我们的程序中来。后面如果再一次包含<code>Sales data.h</code>,则<code>##ifnde</code>f的检查结果将为假，编译器将忽略<code>##ifndef</code>到<code>##endif</code>之间的部分。</p> <h2 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="header-anchor">#</a> 第三章 字符串、向量和数组</h2> <p>​	<code>string</code>表示可变长的字符序列，<code>vector</code>存放的是某种给定的类型对象的可变长序列。</p> <p>​	定长字符串</p> <ol><li><p>有固定的极大长度</p></li> <li><p>不管是否达到了这个极大值都使用同样的数量的内存</p></li></ol> <p>​	变长字符串</p> <ol><li>它的长度不是专断固定的</li> <li>依赖于实际的大小使用可变的数量的内存</li></ol> <h3 id="_3-1-命名空间的using声明"><a href="#_3-1-命名空间的using声明" class="header-anchor">#</a> 3.1 命名空间的using声明</h3> <p>​	有了<code>using</code>声明就无须专门的前缀（形如命名空间 <code>: :</code> ）也能使用岁序的名字了。<code>using</code>声明具有如下的形式：</p> <p><code>using namespace::name;</code></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">// using 声明，当我们使用名宇 cin 时，从命名空间 std 中获取它</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span>i<span class="token punctuation">;</span> <span class="token comment">// 正确:cin和std::cin 含义相同</span>
    cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token comment">//错误:没有对应的 using 声明，必须使用完整的名字</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token comment">// 正确:显式地从 std中使用 cout</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>程序中使用的每个名字都需要用独立的<code>using</code>声明引入。</p> <p>头文件中通常不应该包含<code>using</code>声明。</p> <h3 id="_3-2-标准库类型string"><a href="#_3-2-标准库类型string" class="header-anchor">#</a> 3.2 标准库类型string</h3> <h4 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="header-anchor">#</a> 定义和初始化string对象</h4> <p>初始化<code>string</code>的方式：</p> <table><thead><tr><th style="text-align:center;">方式</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;"><code>string s1</code></td> <td style="text-align:center;"><code>s1</code>被默认初始化为空串</td></tr> <tr><td style="text-align:center;"><code>string s2(s1)</code><br><code>string s2 = s1</code></td> <td style="text-align:center;"><code>s2</code>是<code>s1</code>的拷贝</td></tr> <tr><td style="text-align:center;"><code>string s3(&quot;val&quot;)</code><br><code>string s3 = &quot;val&quot;</code></td> <td style="text-align:center;"><code>s3</code>是<code>&quot;value&quot;</code>的拷贝</td></tr> <tr><td style="text-align:center;"><code>string s4(n, 'c')</code></td> <td style="text-align:center;"><code>s4</code>被初始化为连续<code>n</code>个字符<code>c</code>组成的串</td></tr></tbody></table> <p>​	如果使用等号初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化（direct initialization）。</p> <h4 id="string对象上的操作"><a href="#string对象上的操作" class="header-anchor">#</a> string对象上的操作</h4> <table><thead><tr><th style="text-align:center;">操作</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;"><code>os &lt;&lt; s</code></td> <td style="text-align:center;">将<code>s</code>写入输出流<code>os</code>，返回<code>os</code></td></tr> <tr><td style="text-align:center;"><code>is &gt;&gt; s</code></td> <td style="text-align:center;">从输入流<code>is</code>读取字符串至<code>s</code>，字符串以空白分隔，返回<code>is</code></td></tr> <tr><td style="text-align:center;"><code>getline(is, s)</code></td> <td style="text-align:center;">从输入流<code>is</code>读取一行至<code>s</code>，返回<code>is</code></td></tr> <tr><td style="text-align:center;"><code>s.empty()</code></td> <td style="text-align:center;"><code>s</code>为空则返回<code>true</code></td></tr> <tr><td style="text-align:center;"><code>s.size()</code></td> <td style="text-align:center;">返回<code>s</code>中的字符个数</td></tr> <tr><td style="text-align:center;"><code>s[n]</code></td> <td style="text-align:center;">返回<code>s</code>中第<code>n</code>个字符的引用</td></tr> <tr><td style="text-align:center;"><code>s1 + s2</code></td> <td style="text-align:center;">返回<code>s1</code>和<code>s2</code>拼接后的串</td></tr> <tr><td style="text-align:center;"><code>s1 = s2</code></td> <td style="text-align:center;">将<code>s2</code>赋值给<code>s1</code></td></tr> <tr><td style="text-align:center;"><code>s1 == s2</code><br><code>s1 != s2</code></td> <td style="text-align:center;">判断<code>s1</code>和<code>s2</code>中的字符是否完全一样</td></tr> <tr><td style="text-align:center;"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td> <td style="text-align:center;">以字典顺序比较<code>s1</code>和<code>s2</code></td></tr></tbody></table> <ol><li>在执行读取操作时，<code>string</code>对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读取，直到遇见下一处空白为止。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string word<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span><span class="token comment">// 反复读取，直至到达文件末尾</span>
    	cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 逐个输出单词，每个单词后面紧跟一个换行</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//读单词</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li>使用<code>getline</code>函数可以读取一整行字符。该函数只要遇到换行符就结束读取并返回结果，如果输入的开始就是一个换行符，则得到空<code>string</code>。触发<code>getline</code>函数返回的那个换行符实际上被丢弃掉了，得到的<code>string</code>对象中并不包含该换行符。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string line<span class="token punctuation">;</span>
    <span class="token comment">// 每次读入一整行，直至到达文件末尾</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>
    	cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//读句子</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>string的empty和size操作</strong></p> <ol><li><p><code>empty</code>用来判断<code>string</code>是否为空</p></li> <li><p><code>size</code>用来判断<code>string</code>的大小</p></li></ol> <p>​	<code>size</code>函数返回<code>string</code>对象的长度，返回值是<code>string::size_type</code>类型，这是一种无符号类型。要使用<code>size_type</code>，必须先指定它是由哪种类型定义的。</p> <p>​	如果一个表达式中已经有了<code>size（）</code>函数就不要再使用int了，这样可以避免混用<code>int</code>和<code>unsigned int</code>可能带来的问题。</p> <p><strong>string::size_type类型</strong></p> <p>​	<code>size_type</code>体现了标准库类型与机器无关的特性。这是一种无符号数，所以要避免和有符号数一起出现在表达式中，这样往往会出现一些问题。例如：假设n是一个有符号位的负数，那么表达式<code>s.size()&lt;n</code>几乎都是<code>true</code>。因为一个有符号位的复数转化为无符号位的数时，会转为为一个比较大的无符号值。</p> <p><strong>比较string对象</strong></p> <p>​	两个<code>string</code>对象进行比较，两种情况：</p> <ol><li><p>两个<code>string</code>对象一长一短，且较短string对象的每个字符都与较长对象对应位置上的值相同。则较长对象大于较短对象。</p></li> <li><p>两个<code>string</code>对象对应位置不同，则从前往后进行比较。比较第一个有差异的字母，根据字典集进行更改。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string s1 <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
string s2 <span class="token operator">=</span> <span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">;</span>
string s3 <span class="token operator">=</span> <span class="token string">&quot;Hiya&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//s1 &lt; s2</span>
<span class="token comment">//s1 &lt; s3</span>
<span class="token comment">//s2 &lt; s3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>字面值和string对象相加</strong></p> <p>​	首先要注意的是，字符字面值、字符串面值和<code>string</code>是三个东西，但是字符字面值和字符串面值可以转换为<code>string</code>类型</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string s1 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
string s2 <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
string s3 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">;</span><span class="token comment">//错误 两个字符串不能直接相加赋值给string</span>
string s4 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token operator">+</span><span class="token string">&quot;,&quot;</span><span class="token operator">+</span>s2<span class="token punctuation">;</span><span class="token comment">//错误 错误原因和上面的相同</span>
string s5 <span class="token operator">=</span> s1<span class="token operator">+</span><span class="token string">&quot;,&quot;</span><span class="token operator">+</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span><span class="token comment">//正确</span>
<span class="token comment">//可以将其视为(s1+&quot;,&quot;)+&quot;world&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ol> <h4 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="header-anchor">#</a> 处理string对象中的字符</h4> <p>头文件<code>cctype</code>中的字符操作函数：</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>isalnum(c)</code></td> <td><code>c</code>是字母或数字时返回<code>true</code></td></tr> <tr><td><code>isalpha(c)</code></td> <td><code>c</code>是字母时返回<code>true</code></td></tr> <tr><td><code>iscntrl(c)</code></td> <td><code>c</code>是控制字符时返回<code>true</code></td></tr> <tr><td><code>isdigit(c)</code></td> <td><code>c</code>是数字时返回<code>true</code></td></tr> <tr><td><code>isgraph(c)</code></td> <td><code>c</code>不是空格但可打印时返回<code>true</code></td></tr> <tr><td><code>islower(c)</code></td> <td><code>c</code>是小写字母时返回<code>true</code></td></tr> <tr><td><code>isprint(c)</code></td> <td><code>c</code>是可打印字符时返回<code>true</code></td></tr> <tr><td><code>ispunct(c)</code></td> <td><code>c</code>是标点符号时返回<code>true</code></td></tr> <tr><td><code>isspace(c)</code></td> <td><code>c</code>是空白时返回<code>true</code></td></tr> <tr><td><code>isupper(c)</code></td> <td><code>c</code>是大写字母时返回<code>true</code></td></tr> <tr><td><code>isxdigit(c)</code></td> <td><code>c</code>是十六进制数字时返回<code>true</code></td></tr> <tr><td><code>tolower(c)</code></td> <td>将<code>c</code>转变为小写字母或原样返回</td></tr> <tr><td><code>toupper(c)</code></td> <td>将<code>c</code>转变为大写字母或原样返回</td></tr></tbody></table> <p>注意：由于C++兼容了c的标准库。c标准库中的<code>name.h</code>，在C++中为<code>cname</code>，如c中的<code>ctype.h</code>在C++中为<code>cctype</code>内容是一样的，但是在使用的过程中，建议使用风格一致。这样可以避免程序员混淆继承关系。</p> <p><strong>处理每个字符，基于for语句</strong></p> <p>在C++11中规定了一种新的<code>for</code>使用方法</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span>
    statement

string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">&quot;some string&quot;</span><span class="token punctuation">)</span>
<span class="token comment">//每行输出str中的一个字符</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> str<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>使用范围for语句改变字符串中的字符</strong></p> <p>​	若是要改变<code>string</code>对象中的值，必须要将循环变量定义为引用类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    c <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//toupper是将字符串中的小写的字母转化为大写</span>
<span class="token punctuation">}</span>
cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token comment">//HELLO WORLD</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>通过下标访问String</strong></p> <p>​	可以直接通过下标对<code>string</code>中对应的下标（索引）值进行更改</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;some string&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//在对String进行操作的时候最好进行判断</span>
	s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// Some string</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	也可以使用迭代对<code>string</code>中的元素进行更改</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isspace</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//SOME string</span>
<span class="token comment">//解释：decltype(s.size())返回的是 string::size_type类型 是一种无符号数。index != s.size() &amp;&amp; !isspace(s[index])：循环的条件。index 不能超过字符串 s 的长度，并且当前字符不是空白字符。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_3-3-标准库类型vector"><a href="#_3-3-标准库类型vector" class="header-anchor">#</a> 3.3 标准库类型vector</h3> <p>​	常将<code>vector</code>称为容器。头文件是<code>#include &lt;vector&gt;</code>。在C++中即存在类模板，也存在函数模板。而编译器根据模板创建类或函数的过程称为实例化。</p> <p>​	<code>vector</code>能容纳绝大多类型的对象作为其元素</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>Sales_item<span class="token operator">&gt;</span> Sales_vec<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> file<span class="token punctuation">;</span>
<span class="token comment">//在C++11前如果vector的元素还为vector，则其定义的形式为vector&lt;vector&lt;int&gt; &gt; file;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="header-anchor">#</a> 定义和初始化vector对象</h4> <p>​	初始化<code>vector</code>的方法与<code>string</code>类似。</p> <p>​	初始化<code>vector</code>对象时如果使用圆括号，可以说提供的值是用来构造（construct）<code>vector</code>对象的；如果使用的是花括号，则是在列表初始化（list initialize）该<code>vector</code>对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//v1有10个元素，每个值都是0</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//v2有10个元素，每个值都是1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	可以只提供<code>vector</code>对象容纳的元素数量而省略初始值，此时会创建一个值初始化（value-initialized）的元素初值，并把它赋给容器中的所有元素。这个初值由<code>vector</code>对象中的元素类型决定。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//v1有10个元素，每个值都初始化为0</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v2<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//v2有10个元素，每个都是空string对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="header-anchor">#</a> 向vector对象中添加元素</h4> <p><code>push_back</code>函数可以把一个值添加到<code>vector</code>的尾端。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>        
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>范围<code>for</code>语句体内不应该改变其所遍历序列的大小。</p> <h4 id="其他vector操作"><a href="#其他vector操作" class="header-anchor">#</a> 其他vector操作</h4> <p><code>vector</code>支持的操作：</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>v.empty()</code></td> <td><code>v</code>为空则返回<code>true</code></td></tr> <tr><td><code>v.size()</code></td> <td>返回<code>v</code>中的元素个数</td></tr> <tr><td><code>v.push_back(t)</code></td> <td>将<code>t</code>添加至的<code>v</code>尾部</td></tr> <tr><td><code>v[n]</code></td> <td>返回<code>v</code>中第<code>n</code>个元素的引用</td></tr> <tr><td><code>v = {a, b, c}</code></td> <td>将<code>v</code>赋值为<code>{a, b, c}</code>的拷贝</td></tr></tbody></table> <p><code>size</code>函数返回<code>vector</code>对象中元素的个数，返回值是由<code>vector</code>定义的<code>size_type</code>类型。<code>vector</code>对象的类型包含其中元素的类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type  <span class="token comment">// 正确</span>
vector<span class="token double-colon punctuation">::</span>size_type       <span class="token comment">// 错误</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>vector</code>和<code>string</code>对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>   <span class="token comment">// empty vector</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ivec<span class="token punctuation">[</span>ix<span class="token punctuation">]</span> <span class="token operator">=</span> ix<span class="token punctuation">;</span>  <span class="token comment">// 错误：ivec不包含元素</span>
    ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确：添加一个新元素，该元素的值是ix</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_3-4-迭代器介绍"><a href="#_3-4-迭代器介绍" class="header-anchor">#</a> 3.4 迭代器介绍</h3> <p>​	可以使用下标对<code>string</code>和<code>vector</code>进行访问，迭代器同样也可以做到。迭代器类似于指针，有有效迭代器和无效迭代器。有效迭代器或者指向某个元素，或者指向容器中尾元素的下一个位置。</p> <h4 id="使用迭代器"><a href="#使用迭代器" class="header-anchor">#</a> 使用迭代器</h4> <p>​	迭代器的作用和下标类似，但是更加通用。所有标准库容器都可以使用迭代器，但是其中只有少数几种同时支持下标运算符。</p> <p>​	定义了迭代器的类型都拥有<code>begin</code>和<code>end</code>两个成员函数。<code>begin</code>函数返回指向第一个元素的迭代器，<code>end</code>函数返回指向容器“尾元素的下一位置”的迭代器，通常被称作尾后迭代器（或者简称为尾迭代器。尾后迭代器仅是个标记，表示程序已经处理完了容器中的所有元素。迭代器一般为<code>iterator</code>类型。(可以先简单的理解迭代器的类型为<code>auto</code>)</p> <p>标准容器迭代器的运算符：</p> <table><thead><tr><th>运算符</th> <th>含义</th></tr></thead> <tbody><tr><td><code>*iter</code></td> <td>解引用<code>iter</code></td></tr> <tr><td><code>iter-&gt;mem</code></td> <td>等价于<code>(*iter).mem</code>（可以理解为指向自己）</td></tr> <tr><td><code>++iter</code></td> <td>递增<code>iter</code>使其指向容器的下一个元素</td></tr> <tr><td><code>--iter</code></td> <td>递减<code>iter</code>使其指向容器的前一个元素</td></tr> <tr><td><code>iter1 == iter2</code> <code>iter1 != iter2</code></td> <td>比较<code>iter1</code>和<code>iter2</code>。若他们指向相同元素或都是尾后迭代器，则两者相等</td></tr></tbody></table> <p>​	迭代器和指针类似，可以用解引用迭代器来获取所指的元素。</p> <p>​	迭代器和指针的区别：<a href="https://blog.csdn.net/weixin_45758146/article/details/107029083" target="_blank" rel="noopener noreferrer">C++迭代器和指针区别_C++迭代器和指针的区别-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;some string&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//确保非空</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> it <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	注意：在<code>for</code>或者其他循环语句的判断条件中，最好使用<code>!=</code>而不是<code>&lt;</code>。所有标准库容器的迭代器都定义了<code>==</code>和<code>!=</code>，但是只有其中少数同时定义了<code>&lt;</code>运算符。</p> <p><strong>迭代器的类型</strong></p> <p>迭代器中使用<code>iterator</code>和<code>const_iterator</code>。</p> <p>如果<code>vector</code>或<code>string</code>对象是常量，则只能使用<code>const_iterator</code>迭代器，该迭代器只能读元素，不能写元素。</p> <p><strong>begin和end运算符</strong></p> <p>​	<code>begin</code>和<code>end</code>返回的迭代器具体类型由对象是否是常量决定，如果对象是常量，则返回<code>const_iterator</code>；如果对象不是常量，则返回<code>iterator</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
<span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> cv<span class="token punctuation">;</span>
<span class="token keyword">auto</span> it1 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// it1 的类型是 vector&lt;int&gt;::iterator</span>
<span class="token keyword">auto</span> it2 <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// it2 的类型是 vector&lt;int&gt;::const_iterator</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>C++11新增了<code>cbegin</code>和<code>cend</code>函数，不论<code>vector</code>或<code>string</code>对象是否为常量，都返回<code>const_iterator</code>迭代器。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> it3 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// it3的类型是 vector&lt;int&gt;::const_iterator</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>结合解引用和成员访问操作</strong></p> <p>​	C++中定义了箭头运算符(-&gt;)，<code>(*it).men</code>可以简化为<code>it-&gt;men</code>。（需要关注到的是<code>(*it).men</code>中的括号是必不可少的，建议遇到解引用时都加上括号）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> text<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>it<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>某些对vector对象的操作会使迭代器失效</strong></p> <p>任何可能改变容器对象容量的操作，都会使该对象的迭代器失效。</p> <h4 id="迭代器运算"><a href="#迭代器运算" class="header-anchor">#</a> 迭代器运算</h4> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>iter + n</code> <code>iter - n</code></td> <td><code>iter</code>向前或向后移动<code>n</code>个元素后指向某个元素或尾后位置</td></tr> <tr><td><code>iter1 - iter2</code></td> <td>获得<code>iter1</code>和<code>iter2</code>的间距</td></tr> <tr><td><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td> <td>比较两个迭代器的位置</td></tr></tbody></table> <p><code>difference_type</code>类型用来表示两个迭代器间的距离，这是一种带符号整数类型。</p> <h3 id="_3-5数组"><a href="#_3-5数组" class="header-anchor">#</a> 3.5数组</h3> <h4 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="header-anchor">#</a> 定义和初始化内置数组</h4> <p>​	在不确定大小时用<code>vector</code>。定义数组时不能使用<code>auto</code>，一定要是确定的类型。默认情况下，数组的元素会被默认初始化。</p> <p>​	数组中有一种特殊的字符数组，当用字符串数组初始化时，在数组的最后会存有空字符。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">// 列表初始化，不含有显式的空字符</span>
<span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">,</span> <span class="token char">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 列表初始化，含有显式的空字符</span>
<span class="token keyword">char</span> a3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;C++&quot;</span><span class="token punctuation">;</span>      <span class="token comment">// 自动添加表示字符结束的空字符</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> a4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Daniel&quot;</span><span class="token punctuation">;</span>    <span class="token comment">// error: 没有空间可存空字符</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	数组是不允许拷贝的。</p> <p>​	从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// ptrs是含有10个整形指针的数组</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token comment">/* ? */</span><span class="token punctuation">;</span>    <span class="token comment">// error: 不存在引用的数组</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>Parray<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span>   <span class="token comment">// Parray指向一个含有10个整数的数组</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arrRef<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span>    <span class="token comment">// arrRef引用一个含有10个整数的数组</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arry<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> ptrs<span class="token punctuation">;</span>    <span class="token comment">//arry是数组的引用，该数组含有10个指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="访问数组元素"><a href="#访问数组元素" class="header-anchor">#</a> 访问数组元素</h4> <p>​	数组也可以使用下标来进行访问。使用数组下标时，一般将其定义为<code>size_t</code> ( 一种机器相关的无符号类型，存在<code>cstddf</code>头文件中 )。</p> <p>​	数组的操作和<code>vector</code>基本相同，在遍历的时候推荐使用范围<code>for</code>形式来遍历。</p> <p>​	在使用数组的过程中要特别注意下标。大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p> <h4 id="指针和数组"><a href="#指针和数组" class="header-anchor">#</a> 指针和数组</h4> <p>​	指针和数组有紧密的联系，对数组的操作在很多时候其实时指针的操作。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>stirng num <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;twe&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;three&quot;</span><span class="token punctuation">}</span> 
string <span class="token operator">*</span>p <span class="token operator">=</span> num<span class="token punctuation">;</span><span class="token comment">//指针指向的是数组第一个元素的地址</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>使用<code>auto</code>和<code>decltype</code>关键字时，对于数组的表现并不相同。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">ia2</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时ia2是一个整形指针，指向的时ia中的第一个元素</span>
ia2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//错误，不能把一个常量赋值给ia2</span>

<span class="token keyword">decltype</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span> ia3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//ia3是一个含有10个整形的数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>指针也是迭代器</strong></p> <p>​	就像是迭代器遍历<code>vector</code>对象一样，也可以使用指针遍历数组元素。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//e指向的是数组尾部元素的下一个位置</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> arr<span class="token punctuation">;</span> b <span class="token operator">!=</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//不推荐用int *e = &amp;arr[10];很容易出错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>标准库函数begin和end</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// ia是一个含有10个整数的数组</span>
<span class="token keyword">int</span> <span class="token operator">*</span>beg <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 指向ia首元素的指针</span>
<span class="token keyword">int</span> <span class="token operator">*</span>last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 指向arr尾元素的下一个位置的指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>指针运算</strong></p> <p>​	两个指针相减的结果类型是<code>ptrdiff_t</code>，这是一种定义在头文件<code>cstddef</code>中的带符号类型。</p> <p>​	只有当两个指针指向同一个数组时才能进行关系比较</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> arr<span class="token punctuation">,</span><span class="token operator">*</span>e <span class="token operator">=</span> arr <span class="token operator">+</span>sz<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>b <span class="token operator">&lt;</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token operator">++</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>解引用和指针运算的交互</strong></p> <p>​	指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针。</p> <p>​	需要注意的是如果表达式中含有解引用运算符和点运算符，最好要加上括号</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ia <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将last初始化为ia[4]的值，也就是8</span>
last <span class="token operator">=</span> <span class="token operator">*</span>ia <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//等价于ia[0] + 4，也就是4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="c风格的字符串"><a href="#c风格的字符串" class="header-anchor">#</a> C风格的字符串</h4> <p>​	C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。</p> <p>​	C++标准支持C风格字符串，但是最好不要在C++程序中使用它们。对大多数程序来说，使用标准库<code>string</code>要比使用C风格字符串更加安全和高效。</p> <p>C风格字符串的函数：</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>strlen(p)</code></td> <td>返回<code>p</code>的长度</td></tr> <tr><td><code>strcmp(p1, p2)</code></td> <td>比较<code>p1</code>和<code>p2</code>。若<code>p1 == p2</code>，返回<code>0</code>；若<code>p1 &gt; p2</code>，返回正数；若<code>p1 &lt; p2</code>，返回负数</td></tr> <tr><td><code>strcat(p1, p2)</code></td> <td>将<code>p2</code>拼接至<code>p1</code></td></tr> <tr><td><code>strcpy(p1, p2)</code></td> <td>将<code>p2</code>拷贝至<code>p1</code></td></tr></tbody></table> <p>C风格字符串函数不负责验证其参数的正确性，传入此类函数的指针必须指向以空字符作为结尾的数组。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">char</span> ca<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'C'</span><span class="token punctuation">,</span><span class="token char">'+'</span><span class="token punctuation">,</span><span class="token char">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//错误，ca没有以空字符结尾</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="与旧代码的接口"><a href="#与旧代码的接口" class="header-anchor">#</a> 与旧代码的接口</h4> <p>​	任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：</p> <ul><li><p>允许使用以空字符结束的字符数组来初始化<code>string</code>对象或为<code>string</code>对象赋值。</p></li> <li><p>在<code>string</code>对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。</p></li> <li><p>在<code>string</code>对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。</p> <p>​	不能用<code>string</code>对象直接初始化指向字符的指针。为了实现该功能，<code>string</code>提供了一个名为<code>c_str</code>的成员函数，返回<code>const char*</code>类型的指针，指向一个以空字符结束的字符数组，数组的数据和<code>string</code>对象一样。</p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// s holds Hello World</span>
<span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment">// error: can't initialize a char* from a string</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ok</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	针对<code>string</code>对象的后续操作有可能会让<code>c_str</code>函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p> <p>​	可以使用数组来初始化<code>vector</code>对象，但是需要指明要拷贝区域的首元素地址和尾后地址。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> int_arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ivec有6个元素，分别是int_arr中对应元素的副本</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	在新版本的C++程序中应该尽量使用<code>vector</code>、<code>string</code>和迭代器，避免使用内置数组、C风格字符串和指针。</p> <h3 id="_3-6多维数组"><a href="#_3-6多维数组" class="header-anchor">#</a> 3.6多维数组</h3> <p>​	严格来说，在C++中并不存在多维数组，所谓的多为数组，其实是数组的数组。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//应该理解为：首先ia是一个大小为3的数组，每个元素都要是大小为4的数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>多维数组初始化</strong></p> <p>​	多维数组初始化的几种方式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{</span>  
    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>   
    <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  
    <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ib<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 显式初始化每行的首字母</span>
<span class="token keyword">int</span> ic<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 显式初始化了第1行的元素</span>
<span class="token keyword">int</span> id<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>多维数组的下标引用</strong></p> <p>​	可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 用arr的首元素为ia最后一个元素赋值</span>
ia<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>row<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ia<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 把row绑定到ia的第二个4元素数组上</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>使用范围for语句处理多维数组</strong></p> <p>​	使用范围<code>for</code>语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>row <span class="token operator">:</span> ia<span class="token punctuation">)</span>  <span class="token comment">// 对外层的每一个函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> col <span class="token operator">:</span> row<span class="token punctuation">)</span>    <span class="token comment">// 对内层的每一个函数</span>
        cout <span class="token operator">&lt;&lt;</span> col <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	如果<code>row</code>不是引用类型，编译器初始化<code>row</code>时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的<code>row</code>就是<code>int*</code>类型，而之后的内层循环则试图在一个<code>int*</code>内遍历，程序将无法通过编译。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> row <span class="token operator">:</span> ia<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> col <span class="token operator">:</span> row<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	使用范围<code>for</code>语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。</p> <p>因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。</p> <p><strong>多维数组和指针</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 大小为3的数组，每个元素是含有4个整数的数组</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ia<span class="token punctuation">;</span>   <span class="token comment">// p指向含有4个整数</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>ia<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// p指向ia的尾元素</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	声明指向数组类型的指针时，必须带有圆括号。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 正型指针的数组</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>ip<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 指向含有4个整数的数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	使用<code>auto</code>和<code>decltype</code>能省略复杂的指针定义。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 输出ia中每个元素的值，每个内层数组各占一行</span>
<span class="token comment">// p指向含有4个整形的数组</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> ia<span class="token punctuation">;</span> p <span class="token operator">!=</span> ia <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// q指向4个整形数组的首元素，也就是说，q指向一个整数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> q <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> q <span class="token operator">!=</span> <span class="token operator">*</span>p <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="第四章-表达式"><a href="#第四章-表达式" class="header-anchor">#</a> 第四章 表达式</h2> <h3 id="_4-1基础"><a href="#_4-1基础" class="header-anchor">#</a> 4.1基础</h3> <h4 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h4> <p>​	C++定义了n元运算符，很多的符号既能表示一元运算符也能表示二元运算符。</p> <p>​	对于含有多个运算符的表达式，要注意运算符的优先级。在运算的过程中要注意运算对象的类型转化。</p> <p>​	我们可以重载运算符，包括运算对象的类型和返回值的类型，都是由该运算符定义的;但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p> <p><strong>左值和右值</strong></p> <ul><li>右值: 使用的是它的值(内容), 并忽视&quot;指纹&quot;(这个右值的对象属性, 内存地址什么的)</li> <li>左值: 使用的是它的内存地址, 此时它的值和内存地址同样重要</li></ul> <p>​	在左值和右值的使用过程中，有一个重要的原则，在需要右值的地方可以用左值来代替，但是不能把右值当作左值运算（也就是位置）使用。</p> <p>以下有几种我们熟悉的运算符要用到左值</p> <ul><li>赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。</li> <li>取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。</li> <li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code>和<code>vector</code>的下标运算符都返回左值。</li> <li>内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。</li></ul> <p>​	使用关键字 <code>decltype</code>的时候，左值和右值也有所不同。如果表达式的求值结果是左值，<code>decltype</code>作用于该表达式(不是变量)得到一个引用类型。举个例子，假定<code>p</code>的类型是 <code>int*</code>,因为解引用运算符生成左值，所以<code>decltype(*p)</code>的结果是<code>int&amp;</code>。另一方面，因为取地址运算符生成右值，所以 <code>decltype(&amp;p)</code>的结果是<code>int**</code>，也就是说，结果是一个指向整型指针的指针。</p> <h4 id="优先级和结合律"><a href="#优先级和结合律" class="header-anchor">#</a> 优先级和结合律</h4> <p>​	复合表达式（compound expression）指含有两个或多个运算符的表达式。优先级与结合律决定了运算对象的组合方式。</p> <p>​	括号无视优先级与结合律，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。</p> <h4 id="求值顺序"><a href="#求值顺序" class="header-anchor">#</a> 求值顺序</h4> <p>​	优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。也就是说虽然有优先级的存在，但是程序在运算的过程中，如果优先级存在同级，并不能明确的知道顺序。或者并没有明确规定优先级的，如&quot;&lt;&lt;&quot;</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//未定义的</span>
<span class="token comment">//有可能式1 1，也可以是 0 1</span>
<span class="token comment">//因为不知道编译器是先运算&quot;&lt;&lt;&quot;还是&quot;++&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>有四种运算符明确规定了运算对象：</p> <ol><li>逻辑与(&amp;&amp;)运算符，它规定先求左侧运算对象的值。只有当左侧对象的值为真时才继续进行右侧的运算</li> <li>逻辑或(||)运算符，当且仅当左侧运算对象为假时才对右侧运算对象求值</li> <li>条件(?:)运算符，详见4.7。</li> <li>逗号(,)运算符，含有两个运算对象，按照从左向右的顺序依次求值，最后返回右侧表达式的值。</li></ol> <p>处理复合表达式时建议遵循以下两点：</p> <ul><li>不确定求值顺序时，使用括号来强制让表达式的组合关系符合程序逻辑的要求。</li> <li>如果表达式改变了某个运算对象的值，则在表达式的其他位置不要再使用这个运算对象。</li></ul> <p>​	当改变运算对象的子表达式本身就是另一个子表达式的运算对象时，第二条规则无效。如<code>*++iter</code>，递增运算符改变了<code>iter</code>的值，而改变后的<code>iter</code>又是解引用运算符的运算对象。类似情况下，求值的顺序不会成为问题。</p> <h3 id="_4-2算术运算符"><a href="#_4-2算术运算符" class="header-anchor">#</a> 4.2算术运算符</h3> <p>算术运算符（左结合律）：</p> <table><thead><tr><th>运算符</th> <th>功能</th> <th>用法</th></tr></thead> <tbody><tr><td><code>+</code></td> <td>一元正号</td> <td><code>+expr</code></td></tr> <tr><td><code>-</code></td> <td>一元负号</td> <td><code>-expr</code></td></tr> <tr><td><code>*</code></td> <td>乘</td> <td><code>expr * expr</code></td></tr> <tr><td><code>/</code></td> <td>除</td> <td><code>expr / expr</code></td></tr> <tr><td><code>%</code></td> <td>取余</td> <td><code>expr % expr</code></td></tr> <tr><td><code>+</code></td> <td>加</td> <td><code>expr + expr</code></td></tr> <tr><td><code>-</code></td> <td>减</td> <td><code>expr - expr</code></td></tr></tbody></table> <p>在除法运算中，C++语言的早期版本允许结果为负数的商向上或向下取整，C++11新标准则规定商一律向0取整（即直接去除小数部分）。</p> <h3 id="_4-3逻辑和关系运算符"><a href="#_4-3逻辑和关系运算符" class="header-anchor">#</a> 4.3逻辑和关系运算符</h3> <p>​	关系运算符作用于算术类型和指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。</p> <table><thead><tr><th>结合律</th> <th>运算符</th> <th>功能</th> <th>用法</th></tr></thead> <tbody><tr><td>右</td> <td><code>!</code></td> <td>逻辑非</td> <td><code>!expr</code></td></tr> <tr><td>左</td> <td><code>&lt;</code></td> <td>小于</td> <td><code>expr &lt; expr</code></td></tr> <tr><td>左</td> <td><code>&lt;=</code></td> <td>小于等于</td> <td><code>expr &lt;= expr</code></td></tr> <tr><td>左</td> <td><code>&gt;</code></td> <td>大于</td> <td><code>expr &gt; expr</code></td></tr> <tr><td>左</td> <td><code>&gt;=</code></td> <td>大于等于</td> <td><code>expr &gt;= expr</code></td></tr> <tr><td>左</td> <td><code>==</code></td> <td>相等</td> <td><code>expr == expr</code></td></tr> <tr><td>左</td> <td><code>!=</code></td> <td>不相等</td> <td><code>expr != expr</code></td></tr> <tr><td>左</td> <td><code>&amp;&amp;</code></td> <td>逻辑与</td> <td><code>expr &amp;&amp; expr</code></td></tr> <tr><td>左</td> <td><code>||</code></td> <td>逻辑或</td> <td><code>expr || expr</code></td></tr></tbody></table> <p>逻辑与（logical AND）运算符<code>&amp;&amp;</code>和逻辑或（logical OR）运算符<code>||</code>都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation）。</p> <ul><li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li> <li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li></ul> <p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值<code>true</code>和<code>false</code>作为运算对象。</p> <h3 id="_4-4赋值运算符"><a href="#_4-4赋值运算符" class="header-anchor">#</a> 4.4赋值运算符</h3> <p>赋值运算符<code>=</code>的左侧运算对象必须是一个可修改的左值。</p> <p>C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vi<span class="token punctuation">;</span>
vi <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>赋值运算符满足右结合律。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ival<span class="token punctuation">,</span> jval<span class="token punctuation">;</span>
ival <span class="token operator">=</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 正确，都被赋值为0.但是我认为这种赋值方法不可取</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。</p> <p>不要混淆相等运算符<code>==</code>和赋值运算符<code>=</code>。</p> <p>复合赋值运算符包括<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>和<code>|=</code>。任意一种复合运算都完全等价于<em>a = a op b</em>。</p> <h3 id="_4-5递增和递减运算符"><a href="#_4-5递增和递减运算符" class="header-anchor">#</a> 4.5递增和递减运算符</h3> <p>递增(++)和递减(--)运算符是为对象加1或减1的简洁书写形式。很多不支持算术运算的迭代器，可以使用递增和递减运算符。</p> <p>递增和递减运算符分为前置版本和后置版本：</p> <ul><li>前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。</li> <li>后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span>
j <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token comment">// j = 1, i = 1</span>
j <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// j = 1, i = 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	除非必须，否则不应该使用递增或递减运算符的后置版本。后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。</p> <p>在某些语句中混用解引用和递增运算符可以使程序更简洁。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>iter<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出当前的值，并把iter指针往后移动一位</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_4-6成员访问运算符"><a href="#_4-6成员访问运算符" class="header-anchor">#</a> 4.6成员访问运算符</h3> <p>点运算符<code>.</code>和箭头运算符<code>-&gt;</code>都可以用来访问成员，表达式<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string s1 <span class="token operator">=</span> <span class="token string">&quot;a string&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span>
<span class="token keyword">auto</span> n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//运行string对象</span>
n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//运行p所指对象的size成员</span>
n <span class="token operator">=</span> p<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//等价于(*p).size()</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_4-7条件运算符"><a href="#_4-7条件运算符" class="header-anchor">#</a> 4.7条件运算符</h3> <p>条件运算符的使用形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cond <span class="token operator">?</span> expr1 <span class="token operator">:</span> expr2<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中<code>cond</code>是判断条件的表达式，如果<code>cond</code>为真则对<code>expr1</code>求值并返回该值，否则对<code>expr2</code>求值并返回该值。</p> <p>只有当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果才是左值，否则运算的结果就是右值。</p> <p>条件运算符可以嵌套，但是考虑到代码的可读性，运算的嵌套层数最好不要超过两到三层。</p> <p>条件运算符的优先级非常低，因此当一个长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。</p> <h3 id="_4-8位运算符"><a href="#_4-8位运算符" class="header-anchor">#</a> 4.8位运算符</h3> <p>位运算符（左结合律）：</p> <table><thead><tr><th>运算符</th> <th>功能</th> <th>用法</th></tr></thead> <tbody><tr><td><code>~</code></td> <td>位求反</td> <td><code>~expr</code></td></tr> <tr><td><code>&lt;&lt;</code></td> <td>左移</td> <td><code>expr &lt;&lt; expr</code></td></tr> <tr><td><code>&gt;&gt;</code></td> <td>右移</td> <td><code>expr &gt;&gt; expr</code></td></tr> <tr><td><code>&amp;</code></td> <td>位与</td> <td><code>expr &amp; expr</code></td></tr> <tr><td><code>^</code></td> <td>位异或</td> <td><code>expr ^ expr</code></td></tr> <tr><td><code>|</code></td> <td>位或</td> <td><code>expr | expr</code></td></tr></tbody></table> <p>在位运算中符号位如何处理并没有明确的规定，所以建议仅将位运算符用于无符号类型的处理。</p> <p>​	左移运算符<code>&lt;&lt;</code>在运算对象右侧插入值为0的二进制位。右移运算符<code>&gt;&gt;</code>的行为依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在其左侧插入值为0的二进制位；如果是带符号类型，在其左侧插入符号位的副本或者值为0的二进制位，如何选择视具体环境而定。</p> <h3 id="_4-9sizeof运算符"><a href="#_4-9sizeof运算符" class="header-anchor">#</a> 4.9sizeof运算符</h3> <p><code>sizeof</code>运算符返回一个表达式或一个类型名字所占的字节数，返回值是<code>size_t</code>类型。</p> <p>在<code>sizeof</code>的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。</p> <p><code>sizeof</code>运算符的结果部分依赖于其作用的类型：</p> <ul><li>对<code>char</code>或者类型为<code>char</code>的表达式执行<code>sizeof</code>运算，返回值为1。</li> <li>对引用类型执行<code>sizeof</code>运算得到被引用对象所占空间的大小。</li> <li>对指针执行<code>sizeof</code>运算得到指针本身所占空间的大小。</li> <li>对解引用指针执行<code>sizeof</code>运算得到指针指向的对象所占空间的大小，指针不需要有效。</li> <li>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小。</li> <li>对<code>string</code>或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。</li></ul> <h3 id="_4-10逗号运算符"><a href="#_4-10逗号运算符" class="header-anchor">#</a> 4.10逗号运算符</h3> <p>逗号运算符<code>,</code>含有两个运算对象，按照从左向右的顺序依次求值，最后返回右侧表达式的值。逗号运算符经常用在<code>for</code>循环中。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type cnt <span class="token operator">=</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将把从size到1的值赋给ivec的元素</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">,</span> <span class="token operator">--</span>cnt<span class="token punctuation">)</span>
    ivec<span class="token punctuation">[</span>ix<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_4-11类型转换"><a href="#_4-11类型转换" class="header-anchor">#</a> 4.11类型转换</h3> <p>​	无须程序员介入，会自动执行的类型转换叫做隐式转换。</p> <h4 id="算术转换"><a href="#算术转换" class="header-anchor">#</a> 算术转换</h4> <p>​	把一种算术类型转换成另一种算术类型叫做算术转换。</p> <p>​	整型提升，负责把小整数类型转换成较大的整数类型。</p> <h4 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="header-anchor">#</a> 其他隐式类型转换</h4> <p>​	在大多数表达式中，数组名字自动转换成指向数组首元素的指针。</p> <p>​	常量整数值0或字面值<code>nullptr</code>能转换成任意指针类型；指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针能转换成<code>const void*</code>。</p> <p>​	任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是<code>false</code>，否则是<code>true</code>。</p> <p>​	指向非常量类型的指针能转换成指向相应的常量类型的指针。</p> <h4 id="显式转换"><a href="#显式转换" class="header-anchor">#</a> 显式转换</h4> <p>​	显式类型转换也叫做强制类型转换（cast）。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。</p> <p>​	命名的强制类型转换（named cast）形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cast<span class="token operator">-</span><span class="token generic-function"><span class="token function">name</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	其中<code>type</code>是转换的目标类型，<code>expression</code>是要转换的值。如果<code>type</code>是引用类型，则转换结果是左值。<code>cast-name</code>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种，用来指定转换的方式。</p> <ul><li><p><code>dynamic_cast</code>支持运行时类型识别。</p></li> <li><p>任何具有明确定义的类型转换，只要不包含底层<code>const</code>，都能使用<code>static_cast</code>。</p></li> <li><p><code>const_cast</code>只能改变运算对象的底层<code>const</code>，不能改变表达式的类型。同时也只有<code>const_cast</code>能改变表达式的常量属性。<code>const_cast</code>常常用于函数重载。</p></li> <li><p><code>reinterpret_cast</code>通常为运算对象的位模式提供底层上的重新解释。</p> <p><strong>早期版本的C++语言中，显式类型转换包含两种形式：</strong></p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">type</span> <span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 函数形式的强制类型转化</span>
<span class="token punctuation">(</span>type<span class="token punctuation">)</span> expression<span class="token punctuation">;</span>    <span class="token comment">// c语言风格的强制类型转化</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="第五章-语句"><a href="#第五章-语句" class="header-anchor">#</a> 第五章 语句</h2> <h3 id="_5-1简单语句"><a href="#_5-1简单语句" class="header-anchor">#</a> 5.1简单语句</h3> <p>​	一个表达式语句以分号结尾。复合语句用花括号框起来。</p> <p>​	使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。</p> <h3 id="_5-2语句作用域"><a href="#_5-2语句作用域" class="header-anchor">#</a> 5.2语句作用域</h3> <p>​	可以在<code>if</code>、<code>switch</code>、<code>while</code>和<code>for</code>语句的控制结构内定义变量，这些变量只在相应语句的内部可见，一旦语句结束，变量也就超出了其作用范围。</p> <h3 id="_5-3条件语句"><a href="#_5-3条件语句" class="header-anchor">#</a> 5.3条件语句</h3> <h4 id="if语句"><a href="#if语句" class="header-anchor">#</a> if语句</h4> <p><code>if</code>语句的形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>if-else</code>语句的形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    statement <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{</span>
    statement <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>其中<code>condition</code>是判断条件，可以是一个表达式或者初始化了的变量声明。<code>condition</code>必须用圆括号括起来。</p> <ul><li>如果<code>condition</code>为真，则执行<code>statement</code>。执行完成后，程序继续执行<code>if</code>语句后面的其他语句。</li> <li>如果<code>condition</code>为假，则跳过<code>statement</code>。对于简单<code>if</code>语句来说，程序直接执行<code>if</code>语句后面的其他语句；对于<code>if-else</code>语句来说，程序先执行<code>statement2</code>，再执行<code>if</code>语句后面的其他语句。</li></ul> <p><code>if</code>语句可以嵌套，其中<code>else</code>与离它最近的尚未匹配的<code>if</code>相匹配。</p> <h4 id="switch语句"><a href="#switch语句" class="header-anchor">#</a> switch语句</h4> <p><code>switch</code>语句的形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>number<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
    <span class="token punctuation">{</span>
        statement <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
    <span class="token punctuation">{</span>
        statement <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token punctuation">{</span>
        statement <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>​	<code>switch</code>语句先对括号里的表达式求值，值转换成整数类型后再与每个<code>case</code>标签（case label）的值进行比较。如果表达式的值和某个<code>case</code>标签匹配，程序从该标签之后的第一条语句开始执行，直到到达<code>switch</code>的结尾或者遇到<code>break</code>语句为止。<code>case</code>标签必须是整型常量表达式（存疑，认为字符型常量也行，单字符应该是会自动转int）。</p> <p>​	通常情况下每个<code>case</code>分支后都有<code>break</code>语句。如果确实不应该出现<code>break</code>语句，最好写一段注释说明程序的逻辑。</p> <p>​	尽管<code>switch</code>语句没有强制要求在最后一个<code>case</code>标签后写上<code>break</code>，但为了安全起见，最好添加<code>break</code>。这样即使以后增加了新的<code>case</code>分支，也不用再在前面补充<code>break</code>语句了。</p> <p>​	<code>switch</code>语句中可以添加一个<code>default</code>标签，如果没有任何一个<code>case</code>标签能匹配上<code>switch</code>表达式的值，程序将执行<code>default</code>标签后的语句。</p> <p>​	即使不准备在<code>default</code>标签下做任何操作，程序中也应该定义一个<code>default</code>标签。其目的在于告诉他人我们已经考虑到了默认情况，只是目前不需要实际操作。</p> <p>​	不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。如果需要为<code>switch</code>的某个<code>case</code>分支定义并初始化一个变量，则应该把变量定义在块内。</p> <p>​	允许三种情况</p> <ol><li>可在default中定义；</li> <li>可在最后一个case中定义；</li> <li>在某个特殊的case中定义变量，但必须引入块语句。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">case</span> <span class="token boolean">true</span><span class="token operator">:</span>
 <span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//（1）编译出错</span>
   <span class="token keyword">break</span><span class="token punctuation">;</span>
   <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
  <span class="token punctuation">{</span>
   <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//（2）编译通过,引入块语句</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
   <span class="token keyword">int</span> c <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//（3）编译通过，最后一个case</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;ss&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//输出ss</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ol><li>switch后面的括号里面只能是自动类型转换成int,(short、 char、int、byte)</li> <li>case后面只能跟自动类型转换成int的常量或者常量 表达式</li> <li>case后面的常量必须唯一</li> <li>case和default顺序可以交换，前提是case和default加加了break</li> <li>在case后面如果有多条语句，可以不用加花括号</li></ol> <h3 id="_5-4迭代语句"><a href="#_5-4迭代语句" class="header-anchor">#</a> 5.4迭代语句</h3> <h4 id="while语句"><a href="#while语句" class="header-anchor">#</a> while语句</h4> <p><code>while</code>语句的形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	只要<code>condition</code>的求值结果为<code>true</code>，就一直执行<code>statement</code>（通常是一个块）。<code>condition</code>不能为空，如果<code>condition</code>第一次求值就是<code>false</code>，<code>statement</code>一次都不会执行。</p> <p>​	定义在<code>while</code>条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。</p> <p>​	在不确定迭代次数，或者想在循环结束后访问循环控制变量时，使用<code>while</code>比较合适。</p> <h4 id="传统的for语句"><a href="#传统的for语句" class="header-anchor">#</a> 传统的for语句</h4> <p><code>for</code>语句的形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>initializer<span class="token punctuation">;</span> condition<span class="token punctuation">;</span> expression<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	一般情况下，<code>initializer</code>负责初始化一个值，这个值会随着循环的进行而改变。<code>condition</code>作为循环控制的条件，只要<code>condition</code>的求值结果为<code>true</code>，就执行一次<code>statement</code>。执行后再由<code>expression</code>负责修改<code>initializer</code>初始化的变量，这个变量就是<code>condition</code>检查的对象。如果<code>condition</code>第一次求值就是<code>false</code>，<code>statement</code>一次都不会执行。<code>initializer</code>中也可以定义多个对象，但是只能有一条声明语句，因此所有变量的基础类型必须相同。</p> <p>​	<code>for</code>语句头中定义的对象只在<code>for</code>循环体内可见。</p> <h4 id="范围for语句"><a href="#范围for语句" class="header-anchor">#</a> 范围for语句</h4> <p>范围<code>for</code>语句的形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	其中<code>expression</code>表示一个序列，拥有能返回迭代器的<code>begin</code>和<code>end</code>成员。<code>declaration</code>定义一个变量，序列中的每个元素都应该能转换成该变量的类型（可以使用<code>auto</code>）。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。每次迭代都会重新定义循环控制变量，并将其初始化为序列中的下一个值，之后才会执行<code>statement</code></p> <h4 id="do-while语句"><a href="#do-while语句" class="header-anchor">#</a> do-while语句</h4> <p><code>do-while</code>语句的形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">do</span>
<span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	计算<code>condition</code>的值之前会先执行一次<code>statement</code>，<code>condition</code>不能为空。如果<code>condition</code>的值为<code>false</code>，循环终止，否则重复执行<code>statement</code>。</p> <p>​	因为<code>do-while</code>语句先执行语句或块，再判断条件，所以不允许在条件部分定义变量。</p> <h3 id="_5-5跳转语句"><a href="#_5-5跳转语句" class="header-anchor">#</a> 5.5跳转语句</h3> <p>跳转语句中断当前的执行过程。</p> <h4 id="break语句"><a href="#break语句" class="header-anchor">#</a> break语句</h4> <p>​	<code>break</code>语句只能出现在迭代语句或者<code>switch</code>语句的内部，负责终止离它最近的<code>while</code>、<code>do-while</code>、<code>for</code>或者<code>switch</code>语句，并从这些语句之后的第一条语句开始执行。</p> <h4 id="continue语句"><a href="#continue语句" class="header-anchor">#</a> continue语句</h4> <p>​	<code>continue</code>语句只能出现在迭代语句的内部，负责终止离它最近的循环的当前一次迭代并立即开始下一次迭代。和<code>break</code>语句不同的是，只有当<code>switch</code>语句嵌套在迭代语句内部时，才能在<code>switch</code>中使用<code>continue</code>。</p> <p><code>continue</code>语句中断当前迭代后，具体操作视迭代语句类型而定：</p> <ul><li>对于<code>while</code>和<code>do-while</code>语句来说，继续判断条件的值。</li> <li>对于传统的<code>for</code>语句来说，继续执行<code>for</code>语句头中的第三部分，之后判断条件的值。</li> <li>对于范围<code>for</code>语句来说，是用序列中的下一个元素初始化循环变量。</li></ul> <h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="header-anchor">#</a> try语句块和异常处理</h3> <p>异常（exception）是指程序运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某一部分检测到一个它无法处理的问题时，需要使用异常处理（exception handling）。</p> <p>异常处理机制包括<code>throw</code>表达式（throw expression）、<code>try</code>语句块（try block）和异常类（exception class）。</p> <ul><li>异常检测部分使用<code>throw</code>表达式表示它遇到了无法处理的问题（<code>throw</code>引发了异常）。</li> <li>异常处理部分使用<code>try</code>语句块处理异常。<code>try</code>语句块以关键字<code>try</code>开始，并以一个或多个<code>catch</code>子句（catch clause）结束。<code>try</code>语句块中代码抛出的异常通常会被某个<code>catch</code>子句处理，<code>catch</code>子句也被称作异常处理代码（exception handler）。</li> <li>异常类用于在<code>throw</code>表达式和相关的<code>catch</code>子句之间传递异常的具体信息。</li></ul> <h4 id="throw表达式"><a href="#throw表达式" class="header-anchor">#</a> throw表达式</h4> <p><code>throw</code>表达式包含关键字<code>throw</code>和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。</p> <h4 id="try语句块"><a href="#try语句块" class="header-anchor">#</a> try语句块</h4> <p><code>try</code>语句块的通用形式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">try</span>
<span class="token punctuation">{</span>
    program<span class="token operator">-</span>statements<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span>exception<span class="token operator">-</span>declaration<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    handler<span class="token operator">-</span>statements<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span>exception<span class="token operator">-</span>declaration<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    handler<span class="token operator">-</span>statements<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​	<code>try</code>语句块中的<code>program-statements</code>组成程序的正常逻辑，其内部声明的变量在块外无法访问，即使在<code>catch</code>子句中也不行。<code>catch</code>子句包含关键字<code>catch</code>、括号内一个对象的声明（异常声明，exception declaration）和一个块。当选中了某个<code>catch</code>子句处理异常后，执行与之对应的块。<code>catch</code>一旦完成，程序会跳过剩余的所有<code>catch</code>子句，继续执行后面的语句。</p> <p>​	如果最终没能找到与异常相匹配的<code>catch</code>子句，程序会执行名为<code>terminate</code>的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。类似的，如果一段程序没有<code>try</code>语句块且发生了异常，系统也会调用<code>terminate</code>函数并终止当前程序的执行。</p> <h4 id="标准异常"><a href="#标准异常" class="header-anchor">#</a> 标准异常</h4> <p>异常类分别定义在4个头文件中：</p> <ul><li><p>头文件<code>exception</code>定义了最通用的异常类<code>exception</code>。它只报告异常的发生，不提供任何额外信息。</p></li> <li><p>头文件<code>stdexcept</code>定义了几种常用的异常类。</p> <table><thead><tr><th>类型</th> <th>含义</th></tr></thead> <tbody><tr><td><code>exception</code></td> <td>最常见的错误</td></tr> <tr><td><code>runtime_error</code></td> <td>运行时错误</td></tr> <tr><td><code>overflow_error</code></td> <td>计算上溢</td></tr> <tr><td><code>underflow_error</code></td> <td>计算下溢</td></tr> <tr><td><code>range_error</code></td> <td>数值超出有意义的值域</td></tr> <tr><td><code>logic_error</code></td> <td>程序逻辑错误</td></tr> <tr><td><code>domain_error</code></td> <td>参数值不存在</td></tr> <tr><td><code>invalid_argument</code></td> <td>无效参数</td></tr> <tr><td><code>out_of_range</code></td> <td>试图创建超出该类型最大长度的对象</td></tr> <tr><td><code>length_error</code></td> <td>数值超出有效范围</td></tr></tbody></table></li> <li><p>头文件<code>new</code>定义了<code>bad_alloc</code>异常类。</p></li> <li><p>头文件<code>type_info</code>定义了<code>bad_cast</code>异常类。</p></li></ul> <p><img src="https://raw.githubusercontent.com/moyangsun/ty_assist/main/img/MatLab202403282146262.png" alt="image-20240328214641176"></p> <h2 id="第六章-函数"><a href="#第六章-函数" class="header-anchor">#</a> 第六章 函数</h2> <h3 id="_6-1-函数基础"><a href="#_6-1-函数基础" class="header-anchor">#</a> 6.1 函数基础</h3> <p>函数执行=已定义好的函数+函数调用符</p> <p>函数调用符（括号）</p> <p>{1.作用于调用表达式</p> <p>（调用表达式：2.调用表达式是函数或者函数指针）</p> <p>3.括号内是实参列表，实参列表可初始化函数形参</p> <p>}</p> <p><strong>形参和实参</strong></p> <p>​	实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管存在实参和形参的对应关系，但是并没有规定实参的求职顺序</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//并不能确定先计算哪个函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>函数的形参列表</strong></p> <p>​	在C++中要想定义一个不带形参的函数，最常用的方法是书写一个空的形参列表。但是为了与C兼容，也可以使用关键字void表示函数没有形参：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//隐式地定义空形参列表</span>

<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//显示地定义形参列表</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	函数体内部仍可以写大括号, 只属于最大的那个括号而不属于其他任何一个括号的地区就是最外层作用域(也就是说, 在函数内部的与形参同名的变量定义时必须要用大括号藏起来)</p> <p>最外层作用域就是函数括号下</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>           <span class="token comment">// function has a parameter</span>
<span class="token punctuation">{</span>                       <span class="token comment">// beginning of function scope</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>              <span class="token comment">// OK: local variable</span>
    <span class="token punctuation">{</span>                   <span class="token comment">// beginning of inner block</span>
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>          <span class="token comment">// OK: hides parameter</span>
        <span class="token keyword">int</span> b<span class="token punctuation">;</span>          <span class="token comment">// OK: hides outer variable</span>
    <span class="token punctuation">}</span>                   <span class="token comment">// end of inner block</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>              <span class="token comment">// Error: can't have same name as parameter</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>https://stackoverflow.com/questions/30125671/what-does-local-variables-at-the-outermost-scope-of-the-function-may-not-use-th</p> <p><strong>函数返回值</strong></p> <p>C++函数不能返回数组或者函数(Haskell可以）</p> <p>作为补偿, C++可以返回指向数组或者函数的指针(或引用)</p> <h4 id="局部对象"><a href="#局部对象" class="header-anchor">#</a> 局部对象</h4> <p>​	C++中名字有作用域，对象有生命周期。</p> <ul><li>名字的作用域是程序文本的一部分，名字在其中可见。</li> <li>对象的生命周期是程序执行过程中对该对象存在的一段时间</li></ul> <p>形参和函数体内部定义的变量统称为局部变量。</p> <p>局部变量隐藏外层作用域的特性</p> <ul><li>作用域包括:
loops作用域;(loops内部生成一个局部变量)
函数中的内部作用域(函数中是可以写大括号来增加一个作用域的), 它与函数内部是相隔绝的, 有点像盒子中的另一个盒</li> <li>隐藏行为:
当变量间出现重名的情况下，作用域小的屏蔽作用域大的</li></ul> <p><strong>自动对象</strong></p> <p>​	我们把只存在于块执行期间的对象称为自动对象。</p> <p><a href="https://www.zhihu.com/question/55306698" target="_blank" rel="noopener noreferrer">C++ 局部变量和自动对象有什么区别？ - 知乎 (zhihu.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>局部静态变量</strong></p> <p>​	可以将局部变量定义成<code>static</code>类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p> <h4 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h4> <p>​	函数的三要素(返回类型、函数名、形参类型)描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型。</p> <p><strong>在头文件中进行函数声明</strong></p> <p>​	我们建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。</p> <h4 id="分离式编译"><a href="#分离式编译" class="header-anchor">#</a> 分离式编译</h4> <p>​	分离式编译允许我们把程序按照逻辑关系分割到几个文件中去，每个文件独立编译。这一过程通常会产生后缀名是<code>.obj</code>或<code>.o</code>的文件，该文件包含对象代码。之后编译器把对象文件链接在一起形成可执行文件。</p> <h3 id="_6-2参数传递"><a href="#_6-2参数传递" class="header-anchor">#</a> 6.2参数传递</h3> <p>形参初始化的机理与变量初始化一样。</p> <p>形参的类型决定了形参和实参交互的方式：</p> <ul><li>当形参是引用类型时，它对应的实参被引用传递，函数被传引用调用。引用形参是它对应实参的别名。</li> <li>当形参不是引用类型时，形参和实参是两个相互独立的对象，实参的值会被拷贝给形参（值传递），函数被传值调用。</li></ul> <h4 id="传值参数"><a href="#传值参数" class="header-anchor">#</a> 传值参数</h4> <p>​	当初始化一个非引用类型的变量时，初始值被拷贝给变量。</p> <p><strong>指针形参</strong></p> <p>​	指针的行为和其他非引用类型一样。当执行拷贝操作时，拷贝的是指针的值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span>，i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span> <span class="token operator">&amp;</span>n，<span class="token operator">*</span>q<span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">// P指向n;q指向i</span>
<span class="token operator">*</span>p42<span class="token punctuation">;</span><span class="token comment">// n的值改变;p不变</span>
p<span class="token operator">=</span>q；<span class="token comment">// p现在指向了i;但是i和n的值都不变</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="传引用参数"><a href="#传引用参数" class="header-anchor">#</a> 传引用参数</h4> <p>​	使用引用传参，函数可以改变实参的值。</p> <p><strong>使用引用避免拷贝</strong></p> <p>​	拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型(包括 IO 类型在内)根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p> <p>​	如果函数无须改变引用形参的值，最好将其声明为常量引用</p> <p><strong>使用引用形参返回额外信息</strong></p> <p>​	一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。</p> <h4 id="const形参和实参"><a href="#const形参和实参" class="header-anchor">#</a> const形参和实参</h4> <p>​	当形参有顶层<code>const</code>时，传递给它常量对象或非常量对象都是可以的。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token comment">//fcn能够读取i，但是不能向i写值</span>
<span class="token comment">//调用fcn函数时，既可以传入const int也可以传入int</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	在C++中，允许我们定义若干具有相同名字的函数，不过前提时不同函数的形参列表应该有明显区别。</p> <p>​	可以使用非常量对象初始化一个底层<code>const</code>形参，但是反过来不行。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>cp<span class="token operator">=</span>si<span class="token punctuation">;</span><span class="token comment">// 正确:但是cp 不能改变i</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r<span class="token operator">=</span><span class="token punctuation">;</span> <span class="token comment">// 正确:但是r不能改变</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">// 正确</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span>cp<span class="token punctuation">;</span><span class="token comment">// 错误:p的类型和 cp 的类型不匹配</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token comment">// 错误:r3 的类型和r的类型不匹配</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r4 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">// 错误:不能用宇面值初始化一个非常量引用</span>
<span class="token comment">//------------------------------------------------</span>
<span class="token comment">//将同样的初始化规则应用到参数传递上可得到如下形式</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">;</span>
string<span class="token double-colon punctuation">::</span>size type ctr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">reset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用形参类型是 int*的 reset 函数</span>
<span class="token function">reset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 错误:不能用指向 const int 对象的指针初始化 int*</span>
<span class="token function">reset</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用形参类型是 int&amp;的 reset 函数</span>
<span class="token function">reset</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 错误:不能把普通引用绑定到 const 对象 ci 上</span>
<span class="token function">reset</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 错误:不能把普通应用绑定到字面值上</span>
<span class="token function">reset</span><span class="token punctuation">(</span>ctr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 错误:类型不匹配，ctr 是无符号类型</span>
<span class="token comment">// 正确:find char 的第一个形参是对常量的引用</span>
find <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span>， o<span class="token number">'</span>，ctr<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p><strong>尽量使用常量引用</strong></p> <p>​	把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。</p> <h4 id="数组形参"><a href="#数组形参" class="header-anchor">#</a> 数组形参</h4> <p>​	因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 每个函数都有一个const int*类型的形参</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 可以看出来，函数的意图是作用于一个数组</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这里的维度表示我们期望数组含有多少元素，实际不一定</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。</p> <p>​	因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。</p> <p>​	以数组作为形参的函数必须确保使用数组时不会越界。</p> <p>​	三种给函数提供数组的确切尺寸：</p> <ol><li>使用标记指定数组长度。如：C风格字符数组中最后一个字符后面跟着一个空字符。</li> <li>使用标准库规范。传递指向数组首元素和尾后元素的指针。</li> <li>显示传递一个表示数组大小的形参。即在传参时直接传入数组的长度。</li></ol> <p><strong>数组引用形参</strong></p> <p>​	C++语言允许将变量定义成数组的引用基于同样的道理形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//两端的括号是必不可少的</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> arr<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>传递多维数组</strong></p> <p>​	C++中没有真正意义上的多维数组，所谓的多维数组也就是在数组中存了数组，所有在传递多维数组时真正传递的时指向数组首元素的指针。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//matrix指向数组的首元素，该数组的元素时由10个整数构成的数组</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>matrix<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> rowSize<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="header-anchor">#</a> main：处理命令行选项</h4> <p>可以在命令行中向<code>main</code>函数传递参数，形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第二个形参<code>argv</code>是一个数组，数组元素是指向C风格字符串的指针；第一个形参<code>argc</code>表示数组中字符串的数量。</p> <p>当实参传递给<code>main</code>函数后，<code>argv</code>的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</p> <h4 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="header-anchor">#</a> 含有可变形参的函数</h4> <p>C++11新标准提供了两种主要方法处理实参数量不定的函数。</p> <ul><li><p>如果实参类型相同，可以使用<code>initializer_list</code>标准库类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">error_msg</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> il<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> il<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> beg <span class="token operator">!=</span> il<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>beg<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>beg <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>如果实参类型不同，可以定义可变参数模板。</p></li></ul> <p>​	C++还可以使用省略符形参传递可变数量的实参，但这种功能一般只用在与C函数交换的接口程序中。</p> <p>​	<code>initializer_list</code>是一种标准库类型，定义在头文件<code>initializer_list</code>中，表示某种特定类型的值的数组。</p> <p>​	<code>initializer_list</code>提供的操作：</p> <table><thead><tr><th>操作</th> <th>含义</th></tr></thead> <tbody><tr><td><code>initializer_list&lt;T&gt; lst</code></td> <td><code>lst</code>被默认初始化为<code>T</code>类型元素的空列表</td></tr> <tr><td><code>initializer_list&lt;T&gt; lst {a, b, c}</code></td> <td><code>lst</code>中的元素为<code>{a, b, c}</code>的<code>const</code>拷贝</td></tr> <tr><td><code>initializer_list&lt;T&gt; lst2(lst1)</code> <code>lst2 = lst1</code></td> <td>拷贝或赋值<code>initializer_list</code>并不会拷贝其中的元素，它们被<code>lst1</code>和<code>lst2</code>共享</td></tr> <tr><td><code>lst.size()</code></td> <td>返回<code>lst</code>中的元素数量</td></tr> <tr><td><code>lst.begin()</code></td> <td>返回指向<code>lst</code>中首元素的指针</td></tr> <tr><td><code>lst.end()</code></td> <td>返回指向<code>lst</code>中尾元素下一位置的指针</td></tr></tbody></table> <p>​	拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素。拷贝后，原始列表和副本共享元素。</p> <p><code>initializer_list</code>对象中的元素永远是常量值。</p> <p>​	如果想向<code>initializer_list</code>形参传递一个值的序列，则必须把序列放在一对花括号内。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>expected <span class="token operator">!=</span> actual<span class="token punctuation">)</span>
    <span class="token function">error_msg</span><span class="token punctuation">(</span><span class="token function">ErrCode</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">&quot;functionX&quot;</span><span class="token punctuation">,</span> expected<span class="token punctuation">,</span> actual<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    <span class="token function">error_msg</span><span class="token punctuation">(</span><span class="token function">ErrCode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">&quot;functionX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;okay&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	因为<code>initializer_list</code>包含<code>begin</code>和<code>end</code>成员，所以可以使用范围<code>for</code>循环处理其中的元素。</p> <p>​	省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为<code>varargs</code>的C标准库功能。通常，省略符形参不应该用于其他目的。</p> <p>​	省略符形参应该仅仅用于C和C++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p> <h3 id="_6-3返回类型和return语句"><a href="#_6-3返回类型和return语句" class="header-anchor">#</a> 6.3返回类型和return语句</h3> <h4 id="无返回值函数"><a href="#无返回值函数" class="header-anchor">#</a> 无返回值函数</h4> <p>​	没有返回值的return语句只能用在返回类型时void的函数中。</p> <p>​	通常情况下，如果<code>void</code>函数想在其中间位置提前退出，可以使用<code>return</code>语句。</p> <p>​	一个返回类型是<code>void</code>的函数也能使用<code>return</code>语句的第二种形式，不过此时<code>return</code>语句的<code>expression</code>必须是另一个返回<code>void</code>的函数。</p> <p>​	强行令<code>void</code>函数返回其他类型的表达式将产生编译错误。</p> <h4 id="有返回值函数"><a href="#有返回值函数" class="header-anchor">#</a> 有返回值函数</h4> <p>​	return 语句的第二种形式提供了函数的结果。只要函数的返回类型不是 void，则该函数内的每条 return 语句必须返回一个值。return 语句返回值的类型必须与函数的返回类型相，或者能隐式地转换成函数的返回类型。</p> <p>​	在含有return 语句的循环后面应该也有一条 return 语句，如果没有的话该
程序就是错误的。很多编译器都无法发现此类错误。</p> <p><strong>值时如何被返回的</strong></p> <p>​	返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用一个临时量，该临时量就是函数调用的结果。</p> <p>​	如果函数返回引用类型，则该引用仅仅是它所引用对象的一个别名。</p> <p><strong>不要返回局部对象的引用或指针</strong></p> <p>​	函数不应该返回局部对象的指针或引用，因为一旦函数完成，局部对象将被释放。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 严重错误：这个函数试图返回局部对象的引用</span>
<span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">manip</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string ret<span class="token punctuation">;</span>
    <span class="token comment">// 以某种方式改变一下ret</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>   <span class="token comment">// 错误：返回局部对象的引用</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Empty&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// 错误：“Empty”是一个局部临时量</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>返回类类型的函数和调用运算符</strong></p> <p>​	和其他运算符一样，调用运算符也有优先级和结合律。如果函数返回指针、引用或类的对象，则可以使用函数调用的结果访问结果对象的成员。</p> <p><strong>引用返回左值</strong></p> <p>​	调用一个返回引用的函数会得到左值，其他返回类型得到右值。</p> <p><strong>列表初始化返回值</strong></p> <p>​	C++11规定，函数可以返回用花括号包围的值的列表。同其他返回类型一样，列表也用于初始化表示函数调用结果的临时量。如果列表为空，临时量执行值初始化；否则返回的值由函数的返回类型决定。</p> <ul><li><p>如果函数返回内置类型，则列表内最多包含一个值，且该值所占空间不应该大于目标类型的空间。</p></li> <li><p>如果函数返回类类型，由类本身定义初始值如何使用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// . . .</span>
    <span class="token comment">// expected 和 actual 是 string 对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>expected<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 返回一个空vector对象</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>expected <span class="token operator">==</span> actual<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">&quot;functionX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;okay&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 返回列表初始化的vector对象</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">&quot;functionX&quot;</span><span class="token punctuation">,</span> expected<span class="token punctuation">,</span> actual<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ul> <p><strong>主函数main的返回值</strong></p> <p>​	<code>main</code>函数可以没有<code>return</code>语句直接结束。如果控制流到达了<code>main</code>函数的结尾处并且没有<code>return</code>语句，编译器会隐式地插入一条返回0的<code>return</code>语句。</p> <p>​	<code>main</code>函数的返回值可以看作是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。</p> <p>​	为了使<code>main</code>函数的返回值与机器无关，头文件<code>cstdlib</code>定义了<code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>这两个预处理变量，分别表示执行成功和失败。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>some_failure<span class="token punctuation">)</span>
        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span> <span class="token comment">// 定义在cstdlib</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span> <span class="token comment">// 定义在cstdlib</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	建议使用预处理变量<code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>表示<code>main</code>函数的执行结果。</p> <p><strong>递归</strong></p> <p>​	如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）。</p> <p>​	在递归函数中，一定有某条路径是不包含递归调用的，否则函数会一直递归下去，直到程序栈空间耗尽为止。</p> <p>​	相对于循环迭代，递归的效率较低。但在某些情况下使用递归可以增加代码的可读性。循环迭代适合处理线性问题（如链表，每个节点有唯一前驱、唯一后	继），而递归适合处理非线性问题（如树，每个节点的前驱、后继不唯一）。</p> <p>​	<code>main</code>函数不能调用它自身。</p> <h4 id="返回数组指针"><a href="#返回数组指针" class="header-anchor">#</a> 返回数组指针</h4> <p>因为数组不能被拷贝，所以函数不能返回数组，但可以返回数组的指针或引用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span> arrT<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//arrT是一个类型的别名，它表示的类型是含有10个帧数的数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>声明一个返回数组指针的函数</strong></p> <p>​	要想在声明 func 时不使用类型别名，我们必须牢记被定义的名字后面数组的维度:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// arr 是一个含有 10 个整数的数组</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pl<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// p1是一个含有10 个指针的数组</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span><span class="token comment">// p2 是一个指针，它指向含有 10 个整数的数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>返回数组指针的函数形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">Type</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">function</span><span class="token punctuation">(</span>parameter_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>dimension<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>举个具体点的例子</p> <p><code>int (*func(int i)[10];</code></p> <ul><li><code>func(int i)</code>表示调用 func 函数时需要一个 int 类型的实参。</li> <li><code>(*func(int i))</code>意味着我们可以对函数调用的结果执行解引用操作。</li> <li><code>(*func(int i))[10]</code>表示解引用 func 的调用将得到一个大小是 10 的数组。</li> <li><code>int (*func(int i))[10]</code>表示数组中的元素是 int 类型</li></ul> <p><strong>使用尾置返回类型</strong></p> <p>​	C++11允许使用尾置返回类型简化复杂函数声明。尾置返回类型跟在形参列表后面，并以一个<code>-&gt;</code>符号开头。为了表示函数真正的返回类型在形参列表之后，需要在本应出现返回类型的地方添加<code>auto</code>关键字。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// func 接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	任何函数的定义都能使用尾置返回类型，但是这种形式更适用于返回类型比较复杂的函数。</p> <p><strong>使用decltype</strong></p> <p>​	如果我们知道函数返回的指针将指向哪个数组，就可以使用<code>decltype</code>关键字声明返回类型。但<code>decltype</code>并不会把数组类型转换成指针类型，所以还要在函数声明中添加一个<code>*</code>符号。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> odd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> even<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 返回一个指针，该指针指向含有5个整数的数组</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">arrPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>odd <span class="token operator">:</span> <span class="token operator">&amp;</span>even<span class="token punctuation">;</span>  <span class="token comment">// 返回一个指向数组的指针</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_6-4函数重载"><a href="#_6-4函数重载" class="header-anchor">#</a> 6.4函数重载</h3> <p>​	如果同一作用域内的几个函数名字相同但形参列表不同，我们称为重载函数。函数接受的形参类型不一样，当调用这些函数时，编译器会根据传递的实参类型推断想要的时哪个函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>beg， <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sizet size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用 print(const char*)</span>
<span class="token function">print</span><span class="token punctuation">(</span>j，<span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用 print(const int*, size t)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>，<span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用 print(const int*，const int*)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>main函数不能重载</p> <p><strong>定义重载函数</strong></p> <p>​	对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有要素都相同。</p> <p><strong>判断两个形参的类型是否相异</strong></p> <p>有时候两个形参列表看起来不一样，但实际上是相同的:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 每对声明的是同一个函数</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account <span class="token operator">&amp;</span>acct<span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 省略了形参的名字</span>

<span class="token keyword">typedef</span> Phone Telno<span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Telno<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Telno 和 Phone 的类型相同</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>重载和const形参</strong></p> <p>​	顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重复声明了 Record lookup(Phone)</span>

Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重复声明了 Record lookup(Phone*)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的 const 是底层的:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span>
<span class="token comment">// 定义了 4 个独立的重载函数</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 函数作用于Account 的引用</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 新函数，作用于常量引用</span>


Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 新函数，作用于指向 Account 的指针</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 新函数，作用于指向常量的指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数</p> <p><strong>const_cast和重载</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 比较两个 string 对象的长度，返回较短的那个引用</span>
<span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>sl<span class="token punctuation">,</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> sl<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> sl <span class="token operator">:</span>s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	这个函数的参数和返回类型都是 const string 的引用。我们可以对两个非常量的string 实参调用这个函数，但返回的结果仍然是 const string 的引用。因此我们需要一种新的 shorterString 函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用 const_cast 可以做到这一点:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string
<span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token generic-function"><span class="token function">cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>sl<span class="token punctuation">)</span><span class="token punctuation">,</span>
						<span class="token keyword">const</span> <span class="token generic-function"><span class="token function">cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">const</span> <span class="token generic-function"><span class="token function">cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="重载与作用域"><a href="#重载与作用域" class="header-anchor">#</a> 重载与作用域</h4> <p>​	一般来说，将函数声明置于局部作用域内不是一个明智的选择。但是为了说明作用域和重载的相互关系，我们将暂时违反这一原则而使用局部函数声明。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重载 print 函数</span>
<span class="token keyword">void</span> <span class="token function">fooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> ival<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">bool</span> read<span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">// 新作用域:隐藏了外层的 read</span>
	string s <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 错误:read 是一个布尔值，而非函数</span>
   	<span class="token comment">// 不好的习惯:通常来说，在局部作用域中声明函数不是一个好的选择</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 新作用域:隐藏了之前的 print</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Value:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment">//错误:print(const string &amp;)被隐藏掉了</span>
    <span class="token function">print</span><span class="token punctuation">(</span>ival<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正确:当前 print(int)可见</span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正确:调用 print(int);print (double)被隐藏掉了</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_6-5特殊用途语言特性"><a href="#_6-5特殊用途语言特性" class="header-anchor">#</a> 6.5特殊用途语言特性</h3> <h4 id="默认实参"><a href="#默认实参" class="header-anchor">#</a> 默认实参</h4> <p>​	某些函数有这样一种形参,在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p> <p>​	我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> string<span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">;</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz ht <span class="token operator">=</span> <span class="token number">24</span>，sz wid <span class="token operator">=</span><span class="token number">80</span>，<span class="token keyword">char</span> backgrnd <span class="token operator">=</span><span class="token char">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>使用默认实参调用函数</strong></p> <p>​	我们可以选择数量不同个实参调用函数，但是只能省略尾部的实参</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string window<span class="token punctuation">;</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//等价于screen(24,80，'')</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//等价于screen(66,80，'')</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span>，<span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	    <span class="token comment">// screen(66,256,'')</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span>，<span class="token number">256</span>，<span class="token char">'##'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// screen(66,256，'##')</span>

window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span>，，<span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		   <span class="token comment">//错误:只能省略尾部的实参</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 调用 screen('?',80，'')</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p> <p><strong>默认实参声明</strong></p> <p>​	对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次,但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//表示高度和宽度的形参没有默认值</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz<span class="token punctuation">,</span>sz<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//我们不能修改一个已经存在的默认值：</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz<span class="token punctuation">,</span>sz<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">=</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//但是可以按照如下形式添加默认实参</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>默认实参初始化</strong></p> <p>​	局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// wd、def和 ht 的声明必须出现在函数之外</span>
szwd<span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> def <span class="token operator">=</span><span class="token char">''</span><span class="token punctuation">;</span>
sz <span class="token function">ht</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz <span class="token operator">=</span> <span class="token function">ht</span><span class="token punctuation">(</span><span class="token punctuation">)</span>， sz <span class="token operator">=</span> wd<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">=</span> def<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="header-anchor">#</a> 内联函数和constexpr函数</h4> <p>​	把较小的操作定义为函数有很多的好处，但是也存在缺点。调用函数一般比求等价表达式的值要慢一些。</p> <p><strong>内联函数可以避免函数调用的开销</strong></p> <p>​	将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开</p> <p>​	在函数的返回类型前面加上关键字 inline,这样就可以将它声明成内联函数了</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 内联版本:寻找两个 string 对象中较短的那个</span>
<span class="token keyword">inline</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>
<span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>sl<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> sl<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> sl <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p> <p>​	一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数。</p> <p><a href="https://www.runoob.com/cplusplus/C++-inline-functions.html" target="_blank" rel="noopener noreferrer">C++ 内联函数 | 菜鸟教程 (runoob.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（注意看下方的评论）</p> <p><strong>constexpr函数</strong></p> <p>​	<code>constexpr</code>函数是指能用于常量表达式的函数。<code>constexpr</code>函数的返回类型及所有形参的类型都得是字面值类型。另外C++11标准要求<code>constexpr</code>函数体中必须有且只有一条<code>return</code>语句，但是此限制在C++14标准中被删除。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ok: foo是一个常量表达式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>constexpr</code>函数的返回值可以不是一个常量。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 如果 arg 是常量表达式，则 scale(arg)也是常量表达式</span>
<span class="token keyword">constexpr</span> size_t <span class="token function">scale</span><span class="token punctuation">(</span>size_t cnt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// ok: scale(2)是常量表达式</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment">// i不是常量表达式</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 错误：scale(i)不是常量表达式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>constexpr</code>函数被隐式地指定为内联函数。</p> <p><a href="https://blog.csdn.net/hou09tian/article/details/110470363" target="_blank" rel="noopener noreferrer">C++中constexpr函数-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>把内联函数和constexpr 函数放在头文件内</strong></p> <p>​	和其他函数不同，内联函数和<code>constexpr</code>函数可以在程序中多次定义。因为在编译过程中，编译器需要函数的定义来随时展开函数。对于某个给定的内联函数或<code>constexpr</code>函数，它的多个定义必须完全一致。因此内联函数和<code>constexpr</code>函数通常定义在头文件中。</p> <h4 id="调试帮助"><a href="#调试帮助" class="header-anchor">#</a> 调试帮助</h4> <p><strong>assert预处理宏</strong></p> <p>​	<code>assert</code>是一种预处理宏。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">assert</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//对expr求值，若为假assert输出信息并终止程序执行，如果为真assert什么都不做</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	在实际编程的过程中，即使我们没有包含<code>cassert</code>头文件，也最好不要为了其他目的使用<code>assert</code>。很多头文件都包含了<code>cassert</code>，这就意味着即使你没有直接包含<code>cassert</code>，它也很有可能通过其他途径包含在你的程序中。</p> <p><strong>NDEBUG预处理变量</strong></p> <p>​	<code>assert</code>的行为依赖于一个名为<code>NDEBUG</code>的预处理变量的状态。如果定义了 NDEBUG,则assert 什么也不做。默认状态下没有定义NDEBUG,此时 assert 将执行运行时检查。
​	我们可以使用一个<code>##define</code> 语句定义 <code>NDEBUG</code>，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p> <p>​	除了用于<code>assert</code> 外，也可以使用 <code>NDEBUG</code>编写自己的条件调试代码。如果 <code>NDEBUG</code>未定义，将执行<code>##ifndef</code> 和<code>##endif</code> 之间的代码:如果定义了<code>NDEBUG</code>，这些代码将被忽略掉:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span>， size t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
##ifndef NDEBUG
    <span class="token comment">//__func__是编译器定义的一个局部静态变量，用于存放函数的名字</span>
    cerr <span class="token operator">&lt;&lt;</span> <span class="token constant">__func__</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;: array size is &quot;</span> <span class="token operator">&lt;&lt;</span> size <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

##endif
<span class="token comment">//...</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	除了 C++编译器定义的<code>__func__</code>之外，预处理器还定义了另外4个对于程序调试很有用的名字:</p> <table><thead><tr><th>变量名称</th> <th>内容</th></tr></thead> <tbody><tr><td><code>__func__</code></td> <td>当前函数名称</td></tr> <tr><td><code>__FILE__</code></td> <td>当前文件名称</td></tr> <tr><td><code>__LINE__</code></td> <td>当前行号</td></tr> <tr><td><code>__TIME__</code></td> <td>文件编译时间</td></tr> <tr><td><code>__DATE__</code></td> <td>文件编译日期</td></tr></tbody></table> <h3 id="_6-6函数匹配"><a href="#_6-6函数匹配" class="header-anchor">#</a> 6.6函数匹配</h3> <p><strong>确定候选函数和可行函数</strong></p> <p>​	函数实参类型与形参类型越接近，它们匹配得越好。</p> <p>​	重载函数集中的函数称为候选函数。</p> <p>​	可行函数的形参数量与函数调用所提供的实参数量相等，并且每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p> <p>​	调用重载函数时应该尽量避免强制类型转换。</p> <h4 id="实参类型转换"><a href="#实参类型转换" class="header-anchor">#</a> 实参类型转换</h4> <p>​	为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示:</p> <ol><li>精确匹配，包括以下情况:</li></ol> <ul><li><p>实参类型和形参类型相同。</p></li> <li><p>实参从数组类型或函数类型转换成对应的指针类型</p></li> <li><p>向实参添加顶层 const 或者从实参中删除顶层 const。</p></li></ul> <ol start="2"><li>通过 const 转换实现的匹配。</li> <li>通过类型提升实现的匹配。</li> <li>通过算术类型转换或指针转换实现的匹配。</li> <li>通过类类型转换实现的匹配</li></ol> <p><strong>需要类型提升和算术类型转换的匹配</strong></p> <p>​	所有算术类型转换的级别都一样</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">ff</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// char 提升成 int;调用 f(int)</span>

<span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">manip</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 错误:二义性调用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>函数匹配和const 实参</strong></p> <p>​	如果载函数的区别在于它们的引用或指针类型的形参是否含有底层<code>const</code>，则调用发生时编译器通过实参是否是常量来决定函数的版本。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Record <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 函数的参数是Account的引用</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 函数的参数是一个常量引用</span>

<span class="token keyword">const</span> Account a<span class="token punctuation">;</span>
Account b<span class="token punctuation">;</span>

<span class="token function">lookup</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用lookup(const Account&amp;)</span>
<span class="token function">lookup</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用lookup(Account&amp;)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_6-7函数指针"><a href="#_6-7函数指针" class="header-anchor">#</a> 6.7函数指针</h3> <p>​	要想声明一个可以指向某种函数的指针，只需要用指针替换函数名称即可。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 比较两个string对象的长度</span>
<span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// pf指向一个函数，该函数的参数是两个const string的引用</span>
<span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未初始化</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>使用函数指针</strong></p> <p>​	可以直接使用指向函数的指针来调用函数，无须提前解引用指针。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span> <span class="token comment">// pf指向名为lengthCompare的函数</span>
pf <span class="token operator">=</span> <span class="token operator">&amp;</span>lengthCompare<span class="token punctuation">;</span> <span class="token comment">// 等价的赋值语句：取地址符是可选的 </span>

<span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;goodbye&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//调用lengthCompare</span>
<span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;goodbye&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//一个等价调用</span>
<span class="token keyword">bool</span> b3 <span class="token operator">=</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;goodbye&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//另一个等价调用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>重载函数指针</strong></p> <p>​	对于重载函数，编译器通过指针类型决定函数版本，指针类型必须与重载函数中的某一个精确匹配。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> ff<span class="token punctuation">;</span> <span class="token comment">// pf1指向ff(unsigned)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>函数指针形参</strong></p> <p>​	可以把函数的形参定义成指向函数的指针。调用时允许直接把函数名当作实参使用，它会自动转换成指针。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 第三个形参是函数类型，它会自动地转换成指向函数的指针</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span> 
				<span class="token keyword">bool</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价的声明:显式地将形参定义成指向函数的指针</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span> 					
<span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 自动将函数 lengthCompare 转换成指向该函数的指针</span>
<span class="token function">useBigger</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> lengthCompare<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	关键字<code>decltype</code>作用于函数时，返回的是函数类型，而不是函数指针类型，所以只用在结果前面加上*才能得到指针。</p> <p><strong>返回指向函数的指针</strong></p> <p>​	函数可以返回指向函数的指针。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型。</p> <p><strong>将auto 和 decltype 用于函数指针类型</strong></p> <p>​	它返回函数类型而非指针类型。因此，我们显式地加上*以表明我们需要返回指针，而非函数本身。</p> <h2 id="第七章-类"><a href="#第七章-类" class="header-anchor">#</a> 第七章 类</h2> <p>​	类的基本思想是数据抽象和封装。数据抽象是一种依赖接口和实现的分离的编程技术。类要想实现数据的抽象和封装，需要首先定义一个抽象数据类型。</p> <h3 id="_7-1定义抽象数据类型"><a href="#_7-1定义抽象数据类型" class="header-anchor">#</a> 7.1定义抽象数据类型</h3> <h4 id="设计sales-data类"><a href="#设计sales-data类" class="header-anchor">#</a> 设计Sales_data类</h4> <p>​	类的用户是程序员，而非应用程序的最终使用者。C++程序员们无须刻意区分应用程序的用户以及类的用户。</p> <h4 id="定义改进的sales-data类"><a href="#定义改进的sales-data类" class="header-anchor">#</a> 定义改进的Sales_data类</h4> <p>​	定义个声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的<code>inline</code>函数。</p> <p><strong>定义成员函数</strong></p> <p>​	尽管所有成员必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。</p> <p><strong>引入this</strong></p> <p>​	成员函数通过一个名为<code>this</code>的额外的隐式参数来访问调用它的哪个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>total<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 伪代码，用于说明调用成员函数的实际执行过程</span>
<span class="token comment">// 调用Sales_data的isbn成员时传入了total的地址</span>
<span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>total<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	任何对类成员的直接访问都被看作<code>this</code>的隐式引用。<code>this</code>形参时隐式定义。任何自定义名为<code>this</code>的参数或变量的行为都是非法的。我们可以在成员函数体内使用<code>this</code>，尽管没有必要，但我们还是能把<code>isbn</code>定义为一下形式</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 两者表示的含义相同</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>bookNo<span class="token punctuation">;</span> <span class="token punctuation">}</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> bookNo<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	因为 <code>this</code> 的目的总是指向“这个”对象，所以 <code>this</code> 是一个常量指针，我们不允许改变 <code>this</code> 中保存的地址。</p> <p><strong>引入const成员函数</strong></p> <p>​	<code>isbn</code> 函数的另一个关键之处是紧随参数列表之后的 <code>const</code> 关键字，这里，<code>const</code>的作用是修改隐式 <code>this</code> 指针的类型。默认情况下,<code>this</code>的类型是指向类类型非常量版本的常量指针。尽管 <code>this</code> 是隐式的，但它仍然需要遵循初始化规则，意味着(在默认情况下)我们不能把 <code>this</code> 绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。</p> <p>​	C++语言中应许把<code>const</code>关键字放在成员函数的参数列表之后此时，紧跟在参数列表后面的 <code>const</code> 表示 <code>this</code> 是一个指向常量的指针。像这样使用<code>const</code> 的成员函数被称作常量成员函数</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 伪代码，说明隐式的 this 指针是如何使用的</span>
<span class="token comment">// 下面的代码是非法的:因为我们不能显式地定义自己的 this 指针</span>
<span class="token comment">// 谨记此处的 this 是一个指向常量的指针，因为 isbn 是一个常量成员</span>
std<span class="token double-colon punctuation">::</span>string <span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">*</span><span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>isbn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	因为 <code>this</code> 是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，<code>isbn</code> 可以读取调用它的对象的数据成员，但是不能写入新值。</p> <p>​	常量对象和指向常量对象的引用或指针都只能调用常量成员函数。</p> <p><strong>类作用域和成员函数</strong></p> <p>​	编译器分两步处理类:首先编译成员的声明，然后才轮到成员函数体(如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p> <p><strong>在类的外部定义的成员函数</strong></p> <p>​	在类的外部定义成员函数时，成员函数的定义必须与它的声明相匹配。如果成员函数被声明为常量成员函数，那么它的定义也必须在参数列表后面指定<code>const</code>属性。同时，类外部定义的成员名字必须包含它所属的类名。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">double</span> <span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>units_sold<span class="token punctuation">)</span>
        <span class="token keyword">return</span> revenue <span class="token operator">/</span> units_sold<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>定义一个返回this对象的函数</strong></p> <p>​	可以定义返回<code>this</code>对象的成员函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Sales_data<span class="token operator">&amp;</span> <span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    units_sold <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>   <span class="token comment">// 把 rhs 的成员加到 this 对象的成员上</span>
    revenue <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span> 
    <span class="token comment">//我们无须使用隐式的 this 指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问:</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>       <span class="token comment">// 返回调用该函数的对象</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="header-anchor">#</a> 定义类相关的非成员函数</h4> <p>​	类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。</p> <p>​	一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p> <p><a href="https://blog.csdn.net/no_O_ac/article/details/104213792" target="_blank" rel="noopener noreferrer">C++ 类：类相关的非成员函数、构造函数_C++ 非成员函数-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.cnblogs.com/muchen/p/6353793.html" target="_blank" rel="noopener noreferrer">第十三篇：成员函数与非成员函数的选择 - 穆晨 - 博客园 (cnblogs.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h4> <p>​	每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p> <p>​	构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型;除此之外类似于其他的函数，构造函数也有一个(可能为空的) 参数列表和一个(可能为空的)函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。</p> <p>​	不同于其他成员函数，构造函数不能被声明成 const 的。但是，构造函数在 const 对象的构造过程中可以向其写值。</p> <p><strong>合成的默认构造函数</strong></p> <p>​	类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数。默认构造函数无须任何实参。</p> <p>​	如果我们的类没有显式地定义构造函数，那么编译器会为我们隐式的定义一个默认构造函数。</p> <p>​	对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：</p> <ul><li>如果存在类内的初始值，用它来初始化成员</li> <li>否则，默认初始化该成员</li></ul> <p><strong>某些类不能依赖于合成的默认构造函数</strong></p> <p>​	对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：</p> <ol><li>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。</li> <li>如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。</li> <li>编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。</li></ol> <p><strong>= default 的含义</strong></p> <p>​	在C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加<code>=default</code>来要求编译器生成构造函数。其中<code>=default</code>既可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果<code>=default</code>在类的内部，则默认构造函数是内联的。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>构造函数初始值列表</strong></p> <p>​	 冒号后的部分被称为构造函数初始值列表，它负责为新创建的对象的一个或几个数据成员赋初始值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> p<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>p<span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 与上面定义的那个构造函数效果相同（第一个）</span>
<span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p> <p><strong>在类的外部定义构造函数</strong></p> <p><a href="https://deepinout.com/C++/C++-questions/g_how-to-define-the-constructor-outside-the-class-in-C++.html" target="_blank" rel="noopener noreferrer">如何在C++中定义类外的构造函数？|极客笔记 (deepinout.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="header-anchor">#</a> 拷贝、赋值和析构</h4> <p>​	编译器能合成拷贝、赋值和析构函数，但是对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。</p> <p>​	在学习第 13 章关于如何自定义操作的知识之前，类中所有分配的资源都应该直接以类的数据成员的形式存储。</p> <h3 id="_7-2访问控制与封装"><a href="#_7-2访问控制与封装" class="header-anchor">#</a> 7.2访问控制与封装</h3> <p>​	在C++中，我们使用访问说明符加强类的封装性：</p> <ul><li>定义在<code>public</code>说明符之后的成员在整个程序内都可以被访问。<code>public</code>成员定义类的接口。</li> <li>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。<code>private</code>部分封装了类的实现细节。</li></ul> <p>​	每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现在下一个访问说明符或者到达类的结尾处为止。</p> <p><strong>使用class或struct关键字</strong></p> <p>​	如果我们使用 <code>struct</code> 关键字,则定义在第一个访问说明符之前的成员是 <code>public</code>的;相反，如果我们使用 <code>class</code> 关键字，则这些成员是 <code>private</code> 的。</p> <h4 id="友元"><a href="#友元" class="header-anchor">#</a> 友元</h4> <p>​	类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元 (<code>friend</code>)。如果类想把一个函数作为它的友元，只需要增加一条以 <code>friend</code> 关键字开始的函数声明语句即可:</p> <p>​	友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。但是，一般来说，最好在类定义开始或结束前的位置集中声明友元。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 为Sales_data的非成员函数所做的友元声明</span>
    <span class="token keyword">friend</span> Sales_data <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream<span class="token operator">&amp;</span><span class="token punctuation">,</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 其他成员及访问说明符与之前一致</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> p<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>p<span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> bookNo<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    Sales_data <span class="token operator">&amp;</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Sales_data接口的非成员组成部分的声明</span>
Sales_data <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream<span class="token operator">&amp;</span><span class="token punctuation">,</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>封装的好处：</p> <ul><li>确保用户代码不会无意间破坏封装对象的状态。</li> <li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</li></ul> <p><strong>友元的声明</strong></p> <p>​	友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。如果希望类的用户能调用某个友元函数，就必须在友元声明之外再专门对函数进行一次声明（部分编译器没有该限制）。</p> <p>​	为了使友元对类的用户可见，通常会把友元的声明（类的外部）与类本身放在同一个头文件中。</p> <h3 id="_7-3类的其他特性"><a href="#_7-3类的其他特性" class="header-anchor">#</a> 7.3类的其他特性</h3> <h4 id="类成员再探"><a href="#类成员再探" class="header-anchor">#</a> 类成员再探</h4> <p><strong>定义一个类型成员</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span> <span class="token punctuation">(</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type pos<span class="token punctuation">;</span>
     <span class="token keyword">using</span> pos <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type<span class="token punctuation">;</span><span class="token comment">//上下两种含义相同，都是取了别名</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	pos cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	pos height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>width <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>string contents<span class="token punctuation">;</span>
<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>Screen类的成员函数</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size type pos<span class="token punctuation">;</span>
    <span class="token function">Screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 因为 Screen 有另一个构造函数</span>
    				  <span class="token comment">// 所以本函数是必需的</span>
    <span class="token comment">// cursor 被其类内初始值初始化为 0</span>
    <span class="token function">Screen</span><span class="token punctuation">(</span>pos ht，pos wd<span class="token punctuation">,</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">height</span><span class="token punctuation">(</span>ht<span class="token punctuation">)</span>， <span class="token function">width</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">contents</span><span class="token punctuation">(</span>ht <span class="token operator">*</span> wd，c<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>   <span class="token comment">// 读取光标处的字符 </span>
    	<span class="token punctuation">{</span><span class="token keyword">return</span> contents<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//隐式内联</span>
    <span class="token keyword">inline</span> <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span>pos ht，pos wd<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">//显式内联</span>
    Screen <span class="token operator">&amp;</span><span class="token function">move</span><span class="token punctuation">(</span>pos r，pos c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 能在之后被设为内联  </span>
<span class="token keyword">private</span><span class="token operator">:</span>
    pos cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pos height <span class="token operator">=</span> <span class="token number">0</span>，width <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string contents<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>令成员作为内联函数</strong></p> <p>​	最好只在类外部定义的地方说明<code>inline</code>，这样可以时类更容易理解。</p> <p>​	inline成员函数也应该与相对应的类定义在同一个头文件中。</p> <p><strong>重载成员函数</strong></p> <p>​	和非成员函数一样，成员函数也可以被重载，只要函数之在参数的数量和/或类型上有所区别就行。成员函数的函数匹配过程同样与非成员函数非常类似。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Screen myscreen<span class="token punctuation">;</span>
<span class="token keyword">char</span> ch <span class="token operator">=</span> myscreen<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用 Screen::get()</span>
ch <span class="token operator">=</span> myscreen<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用 Screen::get(pos，pos)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>可变数据成员</strong></p> <p>​	改变某个数据成员，我们可以通过在变量的声明中加入<code>mutable</code>关键字做到这一点（即使是一个<code>const</code>成员函数）。</p> <p>​	一个可变数据成员永远不会是<code>const</code>，即使它时<code>const</code>对象的成员。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">some_member</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">mutable</span> size_t access_ctr<span class="token punctuation">;</span>  <span class="token comment">// 即使在一个const对象内也可以被修改</span>
    <span class="token comment">// 其他成员与之前的版本一致</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">some_member</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token operator">++</span>access_ctr<span class="token punctuation">;</span>   <span class="token comment">// 保存一个计数值，用于记录成员函数被调用的次数</span>
    <span class="token comment">// 该成员需要完成的其他工作</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>类数据成员的初始值</strong></p> <p>​	提供类内初始值时，必须使用<code>=</code>或花括号形式。</p> <h4 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="header-anchor">#</a> 返回*this的成员函数</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Screen <span class="token operator">&amp;</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Screen <span class="token operator">&amp;</span><span class="token function">set</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 其他成员和之前的版本一致</span>
<span class="token punctuation">}</span>；
<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span><span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    contents<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment">// 设置当前光标所在位置的新值</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>		<span class="token comment">// 将 this 对象作为左值返回</span>
<span class="token punctuation">}</span>
<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span>Screen<span class="token operator">:</span><span class="token function">set</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos col<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    contents<span class="token punctuation">[</span>r<span class="token operator">*</span>width <span class="token operator">+</span> col<span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span><span class="token comment">//设置给定位置的新值</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                <span class="token comment">//将this 对象作为左值返回</span>
<span class="token punctuation">}</span>

<span class="token comment">// 把光标移动到一个指定位置，然后设置该位置的字符值</span>
myScreen<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token char">'##'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>从const成员函数返回*this</strong></p> <p>​	一个 <code>const</code> 成员函数如果以引用的形式返回<code>*this</code>，那么它的返回类型将是常量引用。</p> <p><strong>基于const的重载</strong></p> <p>​	<code>const</code>成员函数如果以引用形式返回<code>*this</code>，则返回类型是常量引用。</p> <p>​	通过区分成员函数是否为<code>const</code>的，可以对其进行重载。在常量对象上只能调用<code>const</code>版本的函数；在非常量对象上，尽管两个版本都能调用，但会选择非常量版本。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 根据对象是否是 const 重载了 display 函数</span>
    Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token function">do_display</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">const</span> Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span> <span class="token function">do_display</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">// 该函数负责显示 Screen 的内容</span>
    <span class="token keyword">void</span> <span class="token function">do_display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span> os <span class="token operator">&lt;&lt;</span> contents<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// 其他成员与之前的版本一致</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Screen <span class="token function">myScreen</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> Screen <span class="token function">blank</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myScreen<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token char">'##'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用非常量版本</span>
blank<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用常量版本</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="类类型"><a href="#类类型" class="header-anchor">#</a> 类类型</h4> <p>​	即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和其他任何类(或者任何其他作用域)的成员都不是一回事儿</p> <p>​	我们可以把类名作为类型的名字使用，从而直接指向类类型</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Sales data iteml<span class="token punctuation">;</span><span class="token comment">// 默认初始化 Sales data 类型的对象</span>
<span class="token keyword">class</span> <span class="token class-name">Sales</span> data iteml<span class="token punctuation">;</span><span class="token comment">// 一条等价的声明</span>
<span class="token comment">// 后者C风格，在C++语言中也是合法的</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>类的声明</strong></p> <p>​	可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明，用于引入类的名字。在类声明之后定义之前都是一个不完全类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">;</span>   <span class="token comment">// Screen类的声明</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以定义指向不完全类型的指针或引用，也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。</p> <p>只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Link_screen</span>
<span class="token punctuation">{</span>
    Screen window<span class="token punctuation">;</span>
    Link_screen <span class="token operator">*</span>next<span class="token punctuation">;</span>
    Link_screen <span class="token operator">*</span>prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>练习7.31：定义一对类X和Y，其中X包含一个指向Y的指针，而Y包含一个类型为X的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
	Y<span class="token operator">*</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Y</span>
<span class="token punctuation">{</span>
	X x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>友元再探</strong></p> <p>除了普通函数，类还可以把其他类或其他类的成员函数声明为友元。友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Window_mgr 的成员可以访问 Screen 类的私有部分</span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Window_mgr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	每个类负责控制自己的友元类或友元函数</p> <p><strong>令成员函数作为友元</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Window_mgr::clear 必须在Screen类之前被声明</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token class-name">Window_mgr</span><span class="token double-colon punctuation">::</span><span class="token function">clear</span><span class="token punctuation">(</span>ScreenIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序:</p> <ul><li>首先定义 window mgr 类，其中声明 clear 函数，但是不能定义它。在 clear使用 Screen的成员之前必须先声明 Screen。</li> <li>接下来定义 screen，包括对于 clear 的友元声明</li> <li>最后定义clear，此时它才可以使用 Screen 的成员。</li></ul> <p><strong>函数重载和友元</strong></p> <p>​	尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。</p> <p><strong>友元声明和作用域</strong></p> <p>​	友元函数可以直接定义在类的内部，这种函数是隐式内联的。但是必须在类外部提供相应声明令函数可见。</p> <p>​	即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*友元函数可以定义在类的内部 */</span> <span class="token punctuation">}</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token comment">// 错误：f没有被声明</span>
    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token comment">// 错误：f没有被声明</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   				<span class="token comment">// 声明那个定义在x中的函数</span>
<span class="token keyword">void</span> <span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token comment">// 正确：现在f的声明在作用域中了</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_7-4类的作用域"><a href="#_7-4类的作用域" class="header-anchor">#</a> 7.4类的作用域</h3> <p>​	每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对
象、引用或者指针使用成员访问运算符来访问。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Screen<span class="token double-colon punctuation">::</span>pos ht <span class="token operator">=</span> <span class="token number">24</span>， wd <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>	<span class="token comment">// 使用 Screen 定义的 pos 类型</span>
Screen <span class="token function">scr</span><span class="token punctuation">(</span>ht，wd，<span class="token char">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Screen <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>scr<span class="token punctuation">;</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> scr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 访问 scr 对象的 get 成员</span>
c <span class="token operator">=</span> P<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 访问p所指对象的 get 成员</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>作用域和定义在类外部的成员</strong></p> <p>​	当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Window_mgr</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 向窗口添加一个Screen，返回它的编号</span>
    ScreenIndex <span class="token function">addScreen</span><span class="token punctuation">(</span><span class="token keyword">const</span> Screen<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 首先处理返回类型，之后我们才进入Window_mgr的作用域</span>
Window_mgr<span class="token double-colon punctuation">::</span>ScreenIndex <span class="token class-name">Window_mgr</span><span class="token double-colon punctuation">::</span><span class="token function">addScreen</span><span class="token punctuation">(</span><span class="token keyword">const</span> Screen <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    screens<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> screens<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="header-anchor">#</a> 名字查找与类的作用域</h4> <p>​	学习至目前为止，名字查找的过程比较直截了当：</p> <ul><li>首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。</li> <li>如果没找到，继续查找外层作用域。</li> <li>如果最终没有找到匹配的声明，则程序报错。</li></ul> <p>​	对于定义在类中的成员函数分为两步处理</p> <ul><li>首先，编译成员的声明</li> <li>直到类全部可见后才编译函数体</li></ul> <p>​	编译器处理完类中的全部声明后才会处理成员函数的定义</p> <p><strong>用于类成员声明的名字查找</strong></p> <p>​	编辑器会现在类中寻找，若是寻找不到会在成员函数前进行查找。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">double</span> Money<span class="token punctuation">;</span>
string bal<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	Money <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> bal<span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Money bal<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	编译器会先在<code>Accout</code>类中查找<code>Money</code>，若没有找到才会去<code>balance</code>上面找，并找到<code>typedef</code>定义的<code>Money</code>。</p> <p><strong>类型名要特殊处理</strong></p> <p>​	一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">double</span> Money<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	Money <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> bal<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// 使用外层作用域的 Money</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> <span class="token keyword">double</span> Money<span class="token punctuation">;</span><span class="token comment">//错误:不能重新定义 Money</span>
	Money bal<span class="token punctuation">;</span>
<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。</p> <p><strong>成员定义中的普通块作用域的名字查找</strong></p> <p>成员函数中使用的名字按照如下方式解析:</p> <ul><li>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。</li> <li>如果在成员函数内没有找到，则在类内继续查找,这时类的所有成员都可以被考虑。</li> <li>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 注意:这段代码仅为了说明而用，不是一段很好的代码</span>
<span class="token comment">// 通常情况下不建议为参数和成员使用同样的名字</span>
<span class="token keyword">int</span> height<span class="token punctuation">;</span>   <span class="token comment">// 定义了一个名字，稍后将在 Screen 中使用</span>
<span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type pos<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">dummy_fcn</span><span class="token punctuation">(</span>pos height<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cursor <span class="token operator">=</span> width <span class="token operator">*</span> height<span class="token punctuation">;</span>  <span class="token comment">// 哪个height?是那个参数</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    pos cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pos height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> width <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 注意：在此例子中隐藏了同名的成员</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>可以通过作用域运算符<code>::</code>或显式<code>this</code>指针来强制访问被隐藏的类成员。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 不建议的写法:成员函数中的名字不应该隐藏同名的成员</span>
<span class="token keyword">void</span> <span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">dummy_fcn</span><span class="token punctuation">(</span>pos height<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cursor <span class="token operator">=</span> width <span class="token operator">*</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>height<span class="token punctuation">;</span>  <span class="token comment">// 成员 height</span>
    <span class="token comment">// 另外一种表示该成员的方式</span>
    cursor <span class="token operator">=</span> width <span class="token operator">*</span> Screen<span class="token double-colon punctuation">::</span>height<span class="token punctuation">;</span>  <span class="token comment">// 成员 height</span>
<span class="token punctuation">}</span>

<span class="token comment">// 建议的写法:不要把成员名字作为参数或其他局部变量使用</span>
<span class="token keyword">void</span> <span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">dummy_fcn</span><span class="token punctuation">(</span>pos ht<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cursor <span class="token operator">=</span> width <span class="token operator">*</span> height<span class="token punctuation">;</span>  <span class="token comment">// member height</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_7-5构造函数再探"><a href="#_7-5构造函数再探" class="header-anchor">#</a> 7.5构造函数再探</h3> <h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="header-anchor">#</a> 构造函数初始值列表</h4> <p>​	构造函数是否进行列表初始化这一区别带来的深层影响完全依赖于数据成员的类型。</p> <p><strong>构造函数的初始值有时必不可少</strong></p> <p>​	如果成员是 <code>const</code>、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。</p> <p>建议:使用构造函数初始值</p> <ul><li>在很多类中，初始化和赋值的区别事关底层效率问题:前者直接初始化数据成员后者则先初始化再赋值。</li> <li>除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。</li></ul> <p><strong>成员初始化的顺序</strong></p> <p>​	构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。</p> <p>​	一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">(</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// 未定义的:i在之前被初始化</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">j</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>，<span class="token function">i</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>；<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。</p> <p><strong>默认实参和构造函数</strong></p> <p>​	如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 定义默认构造函数，令其与只接受一个 string 实参的构造函数功能相同</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> cnt<span class="token punctuation">,</span> <span class="token keyword">double</span> rev<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>rev<span class="token operator">*</span>cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">read</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="委托构造函数"><a href="#委托构造函数" class="header-anchor">#</a> 委托构造函数</h4> <p>​	C++11 新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Sales</span> data
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 非委托构造函数使用对应的实参初始化成员</span>
	Sales <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">,</span><span class="token keyword">unsigned</span> cnt<span class="token punctuation">,</span> <span class="token keyword">double</span> price<span class="token punctuation">)</span><span class="token operator">:</span>
		<span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>units <span class="token function">sold</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>cnt<span class="token operator">*</span>price<span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token comment">// 其余构造函数全都委托给另一个构造函数</span>
    Sales <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Sales <span class="token function">data</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    Sales <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">)</span><span class="token operator">:</span> Sales <span class="token function">data</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span>
    Sales <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token operator">:</span> Sales <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span><span class="token function">read</span><span class="token punctuation">(</span>is，<span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="header-anchor">#</a> 默认构造函数的作用</h4> <p>​	当对象被默认初始化或值初始化时会自动执行默认构造函数。</p> <p>​	默认初始化的发生情况：</p> <ul><li>在块作用域内不使用初始值定义非静态变量或数组。</li> <li>类本身含有类类型的成员且使用合成默认构造函数。</li> <li>类类型的成员没有在构造函数初始值列表中显式初始化。</li></ul> <p>​	值初始化的发生情况：</p> <ul><li>数组初始化时提供的初始值数量少于数组大小。</li> <li>不使用初始值定义局部静态变量。</li> <li>通过<code>T()</code>形式（<code>T</code>为类型）的表达式显式地请求值初始化。</li></ul> <p>​	在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数</p> <p><strong>使用默认构造函数</strong></p> <p>​	如果想定义一个使用默认构造函数进行初始化的对象，应该去掉对象名后的空括号对。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Sales_data <span class="token function">obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 声明了一个函数而非对象</span>
Sales_data obj2<span class="token punctuation">;</span>    <span class="token comment">// obj2是一个对象而被函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="header-anchor">#</a> 隐式的类类型转换</h4> <p>​	如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string null_book <span class="token operator">=</span> <span class="token string">&quot;9-999-99999-9&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 构造一个临时的Sales_data对象</span>
<span class="token comment">// 该对象的units_sold和revenue等于0，bookNo等于bull_book</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>null_book<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>只允许一步类类型转换</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 错误:需要用户定义的两种转换:</span>
<span class="token comment">//   (1) 把“9-999-99999-9”转换成 string</span>
<span class="token comment">//   (2) 再把这个(临时的)string 转换成 Sales data</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token string">&quot;9-999-99999-9&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确:显式地转换成 string，隐式地转换成 Sales_data</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;9-999-99999-9&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确:隐式地转换成 string，显式地转换成 Sales_data</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token string">&quot;9-999-99999-9&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>类类型转换不是总有效</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 使用 istream 构造函数创建一个函数传递给 combine</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	这段代码隐式地把 <code>cin</code> 转换成 <code>Sales_data</code>，这个转换执行了接受一个 <code>istream</code> 的<code>Sales_data</code> 构造函数。该构造函数通过读取标准输入创建了一个(临时的)<code>Sales_data</code>对象，随后将得到的对象传递给 <code>combine</code>。</p> <p><strong>抑制构造函数定义的隐式转换</strong></p> <p>​	在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为 <code>explicit</code> 加以阻止</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Sales</span> data
<span class="token keyword">public</span><span class="token operator">:</span>
    Sales <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    Sales <span class="token function">data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s，<span class="token keyword">unsigned</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> p<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>， units <span class="token function">sold</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>， <span class="token function">revenue</span><span class="token punctuation">(</span>p<span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">explicit</span> Sales <span class="token function">data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token punctuation">;</span><span class="token operator">:</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">explicit</span> Sales <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istreams<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	<code>explicit</code>关键字只对接受一个实参的构造函数有效。</p> <p>​	只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外定义时不能重复。</p> <p><strong>explicit构造函数只能用于直接初始化</strong></p> <p>​	执行拷贝初始化时（使用<code>=</code>）会发生隐式转换，所以<code>explicit</code>构造函数只能用于直接初始化。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Sales_data <span class="token function">item1</span> <span class="token punctuation">(</span>null_book<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确:直接初始化</span>
<span class="token comment">// 错误:不能将 explicit 构造函数用于拷贝形式的初始化过程</span>
Sales_data item2 <span class="token operator">=</span> null_book<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>为转换显式地使用构造函数</strong></p> <p>可以使用<code>explicit</code>构造函数显式地强制转换类型。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 正确:实参是一个显式构造的 Sales data 对象</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token function">Sales_data</span><span class="token punctuation">(</span>null_book<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确:static cast 可以使用 explicit 的构造函数</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Sales_data<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>标准库中含有显式构造函数的类</strong></p> <p>我们用过的一些标准库中的类含有单参数的构造函数:</p> <ul><li>接受一个单参数的 const char*的 string 构造函数不是 explicit 的。</li> <li>接受一个容量参数的 vector 构造函数是explicit 的。</li></ul> <h4 id="聚合类"><a href="#聚合类" class="header-anchor">#</a> 聚合类</h4> <p>​	聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的:</p> <ul><li>所有成员都是<code>public</code>的。</li> <li>没有定义任何构造函数。</li> <li>没有类内初始值。</li> <li>没有基类。</li> <li>没有虚函数。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Data</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ival<span class="token punctuation">;</span>
    string s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// val1.ival = 0; val1.s = string(&quot;Anna&quot;)</span>
Data val1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;Anna&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 错误:不能使用”Anna&quot;初始化ival，也不能使用1024初始化s</span>
Data val2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Anna&quot;</span> ，<span class="token number">1024</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="字面值常量类"><a href="#字面值常量类" class="header-anchor">#</a> 字面值常量类</h4> <p>​	字面值类型的类可能含有 <code>constexpr</code> 函数成员。这样的成员必须符合 <code>constexpr</code> 函数的所有要求，它们是隐式 <code>const</code> 的。</p> <p>​	数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类:</p> <ul><li>数据成员都是字面值类型。</li> <li>类至少含有一个<code>constexpr</code>构造函数。</li> <li>如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li> <li>类必须使用析构函数的默认定义。</li></ul> <p><strong>constexpr 构造函数</strong></p> <p>​	构造函数不能是<code>const</code>的，但是字面值常量类的构造函数可以是<code>constexpr</code>。</p> <p>​	<code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型。综合以上可知，<code>constexpr</code>构造函数体一般来说应该是空的</p> <p>​	<code>constexpr</code>构造函数必须初始化所有数据成员，初始值使用<code>constexpr</code>构造函数或常量表达式。</p> <h3 id="_7-6类的静态成员"><a href="#_7-6类的静态成员" class="header-anchor">#</a> 7.6类的静态成员</h3> <p><strong>声明静态成员</strong></p> <p>​	我们通过在成员的声明之前加上关键字 <code>static</code> 使得其与类关联在一起</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> amount <span class="token operator">+=</span> amount <span class="token operator">*</span> interestRate<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> interestRate<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string owner<span class="token punctuation">;</span>
    <span class="token keyword">double</span> amount<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">double</span> interestRate<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">initRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​	静态成员函数也不与任何对象绑定在一起，它们不包含 <code>this</code> 指针。作为结果，静态成员函数不能声明成 <code>const</code> 的，而且我们也不能在 <code>static</code> 函数体内使用 <code>this</code>指针。这一限制既适用于 <code>this</code> 的显式使用，也对调用非静态成员的隐式使用有效。</p> <p><strong>使用类的静态成员</strong></p> <p>​	使用作用域运算符直接访问静态成员。虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">double</span> r<span class="token punctuation">;</span>
r <span class="token operator">=</span> <span class="token class-name">Account</span><span class="token double-colon punctuation">::</span><span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用作用域运算符访问静态成员</span>

Account ac1<span class="token punctuation">;</span>
Account <span class="token operator">*</span>ac2 <span class="token operator">=</span> <span class="token operator">&amp;</span>acl<span class="token punctuation">;</span>
<span class="token comment">// 调用静态成员函数 rate 的等价形式</span>
r <span class="token operator">=</span> acl<span class="token punctuation">.</span><span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过 Account 的对象或引用</span>
r <span class="token operator">=</span> ac2<span class="token operator">-&gt;</span><span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过指向 Account 对象的指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>成员函数不用通过作用域运算符就能直接使用静态成员。</p> <p><strong>定义静态成员</strong></p> <p>​	和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。<code>static</code>关键字则只出现在类内部的声明语句中。</p> <p>​	在类外部定义静态成员时，不能重复<code>static</code>关键字，其只能用于类内部的声明语句。</p> <p>​	由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。</p> <p>​	要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。</p> <p><strong>静态成员的类内初始化</strong></p> <p>​	通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供 <code>const</code> 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> interestRate<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> period <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>  <span class="token comment">// period是常量表达式</span>
    <span class="token keyword">double</span> daily_tbl<span class="token punctuation">[</span>period<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p> <p><strong>静态成员能用于某些场景，而普通成员不能</strong></p> <p>​	静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Bar</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> Bar mem1<span class="token punctuation">;</span>   <span class="token comment">// 正确:静态成员可以是不完全类型</span>
    Bar <span class="token operator">*</span>mem2<span class="token punctuation">;</span>    <span class="token comment">//正确:指针成员可以是不完全类型</span>
    Bar mem3<span class="token punctuation">;</span>   <span class="token comment">// 错误:数据成员必须是完全类型</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// bkground 表示一个在类中稍后定义的静态成员</span>
    Screen<span class="token operator">&amp;</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">=</span> bkground<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> bkground<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#第一章-开始" class="sidebar-link reco-side-第一章-开始" data-v-b57cc07c>第一章 开始</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#读取数量不定的输入数据" class="sidebar-link reco-side-读取数量不定的输入数据" data-v-b57cc07c>读取数量不定的输入数据</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#缓冲区" class="sidebar-link reco-side-缓冲区" data-v-b57cc07c>缓冲区</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#术语" class="sidebar-link reco-side-术语" data-v-b57cc07c>术语</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#区分「类」「类型」「类型类」「类类型」" class="sidebar-link reco-side-区分「类」「类型」「类型类」「类类型」" data-v-b57cc07c>区分「类」「类型」「类型类」「类类型」</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#第二章-变量和基础类型" class="sidebar-link reco-side-第二章-变量和基础类型" data-v-b57cc07c>第二章 变量和基础类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_2-1基本内置类型" class="sidebar-link reco-side-_2-1基本内置类型" data-v-b57cc07c>2.1基本内置类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_2-2变量" class="sidebar-link reco-side-_2-2变量" data-v-b57cc07c>2.2变量</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_2-3复合类型" class="sidebar-link reco-side-_2-3复合类型" data-v-b57cc07c>2.3复合类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_2-4const限定符" class="sidebar-link reco-side-_2-4const限定符" data-v-b57cc07c>2.4const限定符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_2-5处理类型" class="sidebar-link reco-side-_2-5处理类型" data-v-b57cc07c>2.5处理类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_2-6自定义数据结构" class="sidebar-link reco-side-_2-6自定义数据结构" data-v-b57cc07c>2.6自定义数据结构</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#第三章-字符串、向量和数组" class="sidebar-link reco-side-第三章-字符串、向量和数组" data-v-b57cc07c>第三章 字符串、向量和数组</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_3-1-命名空间的using声明" class="sidebar-link reco-side-_3-1-命名空间的using声明" data-v-b57cc07c>3.1 命名空间的using声明</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_3-2-标准库类型string" class="sidebar-link reco-side-_3-2-标准库类型string" data-v-b57cc07c>3.2 标准库类型string</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_3-3-标准库类型vector" class="sidebar-link reco-side-_3-3-标准库类型vector" data-v-b57cc07c>3.3 标准库类型vector</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_3-4-迭代器介绍" class="sidebar-link reco-side-_3-4-迭代器介绍" data-v-b57cc07c>3.4 迭代器介绍</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_3-5数组" class="sidebar-link reco-side-_3-5数组" data-v-b57cc07c>3.5数组</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_3-6多维数组" class="sidebar-link reco-side-_3-6多维数组" data-v-b57cc07c>3.6多维数组</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#第四章-表达式" class="sidebar-link reco-side-第四章-表达式" data-v-b57cc07c>第四章 表达式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-1基础" class="sidebar-link reco-side-_4-1基础" data-v-b57cc07c>4.1基础</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-2算术运算符" class="sidebar-link reco-side-_4-2算术运算符" data-v-b57cc07c>4.2算术运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-3逻辑和关系运算符" class="sidebar-link reco-side-_4-3逻辑和关系运算符" data-v-b57cc07c>4.3逻辑和关系运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-4赋值运算符" class="sidebar-link reco-side-_4-4赋值运算符" data-v-b57cc07c>4.4赋值运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-5递增和递减运算符" class="sidebar-link reco-side-_4-5递增和递减运算符" data-v-b57cc07c>4.5递增和递减运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-6成员访问运算符" class="sidebar-link reco-side-_4-6成员访问运算符" data-v-b57cc07c>4.6成员访问运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-7条件运算符" class="sidebar-link reco-side-_4-7条件运算符" data-v-b57cc07c>4.7条件运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-8位运算符" class="sidebar-link reco-side-_4-8位运算符" data-v-b57cc07c>4.8位运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-9sizeof运算符" class="sidebar-link reco-side-_4-9sizeof运算符" data-v-b57cc07c>4.9sizeof运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-10逗号运算符" class="sidebar-link reco-side-_4-10逗号运算符" data-v-b57cc07c>4.10逗号运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_4-11类型转换" class="sidebar-link reco-side-_4-11类型转换" data-v-b57cc07c>4.11类型转换</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#第五章-语句" class="sidebar-link reco-side-第五章-语句" data-v-b57cc07c>第五章 语句</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_5-1简单语句" class="sidebar-link reco-side-_5-1简单语句" data-v-b57cc07c>5.1简单语句</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_5-2语句作用域" class="sidebar-link reco-side-_5-2语句作用域" data-v-b57cc07c>5.2语句作用域</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_5-3条件语句" class="sidebar-link reco-side-_5-3条件语句" data-v-b57cc07c>5.3条件语句</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_5-4迭代语句" class="sidebar-link reco-side-_5-4迭代语句" data-v-b57cc07c>5.4迭代语句</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_5-5跳转语句" class="sidebar-link reco-side-_5-5跳转语句" data-v-b57cc07c>5.5跳转语句</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#try语句块和异常处理" class="sidebar-link reco-side-try语句块和异常处理" data-v-b57cc07c>try语句块和异常处理</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#第六章-函数" class="sidebar-link reco-side-第六章-函数" data-v-b57cc07c>第六章 函数</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_6-1-函数基础" class="sidebar-link reco-side-_6-1-函数基础" data-v-b57cc07c>6.1 函数基础</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_6-2参数传递" class="sidebar-link reco-side-_6-2参数传递" data-v-b57cc07c>6.2参数传递</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_6-3返回类型和return语句" class="sidebar-link reco-side-_6-3返回类型和return语句" data-v-b57cc07c>6.3返回类型和return语句</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_6-4函数重载" class="sidebar-link reco-side-_6-4函数重载" data-v-b57cc07c>6.4函数重载</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_6-5特殊用途语言特性" class="sidebar-link reco-side-_6-5特殊用途语言特性" data-v-b57cc07c>6.5特殊用途语言特性</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_6-6函数匹配" class="sidebar-link reco-side-_6-6函数匹配" data-v-b57cc07c>6.6函数匹配</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_6-7函数指针" class="sidebar-link reco-side-_6-7函数指针" data-v-b57cc07c>6.7函数指针</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#第七章-类" class="sidebar-link reco-side-第七章-类" data-v-b57cc07c>第七章 类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_7-1定义抽象数据类型" class="sidebar-link reco-side-_7-1定义抽象数据类型" data-v-b57cc07c>7.1定义抽象数据类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_7-2访问控制与封装" class="sidebar-link reco-side-_7-2访问控制与封装" data-v-b57cc07c>7.2访问控制与封装</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_7-3类的其他特性" class="sidebar-link reco-side-_7-3类的其他特性" data-v-b57cc07c>7.3类的其他特性</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_7-4类的作用域" class="sidebar-link reco-side-_7-4类的作用域" data-v-b57cc07c>7.4类的作用域</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_7-5构造函数再探" class="sidebar-link reco-side-_7-5构造函数再探" data-v-b57cc07c>7.5构造函数再探</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20Primer%20One.html#_7-6类的静态成员" class="sidebar-link reco-side-_7-6类的静态成员" data-v-b57cc07c>7.6类的静态成员</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.c8e3a0f1.js" defer></script><script src="/assets/js/3.1f40c1f2.js" defer></script><script src="/assets/js/1.fd77260d.js" defer></script><script src="/assets/js/13.93844b51.js" defer></script>
  </body>
</html>
