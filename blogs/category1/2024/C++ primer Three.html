<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ Primer 第三部分 | blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="陌小阳的博客">
    <meta name="description" content="this is my blog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.47a191c6.css" as="style"><link rel="preload" href="/assets/js/app.c8e3a0f1.js" as="script"><link rel="preload" href="/assets/js/3.1f40c1f2.js" as="script"><link rel="preload" href="/assets/js/1.fd77260d.js" as="script"><link rel="preload" href="/assets/js/15.54763910.js" as="script"><link rel="prefetch" href="/assets/js/10.27468c1b.js"><link rel="prefetch" href="/assets/js/11.02b03c80.js"><link rel="prefetch" href="/assets/js/12.15f74c8b.js"><link rel="prefetch" href="/assets/js/13.93844b51.js"><link rel="prefetch" href="/assets/js/14.645c3afc.js"><link rel="prefetch" href="/assets/js/16.7ce4fb83.js"><link rel="prefetch" href="/assets/js/17.2a6c8b67.js"><link rel="prefetch" href="/assets/js/18.5af2a41f.js"><link rel="prefetch" href="/assets/js/19.8a6002cd.js"><link rel="prefetch" href="/assets/js/20.13402627.js"><link rel="prefetch" href="/assets/js/21.72517caa.js"><link rel="prefetch" href="/assets/js/22.b9eb4d25.js"><link rel="prefetch" href="/assets/js/4.51d906d3.js"><link rel="prefetch" href="/assets/js/5.2b3573cc.js"><link rel="prefetch" href="/assets/js/6.b8c0fc1c.js"><link rel="prefetch" href="/assets/js/7.d62414bd.js"><link rel="prefetch" href="/assets/js/8.69f56ef7.js"><link rel="prefetch" href="/assets/js/9.d4a50642.js">
    <link rel="stylesheet" href="/assets/css/0.styles.47a191c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>blog</h3> <p class="description" data-v-59e6cb88>this is my blog</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>mo_xiao_yang</span>
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/C++/" class="nav-link"><i class="undefined"></i>
  C++
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  else
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Computer Fundamentals/" class="nav-link"><i class="undefined"></i>
  Computer Fundamentals
</a></li><li class="dropdown-item"><!----> <a href="/categories/CMake/" class="nav-link"><i class="undefined"></i>
  CMake
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun/md_notebook" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  md文档仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/pikaqiu.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    mo_xiao_yang
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>12</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>5</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/C++/" class="nav-link"><i class="undefined"></i>
  C++
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  else
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Computer Fundamentals/" class="nav-link"><i class="undefined"></i>
  Computer Fundamentals
</a></li><li class="dropdown-item"><!----> <a href="/categories/CMake/" class="nav-link"><i class="undefined"></i>
  CMake
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/moyangsun/md_notebook" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  md文档仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>C++ Primer 第三部分</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>mo_xiao_yang</span>
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">C++ Primer 第三部分</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>mo_xiao_yang</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>4/27/2024</span></i> <i class="iconfont reco-eye" data-v-8a445198><span id="/blogs/category1/2024/C++%20primer%20Three.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-8a445198><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>C++</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="c-primer-第三部分"><a href="#c-primer-第三部分" class="header-anchor">#</a> C++ primer 第三部分</h1> <h2 id="第13章-拷贝控制"><a href="#第13章-拷贝控制" class="header-anchor">#</a> 第13章 拷贝控制</h2> <p>​		一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁操作。</p> <ul><li><p>拷贝构造函数（copy constructor）</p></li> <li><p>拷贝赋值运算符（copy-assignment operator）</p></li> <li><p>移动构造函数（move constructor）</p></li> <li><p>移动赋值运算符（move-assignment operator）</p></li> <li><p>析构函数（destructor）</p> <p>​	这些操作统称为拷贝控制操作（copy control）。</p> <p>​	在定义任何类时，拷贝控制操作都是必要部分。</p></li></ul> <h3 id="_13-1-拷贝、赋值与销毁"><a href="#_13-1-拷贝、赋值与销毁" class="header-anchor">#</a> 13.1 拷贝、赋值与销毁</h3> <h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="header-anchor">#</a> 拷贝构造函数</h4> <p>​		如果一个构造函数的第一个参数是自身类类型的引用（几乎总是<code>const</code>引用），且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 默认构造函数</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 拷贝构造函数</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​		拷贝构造函数的第一个参数必须是一个引用类型，拷贝构造函数通常不应该是 <code>explicit</code>。</p> <p><strong>合成拷贝构造函数</strong></p> <p>​		如果类未定义自己的拷贝构造函数，编译器会为类合成一个，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。一般情况下，合成拷贝构造函数会将其参数的非<code>static</code>成员逐个拷贝到正在创建的对象中。</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>class Sales_data
{
public:
    // 其他成员和构造函数的定义，如前
    // 与合成的拷贝构造函数等价的拷贝构造函数的声明
    Sales_data(const Sales_data&amp;);
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};

// 与 Sales_data 的合成的拷贝构造函数等价
Sales_data::Sales_data(const Sales_data &amp;orig):
    bookNo(orig.bookNo),    // 使用 string 的拷贝构造函数
    units_sold(orig.units_sold),    // 拷贝orig.units_sold
    revenue(orig.revenue)   // 拷贝 orig.revenue
    { } // 空函数体
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>拷贝初始化</strong></p> <p>​		使用直接初始化时，实际上是要求编译器按照函数匹配规则来选择与实参最匹配的构造函数。使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string <span class="token function">dots</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 直接初始化</span>
string <span class="token function">s</span><span class="token punctuation">(</span>dots<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 直接初始化</span>
string s2 <span class="token operator">=</span> dots<span class="token punctuation">;</span>       <span class="token comment">// 拷贝初始化</span>
string null_book <span class="token operator">=</span> <span class="token string">&quot;9-999-99999-9&quot;</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝初始化</span>
string nines <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 拷贝初始化</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		拷贝初始化通常使用拷贝构造函数来完成。但如果一个类拥有移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。</p> <p>​		发生拷贝初始化的情况：</p> <ul><li>用<code>=</code>定义变量。</li> <li>将对象作为实参传递给非引用类型的形参。</li> <li>从返回类型为非引用类型的函数返回对象。</li> <li>用花括号列表初始化数组中的元素或聚合类中的成员。</li></ul> <p><strong>参数和返回值</strong></p> <p>​		在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。</p> <p>​		拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功一一为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。</p> <p><strong>拷贝初始化的限制</strong></p> <p>​		当传递一个实参或者从函数返回一个值时，不能隐式使用<code>explicit</code>构造函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 正确:直接初始化</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">// 错误:接受大小参数的构造函数是 explicit 的</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// f的参数进行拷贝初始化</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 错误:不能用一个 explicit 的构造函数拷贝一个实参</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 正确:从一个int 直接构造一个临时 vector</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>编译器可以绕过拷贝构造函数</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string null book<span class="token operator">=</span><span class="token string">&quot;9-999-99999-9&quot;</span><span class="token punctuation">;</span><span class="token comment">// 拷贝初始化</span>
string null <span class="token function">book</span><span class="token punctuation">(</span><span class="token string">&quot;9-999-99999-9&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 编译器略过了拷贝构造函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="header-anchor">#</a> 拷贝赋值运算符</h4> <p><strong>重载赋值运算符</strong></p> <p>​		重载运算符（overloaded operator）的参数表示运算符的运算对象。</p> <p>​		如果一个运算符是成员函数，则其左侧运算对象会绑定到隐式的<code>this</code>参数上。</p> <p>​		赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 赋值运算符</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</p> <p>​		如果类未定义自己的拷贝赋值运算符，编译器会为类合成一个。一般情况下，合成拷贝赋值运算符会将其右侧运算对象的非<code>static</code>成员逐个赋值给左侧运算对象的对应成员，之后返回左侧运算对象的引用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 等价于合成拷贝赋值运算符</span>
Sales_data<span class="token operator">&amp;</span> Sales_data<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    bookNo <span class="token operator">=</span> rhs<span class="token punctuation">.</span>bookNo<span class="token punctuation">;</span>    <span class="token comment">// 调用 string::operator=</span>
    units_sold <span class="token operator">=</span> rhs<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>    <span class="token comment">// 使用内置的 int 赋值</span>
    revenue <span class="token operator">=</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>  <span class="token comment">// 使用内置的 double赋值</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>   <span class="token comment">// 返回一个此对象的引用</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="析构函数"><a href="#析构函数" class="header-anchor">#</a> 析构函数</h4> <p>​		析构函数负责释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。</p> <p>​		析构函数的名字由波浪号<code>~</code>接类名构成，它没有返回值，也不接受参数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 析构函数</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		由于析构函数不接受参数，所以它不能被重载。对一个给定类，只会有唯一一个析构函数。</p> <p><strong>析构函数完成什么工作</strong></p> <p>​		由于析构函数不接受参数，所以它不能被重载。</p> <p>​		如果类未定义自己的析构函数，编译器会为类合成一个。合成析构函数的函数体为空。</p> <p>​		析构函数首先执行函数体，然后再销毁数据成员。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。成员按照初始化顺序的逆序销毁。</p> <p>​		隐式销毁一个内置指针类型的成员不会<code>delete</code>它所指向的对象。</p> <p><strong>什么时候会调用析构函数</strong></p> <p>​		无论何时一个对象被销毁，都会自动调用其析构函数。</p> <p>​		当指向一个对象的引用或指针离开作用域时，该对象的析构函数不会执行。</p> <h4 id="三-五法则"><a href="#三-五法则" class="header-anchor">#</a> 三/五法则</h4> <p><strong>需要析构函数的类一般也需要拷贝和赋值操作</strong></p> <p>​		通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p> <p>如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。</p> <p><strong>需要拷贝操作的类一般也需要赋值操作，反之亦然。</strong></p> <p>​		如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然一如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p> <h4 id="使用-default"><a href="#使用-default" class="header-anchor">#</a> 使用=default</h4> <p>​		可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成版本。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 拷贝控制成员;使用 default</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​		在类内使用<code>=default</code>修饰成员声明时，合成的函数是隐式内联的。如果不希望合成的是内联函数，应该只对成员的类外定义使用<code>=default</code>。</p> <p>​		只能对具有合成版本的成员函数使用<code>=default</code>。(即，跌认构造函数或拷贝控制成员)。</p> <h4 id="阻止拷贝"><a href="#阻止拷贝" class="header-anchor">#</a> 阻止拷贝</h4> <p>​		大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是显式地还是隐式地。</p> <p><strong>定义删除的函数</strong></p> <p>​		在C++11新标准中，将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）可以阻止类对象的拷贝。删除的函数是一种虽然进行了声明，但是却不能以任何方式使用的函数。定义删除函数的方式是在函数的形参列表后面添加<code>=delete</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">NoCopy</span>
<span class="token punctuation">{</span>
    <span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 使用合成的默认构造函数</span>
    <span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token keyword">const</span> NoCopy<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// 阻止拷贝</span>
    NoCopy <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NoCopy<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// 阻止赋值</span>
    <span class="token operator">~</span><span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 使用合成的析构函数</span>
    <span class="token comment">// 其他成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>=delete</code>和<code>=default</code>有两点不同：</p> <ul><li><code>=delete</code>可以对任何函数使用；<code>=default</code>只能对具有合成版本的函数使用。</li> <li><code>=delete</code>必须出现在函数第一次声明的地方；<code>=default</code>既能出现在类内，也能出现在类外</li></ul> <p><strong>析构函数不能是删除的成员</strong></p> <p>​		析构函数不能是删除的函数。对于析构函数被删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。</p> <p>​		对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">NoDtor</span><span class="token punctuation">{</span>
    <span class="token function">NoDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 使用合成默认构造函数</span>
    <span class="token operator">~</span><span class="token function">NoDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>；
<span class="token comment">// 我们不能销毁 NoDtor 类型的对象</span>
NoDtor nd<span class="token punctuation">;</span><span class="token comment">// 错误:NoDtor 的析构函数是删除的</span>
NoDtor <span class="token operator">*</span>p<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NoDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正确:但我们不能 delete p</span>
<span class="token keyword">delete</span> p<span class="token punctuation">;</span><span class="token comment">// 错误:NoDtor 的析构函数是删除的</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。</p> <p><strong>合成的拷贝控制成员可能是删除的</strong></p> <p>​		如果一个类中有数据成员不能默认构造、拷贝或销毁，则对应的合成拷贝控制成员将被定义为删除的。</p> <p>​		本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p> <p><strong>private 拷贝控制</strong></p> <p>​		在旧版本的C++标准中，类通过将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>成员来阻止类对象的拷贝。在新标准中建议使用<code>=delete</code>而非<code>private</code>。</p> <h3 id="_13-2-拷贝控制和资源管理"><a href="#_13-2-拷贝控制和资源管理" class="header-anchor">#</a> 13.2 拷贝控制和资源管理</h3> <p>​		通常，管理类外资源的类必须定义拷贝控制成员。</p> <h4 id="行为像值的类"><a href="#行为像值的类" class="header-anchor">#</a> 行为像值的类</h4> <p>行为向值的类需要：</p> <ul><li>定义一个拷贝构造函数，完成 <code>string</code> 的拷贝，而不是拷贝指针</li> <li>定义一个析构函数来释放 <code>string</code></li> <li>定义一个拷贝赋值运算符来释放对象当前的 <code>string</code>，并从右侧运算对象拷贝<code>string</code></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">HasPtr</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token comment">// 对ps 指向的 string，每个 HasPtr 对象都有自己的拷贝</span>
    <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    HasPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> ps<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span>ps<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>类值拷贝赋值运算符</strong></p> <p>编写赋值运算符时有两点需要注意：</p> <ul><li><p>赋值运算符通常结合了拷贝构造函数和析构函数的工作。</p> <p>编写赋值运算符时，一个好的方法是先将右侧运算对象拷贝到一个局部临时对象中。拷贝完成后，就可以安全地销毁左侧运算对象的现有成员了。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>HasPtr<span class="token operator">&amp;</span> HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> newp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝底层 string</span>
    <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>   <span class="token comment">// 释放旧内存</span>
    ps <span class="token operator">=</span> newp<span class="token punctuation">;</span>   <span class="token comment">// 从右侧运算对象拷贝数据到本对象</span>
    i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>   <span class="token comment">// 返回本对象</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>即使将一个对象赋予它自身，赋值运算符也能正确工作。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 这样编写赋值运算符是错误的!</span>
HasPtr<span class="token operator">&amp;</span> HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>   <span class="token comment">// 释放对象指向的 string</span>
    <span class="token comment">// 如果 rhs 和*this 是同一个对象，我们就将从已释放的内存中拷贝数据!</span>
    ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。</p></li></ul> <h4 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="header-anchor">#</a> 定义行为像指针的类</h4> <p>​		有时我们希望直接管理资源。这种情况下，使用引用计数就要很用用了。</p> <p><strong>引用计数</strong></p> <p>工作方式如下</p> <ul><li>除了初始化对象外，每个构造函数(拷贝构造函数除外) 还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有-个对象共享状态，因此将计数器初始化为 1。</li> <li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li> <li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为 0，则析构函数释放状态。</li> <li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为 0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li></ul> <p><strong>定义一个使用引用计数的类</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">HasPtr</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 构造函数分配新的 string 和新的计数器，将计数器置为 1</span>
    <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 拷贝构造函数拷贝所有三个数据成员，并递增计数器</span>
    <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">ps</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">use</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>use<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span><span class="token operator">*</span>use<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    HasPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span>ps<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>size_t <span class="token operator">*</span>use<span class="token punctuation">;</span> <span class="token comment">// 用来记录有多少个对象共享*ps 的成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>类指针的拷贝成员“篡改”引用计数</strong></p> <p>​		析构函数释放内存前应该判断是否还有其他对象指向这块内存。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token class-name">HasPtr</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token operator">*</span>use <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>   <span class="token comment">// 如果引用计数变为 0</span>
        <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>   <span class="token comment">// 释放 string 内存</span>
        <span class="token keyword">delete</span> use<span class="token punctuation">;</span>  <span class="token comment">// 释放计数器内存</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

HasPtr<span class="token operator">&amp;</span> HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">++</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>use<span class="token punctuation">;</span>    <span class="token comment">// 递增右侧运算对象的引用计数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token operator">*</span>use <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>   <span class="token comment">// 然后递减本对象的引用计数</span>
        <span class="token keyword">delete</span> ps<span class="token punctuation">;</span> <span class="token comment">// 如果没有其他用户</span>
        <span class="token keyword">delete</span> use<span class="token punctuation">;</span> <span class="token comment">// 释放本对象分配的成员</span>
    <span class="token punctuation">}</span>
    ps <span class="token operator">=</span> rhs<span class="token punctuation">.</span>ps<span class="token punctuation">;</span>    <span class="token comment">// 将数据从 rhs 拷贝到本对象</span>
    i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    use <span class="token operator">=</span> rhs<span class="token punctuation">.</span>use<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>   <span class="token comment">// 返回本对象</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_13-3-交换操作"><a href="#_13-3-交换操作" class="header-anchor">#</a> 13.3 交换操作</h3> <p><strong>编写我们自己的 swap函数</strong></p> <p>​		通常，管理类外资源的类会定义<code>swap</code>函数。如果一个类定义了自己的<code>swap</code>函数，算法将使用自定义版本，否则将使用标准库定义的<code>swap</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">HasPtr</span>
<span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>HasPtr<span class="token operator">&amp;</span><span class="token punctuation">,</span> HasPtr<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 其他函数定义</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>HasPtr <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>ps<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 交换指针，而不是 string 数据</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>i<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 交换int 成员</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>swap 函数应该调用 swap，而不是std::swap</strong></p> <p>​		一些算法在交换两个元素时会调用<code>swap</code>函数，其中每个<code>swap</code>调用都应该是未加限定的。如果存在类型特定的<code>swap</code>版本，其匹配程度会优于<code>std</code>中定义的版本（假定作用域中有<code>using</code>声明）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Foo <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> Foo <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 错误:这个函数使用了标准库版本的 swap，而不是 HasPtr 版本</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>h<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 交换类型 Foo的其他成员</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Foo <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> Foo <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>h<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 HasPtr 版本的 swap</span>
    <span class="token comment">// 交换类型 Foo 的其他成员</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​		与拷贝控制成员不同，<code>swap</code>函数并不是必要的。但是对于分配了资源的类，定义<code>swap</code>可能是一种重要的优化手段。</p> <p>​		由于<code>swap</code>函数的存在就是为了优化代码，所以一般将其声明为内联函数。</p> <p><strong>在赋值运算符中使用swap</strong></p> <p>​		定义了<code>swap</code>的类通常用<code>swap</code>来实现赋值运算符。在这种版本的赋值运算符中，右侧运算对象以值方式传递，然后将左侧运算对象与右侧运算对象的副本进行交换（拷贝并交换，copy and swap）。这种方式可以正确处理自赋值情况。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数</span>
<span class="token comment">// 将右侧运算对象中的 string 拷贝到 rhs</span>
HasPtr<span class="token operator">&amp;</span> HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>HasPtr rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 交换左侧运算对象和局部变量 rhs 的内容</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// rhs 现在指向本对象曾经使用的内存</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>       <span class="token comment">// rhs 被销毁，从而 delete了rhs 中的指针</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​		使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。</p> <h3 id="_13-4-拷贝控制示例"><a href="#_13-4-拷贝控制示例" class="header-anchor">#</a> 13.4 拷贝控制示例</h3> <p>​		虽然通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己的拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助来进行簿记工作或其他操作。</p> <p>​		拷贝赋值运算符通常结合了拷贝构造函数和析构函数的工作。在这种情况下，公共部分应该放在<code>private</code>的工具函数中完成。</p> <h3 id="_13-5-动态内存管理类"><a href="#_13-5-动态内存管理类" class="header-anchor">#</a> 13.5 动态内存管理类</h3> <p>​		某些类需要在运行时分配可变大小的内存空间。这种类通常可以(并且如果它们确实可以的话，一般应该)使用标准库容器来保存它们的数据。但是，这一策略并不是对每个类都适用;某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。</p> <p>​		移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象中。</p> <h3 id="_13-6-对象移动"><a href="#_13-6-对象移动" class="header-anchor">#</a> 13.6 对象移动</h3> <p>​		某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。</p> <p>​		在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p> <p>​		标准库容器、<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。IO类和<code>unique_ptr</code>类可以移动但不能拷贝。</p> <h4 id="右值引用"><a href="#右值引用" class="header-anchor">#</a> 右值引用</h4> <p>​		为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过<code>&amp;&amp;</code>来获得右值引用。右值引用有一个重要的性质一只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。</p> <p>​		为了与右值引用区分开来，我们可以称常规引用为左值引用 ,我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token comment">// 正确:r引用i</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr <span class="token operator">=</span> i<span class="token punctuation">;</span>       <span class="token comment">// 错误:不能将一个右值引用绑定到一个左值上</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment">// 错误:i*42是一个右值</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token comment">// 正确:我们可以将一个 const 的引用绑定到一个右值上</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span>        <span class="token comment">// 正确:将rr2绑定到乘法结果上</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>左值持久;右值短暂</strong></p> <p>​		考察左值和右值表达式的列表，两者相互区别之处就很明显了:左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p> <p>​		由于右值引用只能绑定到临时对象，我们得知</p> <ul><li>所引用的对象将要被销毁</li> <li>该对象没有其他用户</li></ul> <p>​		右值引用指向将要被销毁的对象。因此我们可以从绑定到右值引用的对象“窃取”状态。</p> <p><strong>变量是左值</strong></p> <p>​		变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>     <span class="token comment">// 正确:字面常量是右值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr2 <span class="token operator">=</span> rr1<span class="token punctuation">;</span>    <span class="token comment">// 错误:表达式 rr1是左值!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>标准库move函数</strong></p> <p>​		调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件<code>utility</code>中。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//右值引用 rr3 绑定到左值 rr1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​		我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p> <p>​		调用<code>move</code>函数的代码应该使用<code>std::move</code>而非<code>move</code>，这样做可以避免潜在的名字冲突。</p> <h4 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="header-anchor">#</a> 移动构造函数和移动赋值运算符</h4> <p>​		类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用，其他任何额外参数都必须有默认值。</p> <p>​		除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。</p> <p><strong>移动操作、标准库容器和异常</strong></p> <p>​		对于构造函数，<code>noexcept</code>位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定<code>noexcept</code>。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">StrVec</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">StrVec</span><span class="token punctuation">(</span>StrVec<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment">// 移动构造函数</span>
    <span class="token comment">// 其他成员的定义，如前</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">StrVec</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token comment">/* 成员初始化器 */</span>
<span class="token punctuation">{</span> <span class="token comment">/* 构造函数体 */</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​		标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。</p> <p>​		不抛出异常的移动构造函数和移动赋值运算符必须标记为 <code>noexcept</code>。</p> <p><strong>移动赋值运算符</strong></p> <p>​		移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为 <code>noexcept</code>。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>StrVec <span class="token operator">&amp;</span>StrVec<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 直接检测自赋值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 释放已有元素</span>
        elements <span class="token operator">=</span> rhs<span class="token punctuation">.</span>elements<span class="token punctuation">;</span>    <span class="token comment">// 从 rhs 接管资源</span>
        first_free <span class="token operator">=</span> rhs<span class="token punctuation">.</span>first_free<span class="token punctuation">;</span>
        cap <span class="token operator">=</span> rhs<span class="token punctuation">.</span>cap<span class="token punctuation">;</span>
        <span class="token comment">// 将 rhs 置于可析构状态</span>
        rhs<span class="token punctuation">.</span>elements <span class="token operator">=</span> rhs<span class="token punctuation">.</span>first_free <span class="token operator">=</span> rhs<span class="token punctuation">.</span>cap <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>移后源对象必须可析构</strong></p> <p>​		在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p> <p><strong>合成的移动操作</strong></p> <p>​		只有当一个类没有定义任何拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 编译器会为X和hasx 合成移动操作</span>
<span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token comment">// 内置类型可以移动</span>
    std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">;</span>   <span class="token comment">// string 定义了自己的移动操作</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">hasX</span>
<span class="token punctuation">{</span>
    X mem<span class="token punctuation">;</span> <span class="token comment">// X 有合成的移动操作</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

X x<span class="token punctuation">,</span> x2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 使用合成的移动构造函数</span>
hasX hx<span class="token punctuation">,</span> hx2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>hx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 使用合成的移动构造函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​		定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作否则，这些成员默认地被定义为删除的。</p> <p><strong>移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝</strong></p> <p>​		与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p> <p>​		定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。</p> <p>​		如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用<code>move</code>函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝构造系教</span>
    <span class="token comment">// 其他成员定义，但 Foo 未定义移动构造函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Foo x<span class="token punctuation">;</span>
Foo <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 拷贝构造函数;x是一个左值</span>
Foo <span class="token function">z</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝构造函数，因为未定义移动构造函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>拷贝并交换赋值运算符和移动操作</strong></p> <p>​		使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 赋值运算符既是移动赋值运算符，也是拷贝赋值运算</span>
HasPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>HasPtr rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

hp <span class="token operator">=</span> hp2<span class="token punctuation">;</span>   <span class="token comment">// hp2 是一个左值;hp2 通过拷贝构造函数来拷贝</span>
hp <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>hp2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 移动构造函数移动 hp2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>更新三/五法则：建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p></blockquote> <p><strong>Message类的移动操作</strong></p> <p>​		移动赋值运算符可以直接检查自赋值情况。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Message<span class="token operator">&amp;</span> Message<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Message <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 直接检查自赋值情况</span>
        remove from <span class="token function">Folders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        contents <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>contents<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动赋值运算符</span>
        move <span class="token function">Folders</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置 Folders 指向本 Message</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>移动迭代器</strong></p> <p>​		C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。</p> <p>​		调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p> <p>​		最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用<code>move</code>操作。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>uninitialized copy<span class="token operator">:</span>
<span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 分配大小两倍于当前规模的内存空间</span>
    <span class="token keyword">auto</span> newcapacity <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">*</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> first <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>newcapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 移动元素</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> uninitialized <span class="token function">copy</span><span class="token punctuation">(</span>make move <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>，
    							make move <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>，
    							first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放旧空间</span>
    elements <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token comment">// 更新指针</span>
    first free <span class="token operator">=</span> last<span class="token punctuation">;</span>
    cap <span class="token operator">=</span> elements <span class="token operator">+</span>newcapacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="header-anchor">#</a> 右值引用和成员函数</h4> <p>​		区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>参数，另一个版本接受一个<code>T&amp;&amp;</code>参数（<code>T</code>为类型）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 拷贝:绑定到任意类型的 X</span>
<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 移动:只能绑定到类型X的可修改的右值</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>右值和左值引用成员函数</strong></p> <p>​		有时可以对右值赋值：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>
s1 <span class="token operator">+</span> s2 <span class="token operator">=</span> <span class="token string">&quot;wow!&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​		在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即<code>this</code>指向的对象）必须是一个左值。</p> <p>​		在非<code>static</code>成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定<code>this</code>的左值/右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示<code>this</code>可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span> <span class="token comment">// 只能向可修改的左值赋值</span>
    <span class="token comment">// Foo 的其他参数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Foo <span class="token operator">&amp;</span>Foo<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 执行将 rhs 赋予本对象所需的工作</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​		一个非<code>static</code>成员函数可以同时使用<code>const</code>和引用限定符，此时引用限定符跟在<code>const</code>限定符之后。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo <span class="token function">someMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token keyword">const</span><span class="token punctuation">;</span>      <span class="token comment">// 错误:const 限定符必须在前</span>
    Foo <span class="token function">anotherMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>   <span class="token comment">// 正确:const 限定符在前</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>重载和引用函数</strong></p> <p>​		引用限定符也可以区分成员函数的重载版本。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>        <span class="token comment">// 可用于可改变的右值</span>
    Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>   <span class="token comment">// 可用于任何类型的 Foo</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">retVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// retVal()是一个右值，调用 Foo::sorted() &amp;&amp;</span>
<span class="token function">retFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// retFoo()是一个左值，调用 Foo::sorted() const &amp;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​		如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
    Foo <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment">// 错误:必须加上引用限定符</span>
    <span class="token comment">// Comp 是函数类型的类型别名</span>
    <span class="token comment">// 此函数类型可以用来比较 int 值</span>
    <span class="token keyword">using</span> Comp <span class="token operator">=</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Foo <span class="token function">sorted</span><span class="token punctuation">(</span>Comp<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确:不同的参数列表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="第14章-重载运算与类型转换"><a href="#第14章-重载运算与类型转换" class="header-anchor">#</a> 第14章 重载运算与类型转换</h2> <h3 id="_14-1-基本概念"><a href="#_14-1-基本概念" class="header-anchor">#</a> 14.1 基本概念</h3> <p>​		重载的运算符是具有特殊名字的函数，它们的名字由关键字<code>operator</code>和其后要定义的运算符号组成。</p> <p>​		重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p> <p>​		如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的<code>this</code>指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</p> <p>​		当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</p> <p>​		只能重载大多数已有的运算符，无权声明新的运算符号。</p> <ul><li><p>可以被重载的运算符：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>+     -       *       /       %       ^
&amp;     |       ~       !       ,       =
&lt;     &gt;       &lt;=      &gt;=      ++      --
&lt;&lt;    &gt;&gt;      ==      !=      &amp;&amp;      ||
+=    -=      /=      %=      ^=      &amp;=
|=    *=      &lt;&lt;=     &gt;&gt;=     []      ()
-&gt;    -&gt;*     new     new []  delete  delete []
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>不能被重载的运算符：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>::    .*      .       ?:
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <p><strong>直接调用一个重载的运算符函数</strong></p> <p>​		重载运算符的优先级和结合律与对应的内置运算符一致。</p> <p>​		可以像调用普通函数一样直接调用运算符函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 一个非成员运算符函数的等价调用</span>
data1 <span class="token operator">+</span> data2<span class="token punctuation">;</span>              <span class="token comment">// 普通的表达式</span>
<span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>data1<span class="token punctuation">,</span> data2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等价的函数调用</span>
data1 <span class="token operator">+=</span> data2<span class="token punctuation">;</span>             <span class="token comment">// 基于“调用”的表达式</span>
data1<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对成员运算符函数的等价调用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>某些运算符不应该被重载</strong></p> <p>​		通常情况下，不应该重载逗号<code>,</code>、取地址<code>&amp;</code>、逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>运算符。</p> <p><strong>使用与内置类型一致的含义</strong></p> <p>​		建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</p> <p><strong>赋值和复合赋值运算符</strong></p> <p>​		如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</p> <p><strong>选择作为成员或者非成员</strong></p> <p>​		把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string s <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
string t <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">;</span>     <span class="token comment">// 正确:我们能把一个const char*加到一个 string 对象中</span>
string u <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span> <span class="token operator">+</span> s<span class="token punctuation">;</span>    <span class="token comment">// 如果+是 string 的成员，则产生错误</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		如何选择将运算符定义为成员函数还是普通函数：</p> <ul><li>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>和成员访问箭头<code>-&gt;</code>运算符必须是成员函数。</li> <li>复合赋值运算符一般是成员函数，但并非必须。</li> <li>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</li> <li>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</li></ul> <h3 id="_14-2-输入和输出运算符"><a href="#_14-2-输入和输出运算符" class="header-anchor">#</a> 14.2 输入和输出运算符</h3> <h4 id="重载输出运算符"><a href="#重载输出运算符" class="header-anchor">#</a> 重载输出运算符&lt;&lt;</h4> <p>​		通常情况下，输出运算符的第一个形参是<code>ostream</code>类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的<code>ostream</code>形参。</p> <p><strong>Sales_data 的输出运算符</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    os <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span>
        <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>revenue <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>输出运算符应该尽量减少格式化操作</strong></p> <p>​		通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p> <p><strong>输入输出运算符必须是非成员函数</strong></p> <p>​		输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</p> <h4 id="重载输人运算符"><a href="#重载输人运算符" class="header-anchor">#</a> 重载输人运算符&gt;&gt;</h4> <p>​		通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</p> <p><strong>Sales_data 的输入运算符</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>istream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">double</span> price<span class="token punctuation">;</span>   <span class="token comment">// 不需要初始化，因为我们将先读入数据到 price，之后才使用它</span>
    is <span class="token operator">&gt;&gt;</span> item<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> item<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> price<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">)</span>    <span class="token comment">// 检查输入是否成功</span>
        item<span class="token punctuation">.</span>revenue <span class="token operator">=</span> item<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> price<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        item <span class="token operator">=</span> <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输入失败:对象被赋予默认的状态</span>
    <span class="token keyword">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​		输入运算符必须处理输入失败的情况，而输出运算符不需要。</p> <p><strong>输入时的错误</strong></p> <p>​		以下情况可能导致读取操作失败：</p> <ul><li>读取了错误类型的数据。</li> <li>读取操作到达文件末尾。</li> <li>遇到输入流的其他错误。</li></ul> <p>​		当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</p> <p>​		如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置<code>failbit</code>状态。<code>eofbit</code>、<code>badbit</code>等错误最好由IO标准库自己标示。</p> <h3 id="_14-3-算术和关系运算符"><a href="#_14-3-算术和关系运算符" class="header-anchor">#</a> 14.3 算术和关系运算符</h3> <p>​		通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</p> <p>​		算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的<code>const</code>类型）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 假设两个对象指向同一本书</span>
Sales_data <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Sales_data sum <span class="token operator">=</span> lhs<span class="token punctuation">;</span>   <span class="token comment">// 把lhs的数据成员拷贝给 sum</span>
    sum <span class="token operator">+=</span> rhs<span class="token punctuation">;</span>     <span class="token comment">// 将 rhs 加到 sum中</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​		如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。</p> <h4 id="相等运算符"><a href="#相等运算符" class="header-anchor">#</a> 相等运算符</h4> <p>相等运算符设计准则：</p> <ul><li><p>如果类在逻辑上有相等性的含义，则应该定义<code>operator==</code>而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</p></li> <li><p>通常情况下，<code>operator==</code>应该具有传递性。</p></li> <li><p>如果类定义了<code>operator==</code>，则也应该定义<code>operator!=</code>。</p></li> <li><p><code>operator==</code>和<code>operator!=</code>中的一个应该把具体工作委托给另一个。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> rhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        lhs<span class="token punctuation">.</span>units_sold <span class="token operator">==</span> rhs<span class="token punctuation">.</span>units_sold <span class="token operator">&amp;&amp;</span>
        lhs<span class="token punctuation">.</span>revenue <span class="token operator">==</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>lhs <span class="token operator">==</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ul> <h4 id="关系运算符"><a href="#关系运算符" class="header-anchor">#</a> 关系运算符</h4> <p>​		定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较实用。</p> <p>​		关系运算符设计准则：</p> <ul><li>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</li> <li>如果类定义了<code>operator==</code>，则关系运算符的定义应该与<code>operator==</code>保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</li> <li>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义<code>operator&lt;</code>。</li></ul> <h3 id="_14-4-赋值运算符"><a href="#_14-4-赋值运算符" class="header-anchor">#</a> 14.4 赋值运算符</h3> <p>​		为了与内置类型的赋值运算符保持一致(也与我们已经定义的拷贝赋值和移动赋值运算一致)，这个新的赋值运算符将返回其左侧运算对象的引用:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>StrVec <span class="token operator">&amp;</span>StrVec<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> il<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// alloc n copy 分配内存空间并从给定范围内拷贝元素</span>
    <span class="token keyword">auto</span> data <span class="token operator">=</span> <span class="token function">alloc_n_copy</span><span class="token punctuation">(</span>il<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> il<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 销毁对象中的元素并释放内存空间</span>
    elements <span class="token operator">=</span> data<span class="token punctuation">.</span>first<span class="token punctuation">;</span>      <span class="token comment">// 更新数据成员使其指向新空间</span>
    space
    first_free <span class="token operator">=</span> cap <span class="token operator">=</span> data<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​		我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</p> <p><strong>复合赋值运算符</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 作为成员的二元运算符:左侧运算对象绑定到隐式的 this 指针</span>
<span class="token comment">// 假定两个对象表示的是同一本书</span>
Sales_data<span class="token operator">&amp;</span> Sales_data<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    units_sold <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
    revenue <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​		赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做这两类运算符都应该返回左侧运算对象的引用。</p> <h3 id="_14-5-下标运算符"><a href="#_14-5-下标运算符" class="header-anchor">#</a> 14.5 下标运算符</h3> <p>​		下标运算符必须定义为成员函数。</p> <p>​		类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">StrVec</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> elements<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> elements<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token operator">*</span>elements<span class="token punctuation">;</span>  <span class="token comment">// 指向数组首元素的指针</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_14-6-递增递减运算符"><a href="#_14-6-递增递减运算符" class="header-anchor">#</a> 14.6 递增递减运算符</h3> <p>​		定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</p> <p><strong>定义前置递增/递减运算符</strong></p> <p>​		为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 前置版本:返回递增/递减对象的引用</span>
StrBlobPtr<span class="token operator">&amp;</span> StrBlobPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token operator">++</span>curr<span class="token punctuation">;</span>     <span class="token comment">// 将 curr 在当前状态下向前移动一个元素</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>区分前置和后置运算符</strong></p> <p>​		后置递增或递减运算符接受一个额外的（不被使用）<code>int</code>类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 递增和递减运算符</span>
    StrBlobPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 前置运算符</span>
    StrBlobPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    StrBlobPtr <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 后置运算符</span>
    StrBlobPtr <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​		为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的<code>const</code>类型）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>StrBlobPtr StrBlobPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    StrBlobPtr ret <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment">// 记录当前的值</span>
    <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>      <span class="token comment">// 向前移动一个元素，前置++需要检查递增的有效性</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>   <span class="token comment">// 返回之前记录的状态</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>显式地调用后置运算符</strong></p> <p>​		如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>StrBlobPtr p(a1);   // p指向al中的vector
p.operator++(0);    // 调用后置版本的 operator++
p.operator++();     // 调用前置版本的 operator++
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_14-7-成员访问运算符"><a href="#_14-7-成员访问运算符" class="header-anchor">#</a> 14.7 成员访问运算符</h3> <p>​		箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</p> <p>​		重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// (*p)是对象所指的 vector</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>   <span class="token comment">// 将实际工作委托给解引用运算符</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>对箭头运算符返回值的限定</strong></p> <p>​		对于形如<code>point-&gt;mem</code>的表达式来说，<code>point</code>必须是指向类对象的指针或者是一个重载了<code>operator-&gt;</code>的类的对象。<code>point</code>类型不同，<code>point-&gt;mem</code>的含义也不同。</p> <ul><li>如果<code>point</code>是指针，则调用内置箭头运算符，表达式等价于<code>(*point).mem</code>。</li> <li>如果<code>point</code>是重载了<code>operator-&gt;</code>的类的对象，则使用<code>point.operator-&gt;()</code>的结果来获取<code>mem</code>，表达式等价于<code>(point.operator-&gt;())-&gt;mem</code>。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#第13章-拷贝控制" class="sidebar-link reco-side-第13章-拷贝控制" data-v-b57cc07c>第13章 拷贝控制</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_13-1-拷贝、赋值与销毁" class="sidebar-link reco-side-_13-1-拷贝、赋值与销毁" data-v-b57cc07c>13.1 拷贝、赋值与销毁</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_13-2-拷贝控制和资源管理" class="sidebar-link reco-side-_13-2-拷贝控制和资源管理" data-v-b57cc07c>13.2 拷贝控制和资源管理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_13-3-交换操作" class="sidebar-link reco-side-_13-3-交换操作" data-v-b57cc07c>13.3 交换操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_13-4-拷贝控制示例" class="sidebar-link reco-side-_13-4-拷贝控制示例" data-v-b57cc07c>13.4 拷贝控制示例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_13-5-动态内存管理类" class="sidebar-link reco-side-_13-5-动态内存管理类" data-v-b57cc07c>13.5 动态内存管理类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_13-6-对象移动" class="sidebar-link reco-side-_13-6-对象移动" data-v-b57cc07c>13.6 对象移动</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#第14章-重载运算与类型转换" class="sidebar-link reco-side-第14章-重载运算与类型转换" data-v-b57cc07c>第14章 重载运算与类型转换</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_14-1-基本概念" class="sidebar-link reco-side-_14-1-基本概念" data-v-b57cc07c>14.1 基本概念</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_14-2-输入和输出运算符" class="sidebar-link reco-side-_14-2-输入和输出运算符" data-v-b57cc07c>14.2 输入和输出运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_14-3-算术和关系运算符" class="sidebar-link reco-side-_14-3-算术和关系运算符" data-v-b57cc07c>14.3 算术和关系运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_14-4-赋值运算符" class="sidebar-link reco-side-_14-4-赋值运算符" data-v-b57cc07c>14.4 赋值运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_14-5-下标运算符" class="sidebar-link reco-side-_14-5-下标运算符" data-v-b57cc07c>14.5 下标运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_14-6-递增递减运算符" class="sidebar-link reco-side-_14-6-递增递减运算符" data-v-b57cc07c>14.6 递增递减运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/category1/2024/C++%20primer%20Three.html#_14-7-成员访问运算符" class="sidebar-link reco-side-_14-7-成员访问运算符" data-v-b57cc07c>14.7 成员访问运算符</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.c8e3a0f1.js" defer></script><script src="/assets/js/3.1f40c1f2.js" defer></script><script src="/assets/js/1.fd77260d.js" defer></script><script src="/assets/js/15.54763910.js" defer></script>
  </body>
</html>
